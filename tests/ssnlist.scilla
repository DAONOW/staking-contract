scilla_version 0
import ListUtils IntUtils BoolUtils
library SSNList
type Ssn =
| Ssn of Bool Uint128 Uint128 String String String Uint128 Uint128 Uint128 ByStr20
type SsnRewardShare =
| SsnRewardShare of ByStr20 Uint128
type DelegCycleInfo =
| DelegCycleInfo of ByStr20 Uint128 ByStr20
type SSNCycleInfo =
| SSNCycleInfo of Uint128 Uint128
type TmpArg =
| TmpArg of ByStr20 ByStr20 Uint128
let one_msg =
fun (m : Message) =>
let e = Nil {Message} in
Cons {Message} m e
let uint128_one =  Uint128 1
let uint128_zero = Uint128 0
let list_filter_between =
fun (left: Uint128) =>
fun (right: Uint128) =>
fun (l: List Uint128) =>
let fil = @list_filter Uint128 in
let f = fun (element: Uint128) =>
let res_l = builtin lt left element in
let res_r = uint128_le element right in
andb res_l res_r
in fil f l
let option_value =
tfun 'A =>
fun (default: 'A) =>
fun (opt_val: Option 'A) =>
match opt_val with
| Some v => v
| None => default
end
let option_map_uint128_uint128_value =
let f = @option_value (Map Uint128 Uint128) in
let emt = Emp Uint128 Uint128 in
f emt
let option_uint128_value =
let f = @option_value Uint128 in
f uint128_zero
let sub_one_to_zero =
fun (x: Uint128) =>
let less_than_one = builtin lt x uint128_one in
match less_than_one with
| True =>
uint128_zero
| False =>
let res = builtin sub x uint128_one in
res
end
let option_add =
fun (x_opt: Option Uint128) =>
fun (y_opt: Option Uint128) =>
match x_opt with
| Some x =>
let y = option_uint128_value y_opt in
let res = builtin add x y in
Some {Uint128} res
| None => y_opt
end
let change_rate =
fun (old: Uint128) =>
fun (new: Uint128) =>
let a = builtin lt old new in
match a with
| True =>
builtin sub new old
| False =>
builtin sub old new
end
let bool_active = True
let bool_inactive = False
let uint128_10_power_7 = Uint128 10000000
let uint128_100 = Uint128 100
let addfunds_tag = "AddFunds"
type Error =
| ContractFreezedFailure
| VerifierValidationFailed
| AdminValidationFailed
| ProxyValidationFailed
| DelegDoesNotExistAtSSN
| DelegDepositBlowMin
| DelegHasBufferedDeposit
| ChangeCommError
| SSNNotExist
| DelegNotExist
| SSNAlreadyExist
| DelegHasUnwithdrawRewards
| DelegHasNoSufficientAmt
| SSNNoComm
| DelegStakeNotEnough
| GZILValidationFailed
| ExceedMaxChangeRate
| ExceedMaxCommRate
| InvalidTotalAmt
| InvalidRecvAddr
| VerifierNotSet
<<<<<<< HEAD
| NotTimeYet
| NoPendingWithdrawal
| InvalidWithdrawAmt
=======
>>>>>>> 5ea1b34... fix: clarify reward cycle
| VerifierRecvAddrNotSet
let make_error =
fun (result: Error) =>
let result_code =
match result with
| ContractFreezedFailure => Int32 -1
| VerifierValidationFailed => Int32 -2
| AdminValidationFailed => Int32 -3
| ProxyValidationFailed => Int32 -4
| DelegDoesNotExistAtSSN => Int32 -5
| DelegDepositBlowMin => Int32 -6
| DelegHasBufferedDeposit => Int32 -7
| ChangeCommError => Int32 -8
| SSNNotExist => Int32 -9
| DelegNotExist => Int32 -10
| SSNAlreadyExist => Int32 -11
| DelegHasUnwithdrawRewards => Int32 -12
| DelegHasNoSufficientAmt => Int32 -13
| SSNNoComm => Int32 -14
| DelegStakeNotEnough => Int32 -15
| GZILValidationFailed => Int32 -16
| ExceedMaxChangeRate => Int32 -17
| ExceedMaxCommRate => Int32 -18
| InvalidTotalAmt => Int32 -19
| InvalidRecvAddr => Int32 -20
| VerifierNotSet => Int32 -21
| NotTimeYet => Int32 -22
| NoPendingWithdrawal => Int32 -23
| InvalidWithdrawAmt => Int32 -24
| VerifierRecvAddrNotSet => Int32 -25
end
in
{ _exception: "Error"; code: result_code }
contract SSNList(
init_admin: ByStr20,
proxy_address: ByStr20,
gzil_address: ByStr20
)
field ssnlist: Map ByStr20 Ssn = Emp ByStr20 Ssn
field comm_for_ssn: Map ByStr20 (Map Uint128 Uint128) = Emp ByStr20 (Map Uint128 Uint128)
field deposit_amt_deleg: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field ssn_deleg_amt: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field buff_deposit_deleg: Map ByStr20 (Map ByStr20 (Map Uint128 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint128 Uint128))
field direct_deposit_deleg: Map ByStr20 (Map ByStr20 (Map Uint128 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint128 Uint128))
field last_withdraw_cycle_deleg: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field last_buf_deposit_cycle_deleg: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field stake_ssn_per_cycle: Map ByStr20 (Map Uint128 SSNCycleInfo) = Emp ByStr20 (Map Uint128 SSNCycleInfo)
field withdrawal_pending: Map ByStr20 (Map BNum Uint128) = Emp ByStr20 (Map BNum Uint128)
field bnum_req: Uint128 = Uint128 10000
field stake_deleg_per_cycle: Map Uint128 Uint128 = Emp Uint128 Uint128
field rewards_amt_deleg: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field avaiable_withdrawal: Uint128 = uint128_zero
field current_deleg: Option ByStr20 = None {ByStr20}
field reward_cycle_list: List Uint128   =  Nil {Uint128}
field verifier: Option ByStr20 = None {ByStr20}
field verifier_receiving_addr: Option ByStr20 = None {ByStr20}
field minstake: Uint128 = Uint128 0
field mindelegstake: Uint128 = Uint128 1000000000000
field contractadmin: ByStr20  = init_admin
field proxyaddr: ByStr20 = proxy_address
field gziladdr: ByStr20 = gzil_address
field lastrewardcycle: Uint128 = uint128_one
field paused: Bool = True
field maxcommchangerate: Uint128 = uint128_one
field maxcommrate: Uint128 = Uint128 1000000000
field totalstakeamount: Uint128 = uint128_zero
procedure TruncateDeleg(deleg: ByStr20, ssnaddr: ByStr20)
delete deposit_amt_deleg[deleg][ssnaddr];
delete ssn_deleg_amt[ssnaddr][deleg];
delete buff_deposit_deleg[deleg][ssnaddr];
delete direct_deposit_deleg[deleg][ssnaddr];
delete last_withdraw_cycle_deleg[deleg][ssnaddr];
delete last_buf_deposit_cycle_deleg[deleg][ssnaddr]
end
procedure ThrowError(err: Error)
e = make_error err;
throw e
end
procedure ValidateRate(rate: Uint128)
max_rate <- maxcommrate;
validate = uint128_le rate max_rate;
match validate with
| True =>
| False =>
e = ExceedMaxCommRate;
ThrowError e
end
end
procedure ValidateChangeRate(old: Uint128, new: Uint128)
maxcommchangerate_l <- maxcommchangerate;
absolute_change = change_rate old new;
absolute_change = builtin div absolute_change uint128_10_power_7;
valid = uint128_le absolute_change maxcommchangerate_l;
match valid with
| True =>
| False =>
e = ExceedMaxChangeRate;
ThrowError e
end
end
procedure IncreaseTotalStakeAmt(amt: Uint128)
current_amt <- totalstakeamount;
new_amt = builtin add current_amt amt;
totalstakeamount := new_amt
end
procedure DecreaseTotalStakeAmt(amt: Uint128)
current_amt <- totalstakeamount;
valid = uint128_le amt current_amt;
match valid with
| True =>
| False =>
e = InvalidTotalAmt;
ThrowError e
end
end
procedure IncreaseTotalStakeAmtOnStatus(amt: Uint128, status: Bool)
match status with
| True =>
IncreaseTotalStakeAmt amt
| False =>
end
end
procedure DecreaseTotalStakeAmtOnStatus(amt: Uint128, status: Bool)
match status with
| True =>
| False =>
DecreaseTotalStakeAmt amt
end
end
procedure CallerIsVerifier(initiator: ByStr20)
verifier_tmp <- verifier;
match verifier_tmp with
| Some v =>
is_verifier = builtin eq initiator v;
match is_verifier with
| True =>
| False =>
e = VerifierValidationFailed;
ThrowError e
end
| None =>
e = VerifierValidationFailed;
ThrowError e
end
end
procedure IsAdmin(initiator: ByStr20)
contractadmin_tmp <- contractadmin;
is_admin = builtin eq initiator contractadmin_tmp;
match is_admin with
| True  =>
| False =>
e = AdminValidationFailed;
ThrowError e
end
end
procedure IsProxy()
is_proxy = builtin eq _sender proxy_address;
match is_proxy with
| True  =>
| False =>
e = ProxyValidationFailed;
ThrowError e
end
end
procedure IsPaused()
paused_tmp <- paused;
match paused_tmp with
| False =>
| True  =>
e = ContractFreezedFailure;
ThrowError e
end
end
procedure TransferFunds(tag: String, amt: Uint128, recipient: ByStr20)
msg = {_tag: tag; _recipient: recipient; _amount: amt};
msgs = one_msg msg;
send msgs
end
procedure CalculateTotalWithdrawal(withdraw: Pair BNum Uint128)
current_deleg_o <- current_deleg;
match current_deleg_o with
| Some current_deleg =>
match withdraw with
| Pair withdraw_number amt =>
current_bnum <- & BLOCKNUMBER;
current_bnum_req <- bnum_req;
bnum = builtin badd withdraw_number current_bnum_req;
can_withdraw = builtin blt bnum current_bnum;
match can_withdraw with
| True =>
delete withdrawal_pending[current_deleg][withdraw_number];
current_amt <- avaiable_withdrawal;
current_amt = builtin add current_amt amt;
avaiable_withdrawal := current_amt
| False =>
end
end
| None =>
end
end
procedure UpdateStakeReward(entry: SsnRewardShare)
lastreward_blk <- lastrewardcycle;
match entry with
| SsnRewardShare ssnaddr cycle_reward =>
curval <- ssnlist[ssnaddr];
match curval with
| None =>
e = SSNNotExist;
ThrowError e
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
match active_status with
| False =>
e = { _eventname: "SSN inactive"; ssn_addr: ssnaddr};
event e
| True  =>
total_stake_amt <- totalstakeamount;
new_rewards_tmp = builtin mul stake_amt cycle_reward;
new_rewards = builtin div new_rewards_tmp total_stake_amt;
reward_comm_tmp = builtin mul new_rewards comm;
reward_comm_tmp = builtin div reward_comm_tmp uint128_100;
reward_comm_tmp = builtin div reward_comm_tmp uint128_10_power_7;
total_reward_comm = builtin add reward_comm_tmp comm_rewards;
delegate_reward = builtin sub new_rewards reward_comm_tmp;
p = SSNCycleInfo stake_amt delegate_reward;
stake_ssn_per_cycle[ssnaddr][lastreward_blk] := p;
new_stake_amt = builtin add stake_amt buffdeposit;
deleg_reward = builtin add delegate_reward rewards;
ssn = Ssn active_status new_stake_amt deleg_reward name urlraw urlapi uint128_zero comm total_reward_comm rec_addr;
ssnlist[ssnaddr] := ssn;
IncreaseTotalStakeAmtOnStatus buffdeposit active_status;
e = { _eventname: "SSN assign reward"; ssn_addr: ssnaddr; total_reward: total_reward_comm };
event e
end
end
end
end
procedure SendDelegRewards(addr: ByStr20, amt: Uint128)
to_send = builtin eq amt uint128_zero;
match to_send with
| True =>
| False =>
TransferFunds addfunds_tag amt addr;
e = { _eventname: "Send deleg rewards"; addr: addr; amt:  amt};
event e
end
end
procedure DelegExists(ssnaddr: ByStr20, deleg: ByStr20)
if_exists <- exists deposit_amt_deleg[deleg][ssnaddr];
match if_exists with
| True  =>
| False =>
e = DelegDoesNotExistAtSSN;
ThrowError e
end
end
procedure FillLastRewardCycle(ssnaddr: ByStr20, deleg : ByStr20)
lwcd_o <- last_withdraw_cycle_deleg[deleg][ssnaddr];
match lwcd_o with
| Some lwcd =>
| None =>
lrc <- lastrewardcycle;
last_withdraw_cycle_deleg[deleg][ssnaddr] := lrc
end
end
procedure FillInDepositDelegAmt(ssnaddr: ByStr20, deleg: ByStr20, amount: Uint128)
deposit_amt <- deposit_amt_deleg[deleg][ssnaddr];
match deposit_amt with
| Some amt =>
new_amt = builtin add amt amount;
deposit_amt_deleg[deleg][ssnaddr] := new_amt;
ssn_deleg_amt[ssnaddr][deleg] := new_amt
| None =>
deposit_amt_deleg[deleg][ssnaddr] := amount;
ssn_deleg_amt[ssnaddr][deleg] := amount
end
end
procedure HasRewardToWithdraw(ssnaddr: ByStr20, deleg: ByStr20)
lrcd_tmp <- last_withdraw_cycle_deleg[deleg][ssnaddr];
lrcd = option_uint128_value lrcd_tmp;
lrc <- lastrewardcycle;
has_reward = builtin lt lrcd lrc;
match has_reward with
| True =>
e = DelegHasUnwithdrawRewards;
ThrowError e
| False =>
end
end
procedure HasBufferedDeposit(ssnaddr: ByStr20, deleg: ByStr20)
ldcd_o <- last_buf_deposit_cycle_deleg[deleg][ssnaddr];
ldcd = option_uint128_value ldcd_o;
lrc <- lastrewardcycle;
has_buffered = uint128_le lrc ldcd;
match has_buffered with
| True =>
e = DelegHasBufferedDeposit;
ThrowError e
| False =>
end
end
procedure IsDelegstakeSufficient(amount: Uint128)
mindelegstake_l <- mindelegstake;
suffi =  uint128_le mindelegstake_l amount;
match suffi with
| True =>
| False =>
e = DelegStakeNotEnough;
ThrowError e
end
end
procedure AdjustDeleg(ssnaddr: ByStr20, deleg: ByStr20, total_amount: Uint128, withdraw_amount: Uint128)
suffient = uint128_le withdraw_amount total_amount;
match suffient with
| True =>
need_truncate =  builtin eq withdraw_amount total_amount;
match need_truncate with
| True =>
TruncateDeleg deleg ssnaddr
| False =>
lrc <- lastrewardcycle;
rest_deleg = builtin sub total_amount withdraw_amount;
TruncateDeleg deleg ssnaddr;
deposit_amt_deleg[deleg][ssnaddr] := rest_deleg;
ssn_deleg_amt[ssnaddr][deleg] := rest_deleg;
direct_deposit_deleg[deleg][ssnaddr][lrc] := rest_deleg;
<<<<<<< HEAD
last_withdraw_cycle_deleg[deleg][ssnaddr] := lrc;
last_buf_deposit_cycle_deleg[deleg][ssnaddr] := lrc
=======
last_withdraw_cycle_deleg[deleg][ssnaddr] := lrc
>>>>>>> 5ea1b34... fix: clarify reward cycle
end
| False =>
e = DelegHasNoSufficientAmt;
ThrowError e
end
end
procedure WithdrawalStakeAmt(initiator: ByStr20, ssn: ByStr20, withdraw_amount: Uint128)
ssn_o <- ssnlist[ssn];
deleg <- deposit_amt_deleg[initiator][ssn];
lrc <- lastrewardcycle;
match ssn_o with
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
match deleg with
| Some amt =>
HasRewardToWithdraw ssn initiator;
HasBufferedDeposit ssn initiator;
AdjustDeleg ssn initiator amt withdraw_amount;
DecreaseTotalStakeAmt withdraw_amount;
new_amt = builtin sub stake_amt withdraw_amount;
minstake_tmp <- minstake;
status = uint128_le minstake_tmp new_amt;
ssn_option_tmp = Ssn status new_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
ssnlist[ssn] := ssn_option_tmp;
DecreaseTotalStakeAmtOnStatus new_amt status;
withdrawal_bnum <- & BLOCKNUMBER;
withdraw_amt_o <- withdrawal_pending[initiator][withdrawal_bnum];
withdraw_amt_pending = match withdraw_amt_o with
| Some v => builtin add v withdraw_amount
| None => withdraw_amount
end;
withdrawal_pending[initiator][withdrawal_bnum] := withdraw_amt_pending;
e = { _eventname: "Deleg withdraw deposit"; ssn_addr: ssn; deleg_address: initiator; amt: amt };
event e
| None =>
e = DelegDoesNotExistAtSSN;
ThrowError e
end
| None =>
e = SSNNotExist;
ThrowError e
end
end
procedure CalcStakeDelegPerCycle(tmp_arg: TmpArg)
match tmp_arg with
| TmpArg deleg ssn_operator reward_cycle =>
last_reward_cycle = builtin sub reward_cycle uint128_one;
last2_reward_cycle = sub_one_to_zero last_reward_cycle;
cur_opt <- direct_deposit_deleg[deleg][ssn_operator][last_reward_cycle];
buf_opt <- buff_deposit_deleg[deleg][ssn_operator][last2_reward_cycle];
comb_opt = option_add cur_opt buf_opt;
result_map_opt <- stake_deleg_per_cycle[last_reward_cycle];
stake_opt = option_add comb_opt result_map_opt;
match stake_opt with
| Some stake =>
stake_deleg_per_cycle[reward_cycle] := stake
| None =>
stake_deleg_per_cycle[reward_cycle] := uint128_zero
end
end
end
procedure MintCall(recipient: ByStr20, amount: Uint128)
addr <- gziladdr;
msg_to_gzil = {_tag: "Mint"; _recipient: addr; _amount: uint128_zero;
recipient: recipient; amount: amount};
msgs = one_msg msg_to_gzil;
send msgs
end
procedure IncreaseReward(ssn: ByStr20, deleg: ByStr20, reward: Uint128)
exist_reward_o <- rewards_amt_deleg[ssn][deleg];
exist_reward = option_uint128_value exist_reward_o;
new_reward = builtin add exist_reward reward;
rewards_amt_deleg[ssn][deleg] := new_reward
end
procedure CalcRewardsDelegPerCycle(tmp_arg: TmpArg)
match tmp_arg with
| TmpArg deleg ssn_operator reward_cycle =>
staking_per_cycle_for_deleg_opt <- stake_deleg_per_cycle[reward_cycle];
staking_and_rewards_per_cycle_for_ssn_opt <- stake_ssn_per_cycle[ssn_operator][reward_cycle];
match staking_per_cycle_for_deleg_opt with
| Some staking_of_deleg =>
match staking_and_rewards_per_cycle_for_ssn_opt with
| Some (SSNCycleInfo total_staking total_rewards) =>
reward_tmp = builtin mul total_rewards staking_of_deleg;
reward = builtin div reward_tmp total_staking;
IncreaseReward ssn_operator deleg reward
| None =>
end
| None =>
end
end
end
procedure WithdrawalStakeRewards(deleg: ByStr20, ssn_operator: ByStr20)
last_withdraw_cycle_deleg_m <- last_withdraw_cycle_deleg[deleg][ssn_operator];
last_withdraw_cycle = option_uint128_value last_withdraw_cycle_deleg_m;
lrc <- lastrewardcycle;
rcl <- reward_cycle_list;
list_reverse_uint128 = @list_reverse Uint128;
rcl_reverse = list_reverse_uint128 rcl;
list_need_compute_rewards = list_filter_between last_withdraw_cycle lrc rcl;
mapper = @list_map Uint128 TmpArg;
f = fun (cycle: Uint128) => TmpArg deleg ssn_operator cycle;
combined_args_list = mapper f list_need_compute_rewards;
emp_map = Emp Uint128 Uint128;
stake_deleg_per_cycle := emp_map;
rcl_reverse_t = mapper f rcl_reverse;
forall rcl_reverse_t CalcStakeDelegPerCycle;
rewards_amt_deleg[ssn_operator][deleg] := uint128_zero;
forall combined_args_list CalcRewardsDelegPerCycle;
reward <- rewards_amt_deleg[ssn_operator][deleg];
reward = option_uint128_value reward;
SendDelegRewards deleg reward;
MintCall deleg reward;
sdpc <- stake_deleg_per_cycle;
sdpc_list = builtin to_list sdpc;
e = { _eventname: "WithdrawalStakeRewards"; reward_list_need: list_need_compute_rewards; combined_args_list: combined_args_list; stake_deleg_per_cycle: sdpc_list };
event e;
last_withdraw_cycle_deleg[deleg][ssn_operator] := lrc
end
procedure Delegate(ssnaddr: ByStr20, initiator: ByStr20, amount: Uint128)
curval <- ssnlist[ssnaddr];
match curval with
| None =>
e = SSNNotExist;
ThrowError e
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
IsDelegstakeSufficient amount;
minstake_tmp <- minstake;
lrc <- lastrewardcycle;
FillInDepositDelegAmt ssnaddr initiator amount;
FillLastRewardCycle ssnaddr initiator;
match active_status with
| True  =>
last_buf_deposit_cycle_deleg[initiator][ssnaddr] := lrc;
new_buff_amt  = builtin add amount buffdeposit;
new_stake_amt = builtin add new_buff_amt stake_amt;
ssn = Ssn bool_active stake_amt rewards name urlraw urlapi new_buff_amt comm comm_rewards rec_addr;
ssnlist[ssnaddr] := ssn;
stake_amt_for_deleg_option  <- buff_deposit_deleg[initiator][ssnaddr][lrc];
match stake_amt_for_deleg_option  with
| Some stake_amt_for_deleg =>
new_stake_amt_for_deleg = builtin add stake_amt_for_deleg amount;
buff_deposit_deleg[initiator][ssnaddr][lrc] := new_stake_amt_for_deleg
| None =>
buff_deposit_deleg[initiator][ssnaddr][lrc] := amount
end
| False =>
new_stake_amt  = builtin add amount stake_amt;
status = uint128_le minstake_tmp new_stake_amt;
ssn = Ssn status new_stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
ssnlist[ssnaddr] := ssn;
IncreaseTotalStakeAmtOnStatus new_stake_amt status;
stake_amt_for_deleg_option  <- direct_deposit_deleg[initiator][ssnaddr][lrc];
match stake_amt_for_deleg_option  with
| Some stake_amt_for_deleg =>
new_stake_amt_for_deleg = builtin add stake_amt_for_deleg amount;
direct_deposit_deleg[initiator][ssnaddr][lrc] := new_stake_amt_for_deleg
| None =>
direct_deposit_deleg[initiator][ssnaddr][lrc] := amount
end
end
end
end
transition Pause(initiator: ByStr20)
IsProxy;
IsAdmin initiator;
paused := bool_active
end
transition UnPause(initiator: ByStr20)
IsProxy;
IsAdmin initiator;
paused := bool_inactive
end
transition UpdateAdmin(admin: ByStr20, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
contractadmin := admin
end
transition UpdateVerifier(verif: ByStr20, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
newverifier = Some {ByStr20} verif;
verifier := newverifier
end
transition UpdateVerifierRewardAddr(addr: ByStr20, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
newAddr = Some {ByStr20} addr;
verifier_receiving_addr := newAddr
end
transition UpdateStakingParameters(min_stake: Uint128, min_deleg_stake: Uint128, max_comm_change_rate: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
minstake := min_stake;
mindelegstake := min_deleg_stake;
maxcommchangerate := max_comm_change_rate
end
transition ChangeBNumReq(input_bnum_req: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
bnum_req := input_bnum_req;
e = { _eventname: "ChangeBNumReqSuccess"; input_bnum_req: input_bnum_req};
event e
end
transition UpdateContractAddr(proxy_addr: ByStr20, gzil_addr: ByStr20, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
gziladdr := gzil_addr;
proxyaddr := proxy_addr
end
transition AddSSN(ssnaddr: ByStr20, name: String, urlraw: String, urlapi: String, comm: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
already_exists <- exists ssnlist[ssnaddr];
match already_exists with
| True  =>
e = SSNAlreadyExist;
ThrowError e
| False =>
status = bool_inactive;
stake_amt = Uint128 0;
rewards = Uint128 0;
buff_deposit = Uint128 0;
comm_rewards = Uint128 0;
s = Ssn status stake_amt rewards name urlraw urlapi buff_deposit comm comm_rewards ssnaddr;
ssnlist[ssnaddr] := s;
lrc <- lastrewardcycle;
comm_for_ssn[ssnaddr][lrc] := comm;
e = { _eventname: "SSN added"; ssn_addr: ssnaddr };
event e
end
end
transition UpdateSSN(ssnaddr: ByStr20, new_name: String, new_urlraw: String, new_urlapi: String, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
ssn_o <- ssnlist[ssnaddr];
match ssn_o with
| Some (Ssn active_status staking_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
ssn = Ssn active_status staking_amt deleg_reward new_name new_urlraw new_urlapi buffdeposit comm comm_rewards rec_addr;
ssnlist[ssnaddr] := ssn
| None =>
e = SSNAlreadyExist;
ThrowError e
end
end
transition RemoveSSN(ssnaddr: ByStr20, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
already_exists <- exists ssnlist[ssnaddr];
match already_exists with
| False =>
e = SSNNotExist;
ThrowError e
| True =>
delete ssnlist[ssnaddr];
delete comm_for_ssn[ssnaddr];
e = { _eventname: "SSN removed"; ssn_addr: ssnaddr };
event e
end
end
transition UpdateComm(new_rate: Uint128, initiator: ByStr20)
IsPaused;
IsProxy;
curval <- ssnlist[initiator];
match curval with
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
lrc <- lastrewardcycle;
old_comm_option <- comm_for_ssn[initiator][lrc];
match old_comm_option with
| Some old_comm =>
e = ChangeCommError;
ThrowError e
| None =>
ValidateRate new_rate;
ValidateChangeRate comm new_rate;
comm_for_ssn[initiator][lrc] := new_rate;
ssn =  Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit new_rate comm_rewards rec_addr;
ssnlist[initiator] := ssn
end
| None =>
e = SSNNotExist;
ThrowError e
end
end
transition WithdrawComm(ssnaddr: ByStr20, initiator: ByStr20)
IsPaused;
IsProxy;
curval <- ssnlist[ssnaddr];
match curval with
| None =>
e = SSNNotExist;
ThrowError e
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
is_valid_addr = builtin eq initiator rec_addr;
match is_valid_addr with
| True =>
has_comm = uint128_gt comm_rewards uint128_zero;
match has_comm with
| True =>
e = { _eventname: "SSN withdraw reward"; ssn_addr: initiator; withdraw_comm: comm_rewards };
event e;
ssn = Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm uint128_zero rec_addr;
ssnlist[initiator] := ssn;
TransferFunds addfunds_tag comm_rewards rec_addr
| False =>
e = SSNNoComm;
ThrowError e
end
| False =>
e = InvalidRecvAddr;
ThrowError e
end
end
end
transition UpdateReceivedAddr(new_addr: ByStr20, initiator: ByStr20)
IsPaused;
IsProxy;
curval <- ssnlist[initiator];
match curval with
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
ssn =  Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards new_addr;
ssnlist[initiator] := ssn
| None =>
e = SSNNotExist;
ThrowError e
end
end
transition DelegateStake(ssnaddr: ByStr20, initiator: ByStr20)
IsPaused;
IsProxy;
accept;
amount = _amount;
Delegate ssnaddr initiator amount
end
transition WithdrawStakeRewards(ssn_operator: ByStr20, initiator: ByStr20)
IsPaused;
IsProxy;
DelegExists ssn_operator initiator;
amt_opt <- deposit_amt_deleg[initiator][ssn_operator];
amt = option_uint128_value amt_opt;
WithdrawalStakeRewards initiator ssn_operator
end
transition WithdrawStakeAmt(ssn: ByStr20, amt: Uint128, initiator: ByStr20)
IsPaused;
IsProxy;
WithdrawalStakeAmt initiator ssn amt
end
transition CompleteWithdrawal(initiator: ByStr20)
IsPaused;
IsProxy;
withdraw_map_o <- withdrawal_pending[initiator];
match withdraw_map_o with
| Some withdraw_map =>
withdraw_list = builtin to_list withdraw_map;
withdrawal_zero = uint128_zero;
avaiable_withdrawal := withdrawal_zero;
c = Some {ByStr20} initiator;
current_deleg := c;
forall withdraw_list CalculateTotalWithdrawal;
withdraw_amt <- avaiable_withdrawal;
e = { _eventname: "CompleteWithdrawal"; ssn_addr: initiator; initiator: withdraw_amt };
event e;
TransferFunds addfunds_tag withdraw_amt initiator
| None =>
end
end
transition ReDelegateStake(ssnaddr: ByStr20, to_ssn: ByStr20, amount: Uint128, initiator: ByStr20)
IsPaused;
IsProxy;
WithdrawalStakeAmt initiator ssnaddr amount;
Delegate to_ssn initiator amount;
e = { _eventname: "ReDelegateStakeSuccess"; ssnaddr: ssnaddr; to_ssn: to_ssn; delegator: initiator; delegate_amount: amount };
event e
end
transition AssignStakeReward(ssnreward_list: List SsnRewardShare, verifier_reward: Uint128, initiator: ByStr20)
IsPaused;
IsProxy;
CallerIsVerifier initiator;
lrc <- lastrewardcycle;
newLastRewardCycleNum = builtin add uint128_one lrc;
lastrewardcycle := newLastRewardCycleNum;
rcl <- reward_cycle_list;
rcl_new = Cons {Uint128} newLastRewardCycleNum rcl;
reward_cycle_list := rcl_new;
forall ssnreward_list UpdateStakeReward;
verifier_o <- verifier_receiving_addr;
match verifier_o with
| Some v =>
is_zero = builtin eq verifier_reward uint128_zero;
match is_zero with
| True =>
| False =>
TransferFunds addfunds_tag verifier_reward v
end
| None =>
e = VerifierRecvAddrNotSet;
ThrowError e
end
end
transition AddFunds(initiator: ByStr20)
IsProxy;
accept;
e = { _eventname : "Funds deposit "; funder : initiator };
event e
end
transition AddSSNAfterUpgrade(ssnaddr: ByStr20, stake_amt: Uint128, rewards: Uint128, name: String, urlraw: String, urlapi: String, buff_deposit: Uint128,  comm: Uint128, comm_rewards: Uint128, rec_addr: ByStr20, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
already_exists <- exists ssnlist[ssnaddr];
match already_exists with
| True  =>
e = { _eventname: "SSN already exists"; ssn_addr: ssnaddr };
event e
| False =>
minstake_tmp <- minstake;
status = uint128_le minstake_tmp stake_amt;
s = Ssn status stake_amt rewards name urlraw urlapi buff_deposit comm comm_rewards rec_addr;
ssnlist[ssnaddr] := s;
lrc <- lastrewardcycle;
comm_for_ssn[ssnaddr][lrc] := comm;
e = { _eventname: "SSN added"; ssn_addr: ssnaddr };
event e
end
end
transition UpdateDeleg(ssnaddr: ByStr20, deleg: ByStr20, stake_amt: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
ssn_o <- ssnlist[ssnaddr];
minstake_tmp <- minstake;
match ssn_o with
| Some (Ssn active_status staking_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
is_delete = builtin eq stake_amt uint128_zero;
match is_delete with
| True =>
alr_deleg_amt_o <- deposit_amt_deleg[deleg][ssnaddr];
match alr_deleg_amt_o with
| Some alr_deleg =>
TruncateDeleg deleg ssnaddr;
new_stake_amt = builtin sub staking_amt alr_deleg;
status = uint128_le minstake_tmp new_stake_amt;
ssn = Ssn status new_stake_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
ssnlist[ssnaddr] := ssn;
e = { _eventname: "Deleg deleted"; ssn_addr: ssnaddr; deleg_address: deleg };
event e
| None =>
end
| False =>
FillInDepositDelegAmt ssnaddr deleg stake_amt;
new_stake_amt = builtin add stake_amt staking_amt;
status = uint128_le minstake_tmp new_stake_amt;
ssn = Ssn status new_stake_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
ssnlist[ssnaddr] := ssn;
e = { _eventname: "Deleg added"; ssn_addr: ssnaddr; deleg_address: deleg };
event e
end
| None =>
e = SSNNotExist;
ThrowError e
end
end
transition PopulateStakeSSNPerCycle(ssn_addr: ByStr20, cycle: Uint128, info: SSNCycleInfo, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
stake_ssn_per_cycle[ssn_addr][cycle] := info
end
transition PopulateLastWithdrawCycleForDeleg(deleg_addr: ByStr20, ssn_addr: ByStr20, cycle: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
last_withdraw_cycle_deleg[deleg_addr][ssn_addr] := cycle
end
transition PopulateBuffDeposit(deleg_addr: ByStr20, ssn_addr: ByStr20, cycle: Uint128, amt: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
buff_deposit_deleg[deleg_addr][ssn_addr][cycle] := amt
end
transition PopulateDirectDeposit(deleg_addr: ByStr20, ssn_addr: ByStr20, cycle: Uint128, amt: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
direct_deposit_deleg[deleg_addr][ssn_addr][cycle] := amt
end
transition PopulateCommForSSN(ssn_addr: ByStr20, cycle: Uint128, comm: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
comm_for_ssn[ssn_addr][cycle] := comm
end
transition PopulateTotalStakeAmt(amt: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
totalstakeamount := amt
end
transition UpdateRewardCycleList(list: List Uint128, last_cycle: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
reward_cycle_list := list;
lastrewardcycle := last_cycle
end
transition DrainContractBalance(amt: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
bal <- _balance;
less_than = builtin lt bal amt;
match less_than with
| True => throw
| False =>
TransferFunds addfunds_tag amt initiator
end
end

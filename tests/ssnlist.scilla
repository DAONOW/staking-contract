scilla_version 0
import ListUtils IntUtils BoolUtils
library SSNList
type Ssn =
| Ssn of Bool Uint128 Uint128 String String String Uint128 Uint128 Uint128 ByStr20
type SsnRewardShare =
| SsnRewardShare of ByStr20 Uint128
type SSNCycleInfo =
| SSNCycleInfo of Uint128 Uint128
type TmpArg =
| TmpArg of ByStr20 ByStr20 Uint32
let one_msg =
fun (m : Message) =>
let e = Nil {Message} in
Cons {Message} m e
let uint128_one =  Uint128 1
let uint128_zero = Uint128 0
let uint128_10_power_7 = Uint128 10000000
let uint128_100 = Uint128 100
let uint32_one = Uint32 1
let uint32_zero = Uint32 0
let option_value =
tfun 'A =>
fun (default: 'A) =>
fun (opt_val: Option 'A) =>
match opt_val with
| Some v => v
| None => default
end
let option_map_uint128_uint128_value =
let f = @option_value (Map Uint128 Uint128) in
let emt = Emp Uint128 Uint128 in
f emt
let option_uint128_value =
let f = @option_value Uint128 in
f uint128_zero
let option_uint32_value =
let f = @option_value Uint32 in
f uint32_zero
let sub_one_to_zero =
fun (x: Uint32) =>
let less_than_one = builtin lt x uint32_one in
match less_than_one with
| True =>
uint32_zero
| False =>
let res = builtin sub x uint32_one in
res
end
let option_add =
fun (x_opt: Option Uint128) =>
fun (y_opt: Option Uint128) =>
match x_opt with
| Some x =>
let y = option_uint128_value y_opt in
let res = builtin add x y in
Some {Uint128} res
| None => y_opt
end
let change_rate =
fun (old: Uint128) =>
fun (new: Uint128) =>
let a = builtin lt old new in
match a with
| True =>
builtin sub new old
| False =>
builtin sub old new
end
let iota : Uint32 -> Uint32 -> List Uint32 =
fun (m : Uint32) => fun (n : Uint32) =>
let m_lt_n = builtin lt m n in
match m_lt_n with
| True =>
let delta = builtin sub n m in
let delta_nat = builtin to_nat delta in
let fold = @nat_fold (List Uint32) in
let nil = Nil {Uint32} in
let acc_init = Pair {(List Uint32) Uint32} nil n in
let one = Uint32 1 in
let step = fun (xs_n : Pair (List Uint32) Uint32) => fun (ignore : Nat) =>
match xs_n with
| Pair xs n =>
let new_n = builtin sub n one in
let new_xs = Cons {Uint32} new_n xs in
Pair {(List Uint32) Uint32} new_xs new_n
end in
let fold = @nat_fold (Pair (List Uint32) Uint32) in
let xs_m = fold step acc_init delta_nat in
match xs_m with
| Pair xs m => xs
end
| False => Nil {Uint32}
end
let bool_active = True
let bool_inactive = False
let addfunds_tag = "AddFunds"
type Error =
| ContractFrozenFailure
| VerifierValidationFailed
| AdminValidationFailed
| ProxyValidationFailed
| DelegDoesNotExistAtSSN
| DelegHasBufferedDeposit
| ChangeCommError
| SSNNotExist
| SSNAlreadyExist
| DelegHasUnwithdrawRewards
| DelegHasNoSufficientAmt
| SSNNoComm
| DelegStakeNotEnough
| ExceedMaxChangeRate
| ExceedMaxCommRate
| InvalidTotalAmt
| InvalidRecvAddr
| VerifierNotSet
| VerifierRecvAddrNotSet
| ReDelegInvalidSSNAddr
let make_error =
fun (result: Error) =>
let result_code =
match result with
| ContractFrozenFailure => Int32 -1
| VerifierValidationFailed => Int32 -2
| AdminValidationFailed => Int32 -3
| ProxyValidationFailed => Int32 -4
| DelegDoesNotExistAtSSN => Int32 -5
| DelegHasBufferedDeposit => Int32 -6
| ChangeCommError => Int32 -7
| SSNNotExist => Int32 -8
| SSNAlreadyExist => Int32 -9
| DelegHasUnwithdrawRewards => Int32 -10
| DelegHasNoSufficientAmt => Int32 -11
| SSNNoComm => Int32 -12
| DelegStakeNotEnough => Int32 -13
| ExceedMaxChangeRate => Int32 -14
| ExceedMaxCommRate => Int32 -15
| InvalidTotalAmt => Int32 -16
| InvalidRecvAddr => Int32 -17
| VerifierNotSet => Int32 -18
| VerifierRecvAddrNotSet => Int32 -19
| ReDelegInvalidSSNAddr => Int32 -20
end
in
{ _exception: "Error"; code: result_code }
contract SSNList(
init_admin: ByStr20,
init_proxy_address: ByStr20,
init_gzil_address: ByStr20
)
field ssnlist: Map ByStr20 Ssn = Emp ByStr20 Ssn
field comm_for_ssn: Map ByStr20 (Map Uint32 Uint128) = Emp ByStr20 (Map Uint32 Uint128)
field deposit_amt_deleg: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field ssn_deleg_amt: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field buff_deposit_deleg: Map ByStr20 (Map ByStr20 (Map Uint32 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint32 Uint128))
field direct_deposit_deleg: Map ByStr20 (Map ByStr20 (Map Uint32 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint32 Uint128))
field last_withdraw_cycle_deleg: Map ByStr20 (Map ByStr20 Uint32) = Emp ByStr20 (Map ByStr20 Uint32)
field last_buf_deposit_cycle_deleg: Map ByStr20 (Map ByStr20 Uint32) = Emp ByStr20 (Map ByStr20 Uint32)
field stake_ssn_per_cycle: Map ByStr20 (Map Uint32 SSNCycleInfo) = Emp ByStr20 (Map Uint32 SSNCycleInfo)
field deleg_stake_per_cycle: Map ByStr20 (Map ByStr20 (Map Uint32 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint32 Uint128))
field withdrawal_pending: Map ByStr20 (Map BNum Uint128) = Emp ByStr20 (Map BNum Uint128)
field bnum_req: Uint128 = Uint128 24000
field rewards_amt_deleg: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field verifier_reward: Uint128 = uint128_zero
field avaiable_withdrawal: Uint128 = uint128_zero
field current_deleg: Option ByStr20 = None {ByStr20}
field verifier: Option ByStr20 = None {ByStr20}
field verifier_receiving_addr: Option ByStr20 = None {ByStr20}
field minstake: Uint128 = Uint128 10000000000000000000
field mindelegstake: Uint128 = Uint128 1000000000000000
field contractadmin: ByStr20  = init_admin
field proxyaddr: ByStr20 = init_proxy_address
field gziladdr: ByStr20 = init_gzil_address
field lastrewardcycle: Uint32 = uint32_one
field paused: Bool = True
field maxcommchangerate: Uint128 = uint128_one
field maxcommrate: Uint128 = Uint128 1000000000
field totalstakeamount: Uint128 = uint128_zero
procedure TruncateDeleg(deleg: ByStr20, ssnaddr: ByStr20)
delete deposit_amt_deleg[deleg][ssnaddr];
delete ssn_deleg_amt[ssnaddr][deleg];
delete buff_deposit_deleg[deleg][ssnaddr];
delete direct_deposit_deleg[deleg][ssnaddr];
delete last_withdraw_cycle_deleg[deleg][ssnaddr];
delete last_buf_deposit_cycle_deleg[deleg][ssnaddr]
end
procedure ThrowError(err: Error)
e = make_error err;
throw e
end
procedure ValidateRate(rate: Uint128)
max_rate <- maxcommrate;
validate = uint128_le rate max_rate;
match validate with
| True =>
| False =>
e = ExceedMaxCommRate;
ThrowError e
end
end
procedure ValidateChangeRate(old: Uint128, new: Uint128)
maxcommchangerate_l <- maxcommchangerate;
absolute_change = change_rate old new;
absolute_change = builtin div absolute_change uint128_10_power_7;
valid = uint128_le absolute_change maxcommchangerate_l;
match valid with
| True =>
| False =>
e = ExceedMaxChangeRate;
ThrowError e
end
end
procedure IncreaseTotalStakeAmt(amt: Uint128)
current_amt <- totalstakeamount;
new_amt = builtin add current_amt amt;
totalstakeamount := new_amt
end
procedure DecreaseTotalStakeAmt(amt: Uint128)
current_amt <- totalstakeamount;
valid = uint128_le amt current_amt;
match valid with
| True =>
new_amt = builtin sub current_amt amt;
totalstakeamount := new_amt
| False =>
e = InvalidTotalAmt;
ThrowError e
end
end
procedure IncreaseTotalStakeAmtOnStatus(amt: Uint128, status: Bool)
match status with
| True =>
IncreaseTotalStakeAmt amt
| False =>
end
end
procedure DecreaseTotalStakeAmtOnStatus(amt: Uint128, status: Bool)
match status with
| True =>
| False =>
DecreaseTotalStakeAmt amt
end
end
procedure CallerIsVerifier(initiator: ByStr20)
verifier_tmp <- verifier;
match verifier_tmp with
| Some v =>
is_verifier = builtin eq initiator v;
match is_verifier with
| True =>
| False =>
e = VerifierValidationFailed;
ThrowError e
end
| None =>
e = VerifierNotSet;
ThrowError e
end
end
procedure IsAdmin(initiator: ByStr20)
contractadmin_tmp <- contractadmin;
is_admin = builtin eq initiator contractadmin_tmp;
match is_admin with
| True  =>
| False =>
e = AdminValidationFailed;
ThrowError e
end
end
procedure IsProxy()
proxy_tmp <- proxyaddr;
is_proxy = builtin eq _sender proxy_tmp;
match is_proxy with
| True  =>
| False =>
e = ProxyValidationFailed;
ThrowError e
end
end
procedure IsPaused()
paused_tmp <- paused;
match paused_tmp with
| False =>
| True  =>
e = ContractFrozenFailure;
ThrowError e
end
end
procedure TransferFunds(tag: String, amt: Uint128, recipient: ByStr20)
msg = {_tag: tag; _recipient: recipient; _amount: amt};
msgs = one_msg msg;
send msgs
end
procedure CalculateTotalWithdrawal(withdraw: Pair BNum Uint128)
current_deleg_o <- current_deleg;
match current_deleg_o with
| Some current_deleg =>
match withdraw with
| Pair withdraw_number amt =>
current_bnum <- & BLOCKNUMBER;
current_bnum_req <- bnum_req;
bnum = builtin badd withdraw_number current_bnum_req;
can_withdraw = builtin blt bnum current_bnum;
match can_withdraw with
| True =>
delete withdrawal_pending[current_deleg][withdraw_number];
current_amt <- avaiable_withdrawal;
current_amt = builtin add current_amt amt;
avaiable_withdrawal := current_amt
| False =>
end
end
| None =>
end
end
procedure UpdateStakeReward(entry: SsnRewardShare)
lastreward_blk <- lastrewardcycle;
match entry with
| SsnRewardShare ssnaddr cycle_reward =>
curval <- ssnlist[ssnaddr];
match curval with
| None =>
e = SSNNotExist;
ThrowError e
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
match active_status with
| False =>
e = { _eventname: "SSN inactive"; ssn_addr: ssnaddr};
event e
| True  =>
total_stake_amt <- totalstakeamount;
new_rewards_tmp = builtin mul stake_amt cycle_reward;
new_rewards = builtin div new_rewards_tmp total_stake_amt;
current_verifier_reward <- verifier_reward;
new_current_verifier_reward = builtin sub current_verifier_reward new_rewards;
verifier_reward := new_current_verifier_reward;
reward_comm_tmp = builtin mul new_rewards comm;
reward_comm_tmp = builtin div reward_comm_tmp uint128_100;
reward_comm_tmp = builtin div reward_comm_tmp uint128_10_power_7;
total_reward_comm = builtin add reward_comm_tmp comm_rewards;
delegate_reward = builtin sub new_rewards reward_comm_tmp;
p = SSNCycleInfo stake_amt delegate_reward;
stake_ssn_per_cycle[ssnaddr][lastreward_blk] := p;
new_stake_amt = builtin add stake_amt buffdeposit;
deleg_reward = builtin add delegate_reward rewards;
ssn = Ssn active_status new_stake_amt deleg_reward name urlraw urlapi uint128_zero comm total_reward_comm rec_addr;
ssnlist[ssnaddr] := ssn;
IncreaseTotalStakeAmtOnStatus buffdeposit active_status;
e = { _eventname: "SSN assign reward"; ssn_addr: ssnaddr; total_reward: total_reward_comm };
event e
end
end
end
end
procedure SendDelegRewards(addr: ByStr20, amt: Uint128)
to_send = builtin eq amt uint128_zero;
match to_send with
| True =>
| False =>
TransferFunds addfunds_tag amt addr;
e = { _eventname: "Send deleg rewards"; addr: addr; amt:  amt};
event e
end
end
procedure DelegExists(ssnaddr: ByStr20, deleg: ByStr20)
if_exists <- exists deposit_amt_deleg[deleg][ssnaddr];
match if_exists with
| True  =>
| False =>
e = DelegDoesNotExistAtSSN;
ThrowError e
end
end
procedure FillLastRewardCycle(ssnaddr: ByStr20, deleg : ByStr20)
lwcd_o <- last_withdraw_cycle_deleg[deleg][ssnaddr];
match lwcd_o with
| Some lwcd =>
| None =>
lrc <- lastrewardcycle;
last_withdraw_cycle_deleg[deleg][ssnaddr] := lrc
end
end
procedure FillInDepositDelegAmt(ssnaddr: ByStr20, deleg: ByStr20, amount: Uint128)
deposit_amt <- deposit_amt_deleg[deleg][ssnaddr];
match deposit_amt with
| Some amt =>
new_amt = builtin add amt amount;
deposit_amt_deleg[deleg][ssnaddr] := new_amt;
ssn_deleg_amt[ssnaddr][deleg] := new_amt
| None =>
deposit_amt_deleg[deleg][ssnaddr] := amount;
ssn_deleg_amt[ssnaddr][deleg] := amount
end
end
procedure HasRewardToWithdraw(ssnaddr: ByStr20, deleg: ByStr20, total_rewards: Uint128)
no_total_rewards = builtin eq total_rewards uint128_zero;
match no_total_rewards with
| True =>
| False =>
lrcd_tmp <- last_withdraw_cycle_deleg[deleg][ssnaddr];
lrcd = option_uint32_value lrcd_tmp;
lrc <- lastrewardcycle;
has_reward = builtin lt lrcd lrc;
match has_reward with
| True =>
e = DelegHasUnwithdrawRewards;
ThrowError e
| False =>
end
end
end
procedure HasBufferedDeposit(ssnaddr: ByStr20, deleg: ByStr20)
ldcd_o <- last_buf_deposit_cycle_deleg[deleg][ssnaddr];
ldcd = option_uint32_value ldcd_o;
lrc <- lastrewardcycle;
has_buffered = uint32_le lrc ldcd;
match has_buffered with
| True =>
e = DelegHasBufferedDeposit;
ThrowError e
| False =>
end
end
procedure IsDelegstakeSufficient(amount: Uint128)
mindelegstake_l <- mindelegstake;
suffi =  uint128_le mindelegstake_l amount;
match suffi with
| True =>
| False =>
e = DelegStakeNotEnough;
ThrowError e
end
end
procedure AdjustDeleg(ssnaddr: ByStr20, deleg: ByStr20, total_amount: Uint128, withdraw_amount: Uint128)
suffient = uint128_le withdraw_amount total_amount;
match suffient with
| True =>
need_truncate =  builtin eq withdraw_amount total_amount;
match need_truncate with
| True =>
TruncateDeleg deleg ssnaddr
| False =>
lrc <- lastrewardcycle;
rest_deleg = builtin sub total_amount withdraw_amount;
TruncateDeleg deleg ssnaddr;
deposit_amt_deleg[deleg][ssnaddr] := rest_deleg;
ssn_deleg_amt[ssnaddr][deleg] := rest_deleg;
direct_deposit_deleg[deleg][ssnaddr][lrc] := rest_deleg;
last_withdraw_cycle_deleg[deleg][ssnaddr] := lrc;
last_buf_deposit_cycle_deleg[deleg][ssnaddr] := lrc
end
| False =>
e = DelegHasNoSufficientAmt;
ThrowError e
end
end
procedure ReDelegStakeAmt(initiator: ByStr20, ssn: ByStr20, redeleg_amt: Uint128)
ssn_o <- ssnlist[ssn];
deleg <- deposit_amt_deleg[initiator][ssn];
lrc <- lastrewardcycle;
match ssn_o with
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
match deleg with
| Some amt =>
HasRewardToWithdraw ssn initiator rewards;
HasBufferedDeposit ssn initiator;
AdjustDeleg ssn initiator amt redeleg_amt;
DecreaseTotalStakeAmt redeleg_amt;
new_amt = builtin sub stake_amt redeleg_amt;
minstake_tmp <- minstake;
status = uint128_le minstake_tmp new_amt;
ssn_option_tmp = Ssn status new_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
ssnlist[ssn] := ssn_option_tmp;
DecreaseTotalStakeAmtOnStatus new_amt status;
e = { _eventname: "Remove delegate from SSN"; ssn_addr: ssn; deleg_address: initiator; amt: redeleg_amt };
event e
| None =>
e = DelegDoesNotExistAtSSN;
ThrowError e
end
| None =>
e = SSNNotExist;
ThrowError e
end
end
procedure WithdrawalStakeAmt(initiator: ByStr20, ssn: ByStr20, withdraw_amount: Uint128)
ssn_o <- ssnlist[ssn];
deleg <- deposit_amt_deleg[initiator][ssn];
lrc <- lastrewardcycle;
match ssn_o with
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
match deleg with
| Some amt =>
HasRewardToWithdraw ssn initiator rewards;
HasBufferedDeposit ssn initiator;
AdjustDeleg ssn initiator amt withdraw_amount;
DecreaseTotalStakeAmt withdraw_amount;
new_amt = builtin sub stake_amt withdraw_amount;
minstake_tmp <- minstake;
status = uint128_le minstake_tmp new_amt;
ssn_option_tmp = Ssn status new_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
ssnlist[ssn] := ssn_option_tmp;
DecreaseTotalStakeAmtOnStatus new_amt status;
withdrawal_bnum <- & BLOCKNUMBER;
withdraw_amt_o <- withdrawal_pending[initiator][withdrawal_bnum];
withdraw_amt_pending = match withdraw_amt_o with
| Some v => builtin add v withdraw_amount
| None => withdraw_amount
end;
withdrawal_pending[initiator][withdrawal_bnum] := withdraw_amt_pending;
e = { _eventname: "Deleg withdraw deposit"; ssn_addr: ssn; deleg_address: initiator; amt: amt };
event e
| None =>
e = DelegDoesNotExistAtSSN;
ThrowError e
end
| None =>
e = SSNNotExist;
ThrowError e
end
end
procedure CalcStakeDelegPerCycle(tmp_arg: TmpArg)
match tmp_arg with
| TmpArg deleg ssn_operator reward_cycle =>
last_reward_cycle = builtin sub reward_cycle uint32_one;
last2_reward_cycle = sub_one_to_zero last_reward_cycle;
cur_opt <- direct_deposit_deleg[deleg][ssn_operator][last_reward_cycle];
buf_opt <- buff_deposit_deleg[deleg][ssn_operator][last2_reward_cycle];
comb_opt = option_add cur_opt buf_opt;
last_amt_o <- deleg_stake_per_cycle[deleg][ssn_operator][last_reward_cycle];
last_amt = option_uint128_value last_amt_o;
match comb_opt with
| Some stake =>
total_stake = builtin add last_amt stake;
deleg_stake_per_cycle[deleg][ssn_operator][reward_cycle] := total_stake
| None =>
deleg_stake_per_cycle[deleg][ssn_operator][reward_cycle] := last_amt
end
end
end
procedure MintCall(recipient: ByStr20, amount: Uint128)
addr <- gziladdr;
msg_to_gzil = {_tag: "Mint"; _recipient: addr; _amount: uint128_zero;
recipient: recipient; amount: amount};
msgs = one_msg msg_to_gzil;
send msgs
end
procedure IncreaseReward(ssn: ByStr20, deleg: ByStr20, reward: Uint128)
exist_reward_o <- rewards_amt_deleg[ssn][deleg];
exist_reward = option_uint128_value exist_reward_o;
new_reward = builtin add exist_reward reward;
rewards_amt_deleg[ssn][deleg] := new_reward
end
procedure CalcRewardsDelegPerCycle(tmp_arg: TmpArg)
match tmp_arg with
| TmpArg deleg ssn_operator reward_cycle =>
staking_per_cycle_for_deleg_opt <- deleg_stake_per_cycle[deleg][ssn_operator][reward_cycle];
staking_and_rewards_per_cycle_for_ssn_opt <- stake_ssn_per_cycle[ssn_operator][reward_cycle];
match staking_per_cycle_for_deleg_opt with
| Some staking_of_deleg =>
match staking_and_rewards_per_cycle_for_ssn_opt with
| Some (SSNCycleInfo total_staking total_rewards) =>
reward_tmp = builtin mul total_rewards staking_of_deleg;
reward = builtin div reward_tmp total_staking;
IncreaseReward ssn_operator deleg reward
| None =>
end
| None =>
end
end
end
procedure WithdrawalStakeRewards(deleg: ByStr20, ssn_operator: ByStr20)
last_withdraw_cycle_deleg_m <- last_withdraw_cycle_deleg[deleg][ssn_operator];
last_withdraw_cycle = option_uint32_value last_withdraw_cycle_deleg_m;
lrc <- lastrewardcycle;
m = builtin add last_withdraw_cycle uint32_one;
n = builtin add lrc uint32_one;
list_need_compute_rewards = iota m n;
mapper = @list_map Uint32 TmpArg;
f = fun (cycle: Uint32) => TmpArg deleg ssn_operator cycle;
combined_args_list = mapper f list_need_compute_rewards;
forall combined_args_list CalcStakeDelegPerCycle;
rewards_amt_deleg[ssn_operator][deleg] := uint128_zero;
forall combined_args_list CalcRewardsDelegPerCycle;
reward <- rewards_amt_deleg[ssn_operator][deleg];
reward = option_uint128_value reward;
SendDelegRewards deleg reward;
MintCall deleg reward;
ssn_o <- ssnlist[ssn_operator];
match ssn_o with
| Some (Ssn active_status stake_amt total_rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
rest_rewards = builtin sub total_rewards reward;
ssn = Ssn active_status stake_amt rest_rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
ssnlist[ssn_operator] := ssn
| None =>
end;
e = { _eventname: "WithdrawalStakeRewards"; rewards: reward};
event e;
last_withdraw_cycle_deleg[deleg][ssn_operator] := lrc
end
procedure Delegate(ssnaddr: ByStr20, initiator: ByStr20, amount: Uint128)
curval <- ssnlist[ssnaddr];
match curval with
| None =>
e = SSNNotExist;
ThrowError e
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
IsDelegstakeSufficient amount;
minstake_tmp <- minstake;
lrc <- lastrewardcycle;
FillInDepositDelegAmt ssnaddr initiator amount;
FillLastRewardCycle ssnaddr initiator;
match active_status with
| True  =>
last_buf_deposit_cycle_deleg[initiator][ssnaddr] := lrc;
new_buff_amt  = builtin add amount buffdeposit;
ssn = Ssn bool_active stake_amt rewards name urlraw urlapi new_buff_amt comm comm_rewards rec_addr;
ssnlist[ssnaddr] := ssn;
stake_amt_for_deleg_option  <- buff_deposit_deleg[initiator][ssnaddr][lrc];
match stake_amt_for_deleg_option  with
| Some stake_amt_for_deleg =>
new_stake_amt_for_deleg = builtin add stake_amt_for_deleg amount;
buff_deposit_deleg[initiator][ssnaddr][lrc] := new_stake_amt_for_deleg
| None =>
buff_deposit_deleg[initiator][ssnaddr][lrc] := amount
end
| False =>
new_stake_amt  = builtin add amount stake_amt;
status = uint128_le minstake_tmp new_stake_amt;
ssn = Ssn status new_stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
ssnlist[ssnaddr] := ssn;
IncreaseTotalStakeAmtOnStatus new_stake_amt status;
stake_amt_for_deleg_option  <- direct_deposit_deleg[initiator][ssnaddr][lrc];
match stake_amt_for_deleg_option  with
| Some stake_amt_for_deleg =>
new_stake_amt_for_deleg = builtin add stake_amt_for_deleg amount;
direct_deposit_deleg[initiator][ssnaddr][lrc] := new_stake_amt_for_deleg
| None =>
direct_deposit_deleg[initiator][ssnaddr][lrc] := amount
end
end
end
end
transition Pause(initiator: ByStr20)
IsProxy;
IsAdmin initiator;
paused := bool_active
end
transition UnPause(initiator: ByStr20)
IsProxy;
IsAdmin initiator;
paused := bool_inactive
end
transition UpdateAdmin(admin: ByStr20, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
contractadmin := admin
end
transition UpdateVerifier(verif: ByStr20, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
newverifier = Some {ByStr20} verif;
verifier := newverifier
end
transition UpdateVerifierRewardAddr(addr: ByStr20, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
newAddr = Some {ByStr20} addr;
verifier_receiving_addr := newAddr
end
transition UpdateStakingParameters(min_stake: Uint128, min_deleg_stake: Uint128, max_comm_change_rate: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
minstake := min_stake;
mindelegstake := min_deleg_stake;
maxcommchangerate := max_comm_change_rate
end
transition ChangeBNumReq(input_bnum_req: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
bnum_req := input_bnum_req
end
transition UpdateContractAddr(proxy_addr: ByStr20, gzil_addr: ByStr20, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
gziladdr := gzil_addr;
proxyaddr := proxy_addr
end
transition AddSSN(ssnaddr: ByStr20, name: String, urlraw: String, urlapi: String, comm: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
already_exists <- exists ssnlist[ssnaddr];
match already_exists with
| True  =>
e = SSNAlreadyExist;
ThrowError e
| False =>
status = bool_inactive;
stake_amt = Uint128 0;
rewards = Uint128 0;
buff_deposit = Uint128 0;
comm_rewards = Uint128 0;
s = Ssn status stake_amt rewards name urlraw urlapi buff_deposit comm comm_rewards ssnaddr;
ssnlist[ssnaddr] := s;
lrc <- lastrewardcycle;
comm_for_ssn[ssnaddr][lrc] := comm;
e = { _eventname: "SSN added"; ssn_addr: ssnaddr };
event e
end
end
transition UpdateSSN(ssnaddr: ByStr20, new_name: String, new_urlraw: String, new_urlapi: String, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
ssn_o <- ssnlist[ssnaddr];
match ssn_o with
| Some (Ssn active_status staking_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
ssn = Ssn active_status staking_amt deleg_reward new_name new_urlraw new_urlapi buffdeposit comm comm_rewards rec_addr;
ssnlist[ssnaddr] := ssn;
e = { _eventname: "UpdateSSN"; ssnaddr: ssnaddr; new_name: new_name; new_urlraw: new_urlraw; new_urlapi: new_urlapi; initiator: initiator };
event e
| None =>
e = SSNNotExist;
ThrowError e
end
end
transition RemoveSSN(ssnaddr: ByStr20, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
already_exists <- exists ssnlist[ssnaddr];
match already_exists with
| False =>
e = SSNNotExist;
ThrowError e
| True =>
delete ssnlist[ssnaddr];
delete comm_for_ssn[ssnaddr];
e = { _eventname: "SSN removed"; ssn_addr: ssnaddr };
event e
end
end
transition UpdateComm(new_rate: Uint128, initiator: ByStr20)
IsPaused;
IsProxy;
curval <- ssnlist[initiator];
match curval with
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
lrc <- lastrewardcycle;
old_comm_option <- comm_for_ssn[initiator][lrc];
match old_comm_option with
| Some old_comm =>
e = ChangeCommError;
ThrowError e
| None =>
ValidateRate new_rate;
ValidateChangeRate comm new_rate;
comm_for_ssn[initiator][lrc] := new_rate;
ssn =  Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit new_rate comm_rewards rec_addr;
ssnlist[initiator] := ssn;
e = { _eventname: "UpdateComm"; ssn_addr: initiator; new_rate: new_rate };
event e
end
| None =>
e = SSNNotExist;
ThrowError e
end
end
transition WithdrawComm(initiator: ByStr20)
IsPaused;
IsProxy;
curval <- ssnlist[initiator];
match curval with
| None =>
e = SSNNotExist;
ThrowError e
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
has_comm = uint128_gt comm_rewards uint128_zero;
match has_comm with
| True =>
e = { _eventname: "SSN withdraw reward"; ssn_addr: initiator; withdraw_comm: comm_rewards };
event e;
ssn = Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm uint128_zero rec_addr;
ssnlist[initiator] := ssn;
TransferFunds addfunds_tag comm_rewards rec_addr
| False =>
e = SSNNoComm;
ThrowError e
end
end
end
transition UpdateReceivingAddr(new_addr: ByStr20, initiator: ByStr20)
IsPaused;
IsProxy;
curval <- ssnlist[initiator];
match curval with
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
ssn =  Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards new_addr;
ssnlist[initiator] := ssn;
e = { _eventname: "UpdateReceivingAddr"; ssn_addr: initiator; new_addr: new_addr };
event e
| None =>
e = SSNNotExist;
ThrowError e
end
end
transition DelegateStake(ssnaddr: ByStr20, initiator: ByStr20)
IsPaused;
IsProxy;
accept;
amount = _amount;
Delegate ssnaddr initiator amount;
e = { _eventname: "DelegateStake"; ssn_addr: ssnaddr; delegator: initiator; amount: amount };
event e
end
transition WithdrawStakeRewards(ssnaddr: ByStr20, initiator: ByStr20)
IsPaused;
IsProxy;
DelegExists ssnaddr initiator;
WithdrawalStakeRewards initiator ssnaddr
end
transition WithdrawStakeAmt(ssnaddr: ByStr20, amt: Uint128, initiator: ByStr20)
IsPaused;
IsProxy;
WithdrawalStakeAmt initiator ssnaddr amt
end
transition CompleteWithdrawal(initiator: ByStr20)
IsPaused;
IsProxy;
withdraw_map_o <- withdrawal_pending[initiator];
match withdraw_map_o with
| Some withdraw_map =>
withdraw_list = builtin to_list withdraw_map;
withdrawal_zero = uint128_zero;
avaiable_withdrawal := withdrawal_zero;
c = Some {ByStr20} initiator;
current_deleg := c;
forall withdraw_list CalculateTotalWithdrawal;
withdraw_amt <- avaiable_withdrawal;
e = { _eventname: "CompleteWithdrawal"; ssn_addr: initiator; initiator: withdraw_amt };
event e;
TransferFunds addfunds_tag withdraw_amt initiator
| None =>
end
end
transition ReDelegateStake(ssnaddr: ByStr20, to_ssn: ByStr20, amount: Uint128, initiator: ByStr20)
IsPaused;
IsProxy;
same_ssn = builtin eq ssnaddr to_ssn;
match same_ssn with
| True =>
e = ReDelegInvalidSSNAddr;
ThrowError e
| False =>
ReDelegStakeAmt initiator ssnaddr amount;
Delegate to_ssn initiator amount;
e = { _eventname: "ReDelegateStakeSuccess"; ssnaddr: ssnaddr; to_ssn: to_ssn; delegator: initiator; delegate_amount: amount };
event e
end
end
transition AssignStakeReward(ssnreward_list: List SsnRewardShare, available_reward: Uint128, initiator: ByStr20)
IsPaused;
IsProxy;
CallerIsVerifier initiator;
lrc <- lastrewardcycle;
newLastRewardCycleNum = builtin add uint32_one lrc;
lastrewardcycle := newLastRewardCycleNum;
verifier_reward := available_reward;
forall ssnreward_list UpdateStakeReward;
verifier_reward_amt <- verifier_reward;
verifier_o <- verifier_receiving_addr;
match verifier_o with
| Some v =>
is_zero = builtin eq verifier_reward_amt uint128_zero;
match is_zero with
| True =>
| False =>
TransferFunds addfunds_tag verifier_reward_amt v
end
| None =>
e = VerifierRecvAddrNotSet;
ThrowError e
end
end
transition AddFunds(initiator: ByStr20)
IsProxy;
accept;
e = { _eventname : "Funds deposit "; funder : initiator };
event e
end
transition AddSSNAfterUpgrade(ssnaddr: ByStr20, stake_amt: Uint128, rewards: Uint128, name: String, urlraw: String, urlapi: String, buff_deposit: Uint128,  comm: Uint128, comm_rewards: Uint128, rec_addr: ByStr20, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
already_exists <- exists ssnlist[ssnaddr];
match already_exists with
| True  =>
e = { _eventname: "SSN already exists"; ssn_addr: ssnaddr };
event e
| False =>
minstake_tmp <- minstake;
status = uint128_le minstake_tmp stake_amt;
s = Ssn status stake_amt rewards name urlraw urlapi buff_deposit comm comm_rewards rec_addr;
ssnlist[ssnaddr] := s;
lrc <- lastrewardcycle;
comm_for_ssn[ssnaddr][lrc] := comm;
e = { _eventname: "SSN added"; ssn_addr: ssnaddr };
event e
end
end
transition UpdateDeleg(ssnaddr: ByStr20, deleg: ByStr20, stake_amt: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
ssn_o <- ssnlist[ssnaddr];
minstake_tmp <- minstake;
match ssn_o with
| Some (Ssn active_status staking_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
is_delete = builtin eq stake_amt uint128_zero;
match is_delete with
| True =>
alr_deleg_amt_o <- deposit_amt_deleg[deleg][ssnaddr];
match alr_deleg_amt_o with
| Some alr_deleg =>
TruncateDeleg deleg ssnaddr;
new_stake_amt = builtin sub staking_amt alr_deleg;
status = uint128_le minstake_tmp new_stake_amt;
ssn = Ssn status new_stake_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
ssnlist[ssnaddr] := ssn;
e = { _eventname: "Deleg deleted"; ssn_addr: ssnaddr; deleg_address: deleg };
event e;
TransferFunds addfunds_tag alr_deleg deleg
| None =>
end
| False =>
FillInDepositDelegAmt ssnaddr deleg stake_amt;
new_stake_amt = builtin add stake_amt staking_amt;
status = uint128_le minstake_tmp new_stake_amt;
ssn = Ssn status new_stake_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
ssnlist[ssnaddr] := ssn;
e = { _eventname: "Deleg added"; ssn_addr: ssnaddr; deleg_address: deleg };
event e
end
| None =>
e = SSNNotExist;
ThrowError e
end
end
transition PopulateStakeSSNPerCycle(ssn_addr: ByStr20, cycle: Uint32, info: SSNCycleInfo, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
stake_ssn_per_cycle[ssn_addr][cycle] := info
end
transition PopulateLastWithdrawCycleForDeleg(deleg_addr: ByStr20, ssn_addr: ByStr20, cycle: Uint32, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
last_withdraw_cycle_deleg[deleg_addr][ssn_addr] := cycle
end
transition PopulateBuffDeposit(deleg_addr: ByStr20, ssn_addr: ByStr20, cycle: Uint32, amt: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
buff_deposit_deleg[deleg_addr][ssn_addr][cycle] := amt
end
transition PopulateDirectDeposit(deleg_addr: ByStr20, ssn_addr: ByStr20, cycle: Uint32, amt: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
direct_deposit_deleg[deleg_addr][ssn_addr][cycle] := amt
end
transition PopulateCommForSSN(ssn_addr: ByStr20, cycle: Uint32, comm: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
comm_for_ssn[ssn_addr][cycle] := comm
end
transition PopulateTotalStakeAmt(amt: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
totalstakeamount := amt
end
transition DrainContractBalance(amt: Uint128, initiator: ByStr20)
IsProxy;
IsAdmin initiator;
bal <- _balance;
less_than = builtin lt bal amt;
match less_than with
| True => throw
| False =>
TransferFunds addfunds_tag amt initiator
end
end

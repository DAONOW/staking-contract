scilla_version 0
import ListUtils IntUtils BoolUtils
library SSNList
type Ssn =
| Ssn of Bool Uint128 Uint128 String String String Uint128 Uint128 Uint128 ByStr20
type SsnRewardShare =
| SsnRewardShare of ByStr20 Uint128
type DelegCycleInfo =
| DelegCycleInfo of ByStr20 Uint128 ByStr20
type SSNCycleInfo =
| SSNCycleInfo of Uint128 Uint128
type TmpArg =
| TmpArg of ByStr20 ByStr20 Uint128
let one_msg =
fun (m : Message) =>
let e = Nil {Message} in
Cons {Message} m e
let uint128_one =  Uint128 1
let uint128_zero = Uint128 0
let list_filter_between =
fun (left : Uint128) =>
fun (right : Uint128) =>
fun (l : List Uint128) =>
let fil = @list_filter Uint128 in
let f = fun (element : Uint128) =>
let res_l = builtin lt left element in
let res_r = builtin lt right element in
andb res_l res_r
in fil f l
let option_value =
tfun 'A =>
fun (default : 'A) =>
fun (opt_val : Option 'A) =>
match opt_val with
| Some v => v
| None => default
end
let option_map_uint128_uint128_value =
let f = @option_value (Map Uint128 Uint128) in
let emt = Emp Uint128 Uint128 in
f emt
let option_uint128_value =
let f = @option_value Uint128 in
f uint128_zero
let option_add =
fun (x_opt : Option Uint128) =>
fun (y_opt : Option Uint128) =>
match x_opt with
| Some x =>
let y = option_uint128_value y_opt in
let res = builtin add x y in
Some {Uint128} res
| None => y_opt
end
let bool_active = True
let bool_inactive = False
let uint128_10_power_7 = Uint128 10000000
let addfunds_tag = "AddFunds"
type Error =
| ContractFreezedFailure
| VerifierValidationFailed
| AdminValidationFailed
| ProxyValidationFailed
| DelegDoesNotExistAtSSN
| DelegDepositBlowMin
| UpdateStakingParamError
| DelegHasBufferedDeposit
| ChangeCommError
| SSNNotExist
| DelegNotExist
| SSNAlreadyExist
let make_error =
fun (result : Error) =>
let result_code =
match result with
| ContractFreezedFailure => Int32 -1
| VerifierValidationFailed => Int32 -2
| AdminValidationFailed => Int32 -3
| ProxyValidationFailed => Int32 -4
| DelegDoesNotExistAtSSN => Int32 -5
| DelegDepositBlowMin => Int32 -6
| UpdateStakingParamError => Int32 -7
| DelegHasBufferedDeposit => Int32 -8
| ChangeCommError => Int32 -9
| SSNNotExist => Int32 -10
| DelegNotExist => Int32 -11
| SSNAlreadyExist => Int32 -12
end
in
{ _exception : "Error"; code : result_code }
contract SSNList(
init_admin : ByStr20,
proxy_address : ByStr20
)
field ssnlist : Map ByStr20 Ssn = Emp ByStr20 Ssn
field delegs : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field stake_ssn_per_cycle : Map ByStr20 (Map Uint128 SSNCycleInfo) = Emp ByStr20 (Map Uint128 SSNCycleInfo)
field last_withdraw_cycle_deleg : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field buff_deposit_deleg : Map ByStr20 (Map ByStr20 (Map Uint128 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint128 Uint128))
field direct_deposit_deleg : Map ByStr20 (Map ByStr20 (Map Uint128 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint128 Uint128))
field stake_deleg_per_cycle : Map Uint128 Uint128 = Emp Uint128 Uint128
field deposit_amt_deleg : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field comm_for_ssn : Map ByStr20 (Map Uint128 Uint128) = Emp ByStr20 (Map Uint128 Uint128)
field reward_cycle_list : List Uint128   =  Nil {Uint128}
field verifier : Option ByStr20 = None {ByStr20}
field minstake : Uint128 = Uint128 0
field contractadmin : ByStr20  = init_admin
field lastrewardcycle : Uint128 = Uint128 0
field paused : Bool = True
procedure TruncateDeleg(deleg: ByStr20, ssnaddr: ByStr20)
delete delegs[ssnaddr][deleg];
delete deposit_amt_deleg[deleg][ssnaddr];
delete buff_deposit_deleg[deleg][ssnaddr];
delete direct_deposit_deleg[deleg][ssnaddr];
delete last_withdraw_cycle_deleg[deleg][ssnaddr]
end
procedure ThrowError(err : Error)
e = make_error err;
throw e
end
procedure CallerIsVerifier (initiator : ByStr20)
verifier_tmp <- verifier;
match verifier_tmp with
| Some v =>
is_verifier = builtin eq initiator v;
match is_verifier with
| True =>
| False =>
e = VerifierValidationFailed;
ThrowError e
end
| None =>
e = AdminValidationFailed;
ThrowError e
end
end
procedure IsAdmin(initiator : ByStr20)
contractadmin_tmp <- contractadmin;
is_admin = builtin eq initiator contractadmin_tmp;
match is_admin with
| True  =>
| False =>
e = AdminValidationFailed;
ThrowError e
end
end
procedure IsProxy()
is_proxy = builtin eq _sender proxy_address;
match is_proxy with
| True  =>
| False =>
e = ProxyValidationFailed;
ThrowError e
end
end
procedure IsPaused()
paused_tmp <- paused;
match paused_tmp with
| False =>
| True  =>
e = ContractFreezedFailure;
ThrowError e
end
end
procedure TransferFunds(tag: String, amt : Uint128, recipient : ByStr20)
msg = {_tag : tag; _recipient : recipient; _amount : amt};
msgs = one_msg msg;
send msgs
end
procedure UpdateStakeReward(entry : SsnRewardShare)
lastreward_blk <- lastrewardcycle;
match entry with
| SsnRewardShare ssnaddr reward_pct =>
curval <- ssnlist[ssnaddr];
match curval with
| None =>
e = SSNNotExist;
ThrowError e
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards received_address) =>
match active_status with
| False => throw
| True  =>
hundred = Uint128 100;
new_reward = builtin mul stake_amt reward_pct;
new_reward = builtin div new_reward hundred;
new_reward = builtin div new_reward uint128_10_power_7;
reward_comm_tmp = builtin mul new_reward comm;
reward_comm_tmp = builtin div reward_comm_tmp hundred;
reward_comm_tmp = builtin div reward_comm_tmp uint128_10_power_7;
total_reward_comm = builtin add reward_comm_tmp comm_rewards;
expected_reward = builtin sub new_reward total_reward_comm;
deleg_reward = builtin add expected_reward rewards;
new_stake_amt = builtin add stake_amt buffdeposit;
p = SSNCycleInfo stake_amt expected_reward;
stake_ssn_per_cycle[ssnaddr][lastreward_blk] := p;
ssn = Ssn active_status new_stake_amt deleg_reward name urlraw urlapi uint128_zero comm total_reward_comm received_address;
ssnlist[ssnaddr] := ssn;
e = { _eventname : "SSN assign reward"; ssn_addr : ssnaddr; total_reward : total_reward_comm };
event e
end
end
end
end
procedure SendDelegRewards(cycle: Uint128, addr: ByStr20, amt : Uint128)
TransferFunds addfunds_tag amt addr;
e = { _eventname : "Send deleg rewards"; addr : addr; amt :  amt};
event e
end
procedure DelegExists(ssnaddr: ByStr20, deleg: ByStr20)
if_exists <- exists delegs[ssnaddr][deleg];
match if_exists with
| True  =>
| False =>
e = DelegDoesNotExistAtSSN;
ThrowError e
end
end
procedure FillInDepositDelegAmt(ssnaddr: ByStr20, deleg : ByStr20, amount : Uint128)
deposit_amt <- deposit_amt_deleg[deleg][ssnaddr];
match deposit_amt with
| Some amt =>
new_amt = builtin add amt amount;
deposit_amt_deleg[deleg][ssnaddr] := new_amt
| None =>
deposit_amt_deleg[deleg][ssnaddr] := amount
end
end
procedure FillInDepositDeleg(ssnaddr: ByStr20, deleg : ByStr20)
FillInDepositDelegAmt ssnaddr deleg _amount
end
procedure FillInDelegsWithAmt(ssnaddr : ByStr20, deleg : ByStr20, deleg_amt : Uint128)
d <- delegs[ssnaddr][deleg];
match d with
| Some amt =>
new_amt_deleg = builtin add deleg_amt amt;
delegs[ssnaddr][deleg] := new_amt_deleg
| None =>
delegs[ssnaddr][deleg] := deleg_amt
end
end
procedure FillInDelegs(ssnaddr : ByStr20, deleg : ByStr20)
amt = _amount;
FillInDelegsWithAmt ssnaddr deleg _amount
end
procedure HasRewardToWithdraw(ssnaddr : ByStr20, deleg : ByStr20)
lrcd_tmp <- last_withdraw_cycle_deleg[deleg][ssnaddr];
lrcd = option_uint128_value lrcd_tmp;
lrc <- lastrewardcycle;
has_reward = builtin lt lrcd lrc;
match has_reward with
| True =>
throw
| False =>
end
end
procedure DistributeStakeAmt(initiator: ByStr20, ssn: ByStr20)
deleg <- delegs[ssn][initiator];
lrc <- lastrewardcycle;
ssn_option <- ssnlist[ssn];
match deleg with
| Some amt =>
last_withdraw_cycle <- last_withdraw_cycle_deleg[initiator][ssn];
lwc = option_uint128_value last_withdraw_cycle;
last_reward_cycle <- lastrewardcycle;
has_rewards = builtin lt lwc last_reward_cycle;
match has_rewards with
| True => throw
| False =>
HasRewardToWithdraw ssn initiator;
deposit_amt_option <- deposit_amt_deleg[initiator][ssn];
match deposit_amt_option with
| Some deposit_amt =>
TruncateDeleg initiator ssn;
match ssn_option with
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards received_addr) =>
new_amt = builtin sub stake_amt deposit_amt;
minstake_tmp <- minstake;
status = builtin lt minstake_tmp new_amt;
ssn_option_tmp = Ssn status new_amt rewards name urlraw urlapi buffdeposit comm comm_rewards received_addr;
ssnlist[ssn] := ssn_option_tmp;
new_amt_for_deleg = builtin sub amt deposit_amt;
delegs[ssn][initiator] := new_amt_for_deleg;
TransferFunds addfunds_tag deposit_amt initiator;
e = { _eventname : "Deleg withdraw deposit"; ssn_addr : ssn; deleg_address : initiator; deposit_amt : deposit_amt };
event e
| None =>
e = DelegHasBufferedDeposit;
ThrowError e
end
| None =>
e = SSNNotExist;
ThrowError e
end
end
| None =>
e = DelegDoesNotExistAtSSN;
ThrowError e
end
end
procedure CalcStakeDelegPerCycle (tmp_arg : TmpArg)
match tmp_arg with
| TmpArg deleg ssn_operator reward_cycle =>
lrc = builtin sub reward_cycle uint128_one;
cur_opt <- direct_deposit_deleg[deleg][ssn_operator][reward_cycle];
buf_opt <- buff_deposit_deleg[deleg][ssn_operator][lrc];
comb_opt = option_add cur_opt buf_opt;
result_map_opt <- stake_deleg_per_cycle[lrc];
stake_opt = option_add comb_opt result_map_opt;
match stake_opt with
| Some stake =>
stake_deleg_per_cycle[reward_cycle] := stake
| None =>
end
end
end
procedure CalcRewardsDelegPerCycleAndSend (tmp_arg : TmpArg)
match tmp_arg with
| TmpArg deleg ssn_operator reward_cycle =>
staking_per_cycle_for_deleg_opt <- stake_deleg_per_cycle[reward_cycle];
staking_and_rewards_per_cycle_for_ssn_opt <- stake_ssn_per_cycle[ssn_operator][reward_cycle];
match staking_per_cycle_for_deleg_opt with
| Some staking_of_deleg =>
match staking_and_rewards_per_cycle_for_ssn_opt with
| Some (SSNCycleInfo total_staking total_rewards) =>
reward_tmp = builtin mul total_rewards staking_of_deleg;
reward = builtin div reward_tmp total_staking;
SendDelegRewards reward_cycle deleg reward_tmp
| None =>
end
| None =>
end
end
end
procedure DistributeStakeRewards(deleg: ByStr20, ssn_operator: ByStr20)
last_withdraw_cycle_deleg_m <- last_withdraw_cycle_deleg[deleg][ssn_operator];
last_withdraw_cycle = option_uint128_value last_withdraw_cycle_deleg_m;
lrc <- lastrewardcycle;
rcl_local <- reward_cycle_list;
list_need_compute_rewards = list_filter_between last_withdraw_cycle lrc rcl_local;
mapper = @list_map Uint128 TmpArg;
f = fun (cycle : Uint128) => TmpArg deleg ssn_operator cycle;
combined_args_list = mapper f list_need_compute_rewards;
emp_map = Emp Uint128 Uint128;
stake_deleg_per_cycle := emp_map;
forall combined_args_list CalcStakeDelegPerCycle;
forall combined_args_list CalcRewardsDelegPerCycleAndSend
end
transition Pause(initiator : ByStr20)
IsProxy;
IsAdmin initiator;
paused := bool_active
end
transition UnPause(initiator : ByStr20)
IsProxy;
IsAdmin initiator;
paused := bool_inactive
end
transition UpdateAdmin(admin : ByStr20, initiator : ByStr20)
IsProxy;
IsAdmin initiator;
contractadmin := admin
end
transition UpdateVerifier(verif : ByStr20, initiator : ByStr20)
IsProxy;
IsAdmin initiator;
newverifier = Some {ByStr20} verif;
verifier := newverifier
end
transition DrainContractBalance(initiator : ByStr20, amt : Uint128)
IsProxy;
IsAdmin initiator;
bal <- _balance;
less_than = builtin lt bal amt;
match less_than with
| True => throw
| False =>
TransferFunds addfunds_tag amt initiator
end
end
transition UpdateStakingParameters (min_stake : Uint128, initiator : ByStr20)
IsProxy;
IsAdmin initiator;
minstake := min_stake
end
transition AddSSN(ssnaddr : ByStr20, name : String, urlraw : String, urlapi : String, initiator : ByStr20)
IsProxy;
IsAdmin initiator;
already_exists <- exists ssnlist[ssnaddr];
match already_exists with
| True  =>
e = SSNAlreadyExist;
ThrowError e
| False =>
status = bool_inactive;
stake_amt = Uint128 0;
rewards = Uint128 0;
buff_deposit = Uint128 0;
comm = Uint128 0;
comm_rewards = Uint128 0;
s = Ssn status stake_amt rewards name urlraw urlapi buff_deposit comm comm_rewards ssnaddr;
ssnlist[ssnaddr] := s;
lrc <- lastrewardcycle;
comm_for_ssn[ssnaddr][lrc] := comm;
e = { _eventname : "SSN added"; ssn_addr : ssnaddr };
event e
end
end
transition UpdateDeleg(ssnaddr : ByStr20, deleg : ByStr20, stake_amt : Uint128, initiator : ByStr20)
IsProxy;
IsAdmin initiator;
ssn_o <- ssnlist[ssnaddr];
minstake_tmp <- minstake;
match ssn_o with
| Some (Ssn active_status staking_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards received_addr) =>
is_delete = builtin eq stake_amt uint128_zero;
match is_delete with
| True =>
alr_deleg_amt_o <- delegs[ssnaddr][deleg];
match alr_deleg_amt_o with
| Some alr_deleg =>
TruncateDeleg deleg ssnaddr;
new_stake_amt = builtin sub staking_amt alr_deleg;
status = uint128_le minstake_tmp new_stake_amt;
ssn = Ssn status new_stake_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards received_addr;
ssnlist[ssnaddr] := ssn;
e = { _eventname : "Deleg deleted"; ssn_addr : ssnaddr; deleg_address : deleg };
event e
| None =>
end
| False =>
FillInDelegsWithAmt ssnaddr deleg stake_amt;
FillInDepositDelegAmt ssnaddr deleg stake_amt;
new_stake_amt = builtin add stake_amt staking_amt;
status = uint128_le minstake_tmp new_stake_amt;
ssn = Ssn status new_stake_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards received_addr;
ssnlist[ssnaddr] := ssn;
e = { _eventname : "Deleg added"; ssn_addr : ssnaddr; deleg_address : deleg };
event e
end
| None =>
e = SSNNotExist;
ThrowError e
end
end
transition PopulateStakeSSNPerCycle(initiator : ByStr20, ssn_addr : ByStr20, cycle : Uint128, info : SSNCycleInfo)
IsPaused;
IsProxy;
IsAdmin initiator;
stake_ssn_per_cycle[ssn_addr][cycle] := info
end
transition PopulateLastWithdrawCycleForDeleg(initiator : ByStr20, deleg_addr : ByStr20, ssn_addr : ByStr20, cycle : Uint128)
IsPaused;
IsProxy;
IsAdmin initiator;
last_withdraw_cycle_deleg[deleg_addr][ssn_addr] := cycle
end
transition PopulateBuffDeposit(initiator : ByStr20, deleg_addr : ByStr20, ssn_addr : ByStr20, cycle : Uint128, amt : Uint128)
IsPaused;
IsProxy;
IsAdmin initiator;
buff_deposit_deleg[deleg_addr][ssn_addr][cycle] := amt
end
transition PopulateDirectDeposit(initiator : ByStr20, deleg_addr : ByStr20, ssn_addr : ByStr20, cycle : Uint128, amt : Uint128)
IsPaused;
IsProxy;
IsAdmin initiator;
direct_deposit_deleg[deleg_addr][ssn_addr][cycle] := amt
end
transition UpdateLastRewardCycle(initiator : ByStr20, cycle : Uint128)
IsPaused;
IsProxy;
IsAdmin initiator;
lastrewardcycle := cycle
end
transition UpdateRewardCycleList(initiator : ByStr20, list: List Uint128)
IsPaused;
IsProxy;
IsAdmin initiator;
reward_cycle_list := list
end
transition RemoveSSN(ssnaddr : ByStr20, initiator : ByStr20)
IsPaused;
IsProxy;
IsAdmin initiator;
already_exists <- exists ssnlist[ssnaddr];
match already_exists with
| False =>
e = SSNNotExist;
ThrowError e
| True =>
delete ssnlist[ssnaddr];
delete comm_for_ssn[ssnaddr];
e = { _eventname : "SSN removed"; ssn_addr : ssnaddr };
event e
end
end
transition RemoveDeleg(ssnaddr : ByStr20, deleg : ByStr20, initiator : ByStr20)
IsPaused;
IsProxy;
IsAdmin initiator;
alr_exists <- exists delegs[ssnaddr][deleg];
match alr_exists with
| False =>
e = DelegNotExist;
ThrowError e
| True =>
DistributeStakeRewards deleg ssnaddr;
DistributeStakeAmt deleg ssnaddr;
TruncateDeleg deleg ssnaddr;
e = { _eventname : "Deleg removed"; ssn_addr : ssnaddr; deleg_address : deleg};
event e
end
end
transition UpdateComm(new_rate : Uint128, initiator : ByStr20)
IsPaused;
IsProxy;
curval <- ssnlist[initiator];
match curval with
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards received_addr) =>
lrc <- lastrewardcycle;
old_comm_option <- comm_for_ssn[initiator][lrc];
match old_comm_option with
| Some old_comm =>
e = ChangeCommError;
ThrowError e
| None =>
comm_for_ssn[initiator][lrc] := comm;
ssn =  Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit new_rate comm_rewards received_addr;
ssnlist[initiator] := ssn
end
| None =>
e = SSNNotExist;
ThrowError e
end
end
transition UpdateReceivedAddr(new_addr : ByStr20, initiator : ByStr20)
IsPaused;
IsProxy;
curval <- ssnlist[initiator];
match curval with
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards received_addr) =>
ssn =  Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards new_addr;
ssnlist[initiator] := ssn
| None =>
e = SSNNotExist;
ThrowError e
end
end
transition DelegateStake(ssnaddr : ByStr20, initiator : ByStr20)
IsPaused;
IsProxy;
accept;
curval <- ssnlist[ssnaddr];
match curval with
| None =>
e = SSNNotExist;
ThrowError e
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards received_addr) =>
minstake_tmp <- minstake;
lrc <- lastrewardcycle;
FillInDepositDeleg ssnaddr initiator;
FillInDelegs ssnaddr initiator;
match active_status with
| True  =>
new_buff_amt  = builtin add _amount buffdeposit;
new_stake_amt = builtin add new_buff_amt stake_amt;
ssn = Ssn bool_active stake_amt rewards name urlraw urlapi new_buff_amt comm comm_rewards received_addr;
ssnlist[ssnaddr] := ssn;
stake_amt_for_deleg_option  <- buff_deposit_deleg[initiator][ssnaddr][lrc];
match stake_amt_for_deleg_option  with
| Some stake_amt_for_deleg =>
new_stake_amt_for_deleg = builtin add stake_amt_for_deleg _amount;
buff_deposit_deleg[initiator][ssnaddr][lrc] := new_stake_amt_for_deleg
| None =>
buff_deposit_deleg[initiator][ssnaddr][lrc] := _amount
end
| False =>
new_stake_amt  = builtin add _amount stake_amt;
status = uint128_le minstake_tmp new_stake_amt;
ssn = Ssn status new_stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards received_addr;
ssnlist[ssnaddr] := ssn;
d <- delegs[ssnaddr][initiator];
stake_amt_for_deleg_option  <- direct_deposit_deleg[initiator][ssnaddr][lrc];
match stake_amt_for_deleg_option  with
| Some stake_amt_for_deleg =>
new_stake_amt_for_deleg = builtin add stake_amt_for_deleg _amount;
direct_deposit_deleg[initiator][ssnaddr][lrc] := new_stake_amt_for_deleg
| None =>
direct_deposit_deleg[initiator][ssnaddr][lrc] := _amount
end
end
end
end
transition AssignStakeReward(ssnreward_list : List SsnRewardShare, initiator : ByStr20)
IsPaused;
IsProxy;
CallerIsVerifier initiator;
lrc <- lastrewardcycle;
forall ssnreward_list UpdateStakeReward;
newLastRewardCycleNum = builtin add uint128_one lrc;
lastrewardcycle := newLastRewardCycleNum;
rcl_local <- reward_cycle_list;
rcl_new = Cons {Uint128} newLastRewardCycleNum rcl_local;
reward_cycle_list := rcl_new
end
transition WithdrawComm(initiator : ByStr20)
IsPaused;
IsProxy;
curval <- ssnlist[initiator];
match curval with
| None =>
e = SSNNotExist;
ThrowError e
| Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards received_addr) =>
TransferFunds addfunds_tag comm_rewards received_addr;
e = { _eventname : "SSN withdraw reward"; ssn_addr : initiator; withdraw_total_reward : rewards };
event e;
ssn = Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm uint128_zero received_addr;
ssnlist[initiator] := ssn
end
end
transition WithdrawStakeRewards(ssn_operator : ByStr20, deleg : ByStr20)
IsPaused;
IsProxy;
DelegExists ssn_operator deleg;
DistributeStakeRewards deleg ssn_operator
end
transition WithdrawStakeAmt(ssn: ByStr20, initiator : ByStr20)
IsPaused;
IsProxy;
DistributeStakeAmt initiator ssn
end
transition AddFunds(initiator : ByStr20)
IsPaused;
IsProxy;
accept;
e = { _eventname : "Verifier deposit funds"; verifier : initiator };
event e
end
transition PopulateCommForSSN(initiator : ByStr20, ssn_addr : ByStr20, cycle : Uint128, comm : Uint128)
IsPaused;
IsProxy;
IsAdmin initiator;
comm_for_ssn[ssn_addr][cycle] := comm
end

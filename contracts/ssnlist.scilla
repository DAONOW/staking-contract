scilla_version 0

import ListUtils IntUtils

library SSNList

(* A non-custodial staking contract with admin privileges *)
(* SSN Data Type *)
(* Each SSN has the following fields: *)

(* ActiveStatus      : Bool *)
(*                     Represents whether the SSN has the minnimum stake amount and therefore ready to participate in staking and receive rewards. *)
(* StakeAmount       : Uint128 *)
(*                     Total stake that can be used for reward calculation. *)
(* StakeRewards      : Uint128 *)
(*                     (Unwithdrawn) Reward accumulated so far across all cycles. It only includes the reward that the SSN can distribute to its delegators. *)
(*                     It does not include SSN's own commission. *)
(* Name              : String *)
(*                     A human-readable name for this SSN. *)
(* URLRaw            : String *)
(*                     Represents "ip:port" of the SSN serving raw API requests. *)
(* URLApi            : String *)
(*                     Representing URL exposed by SSN serving public API requests. *)
(* BufferedDeposit   : Uint128 *)
(*                     Stake deposit that cannot be counted as a part of reward calculation for the ongoing reward cycle. But, to be considered *)
(*                     for the next one. *)
(* Commission        : Uint128 *)
(*                     Percentage of incoming rewards that the SSN takes as commission. If the commission is 10.5%, then it is multiplied by 10^7 and then the resulting integer is set as commission. The assumption is that the percentage is up to 7 decimal places. *)
(* CommissionRewards : Uint128 *)
(*                     Number of ZILs earned as commission by the SSN. *)
(* ReceivingAddress   : ByStr20 *)
(*                     Address that will be used to receive commission. *)
(* Invariant : ActiveStatus = (Minstake < StakeAmount)  *)

type Ssn =
| Ssn of Bool Uint128 Uint128 String String String Uint128 Uint128 Uint128 ByStr20

(* SSNRewardShare Data Type *)
(* SSNRewardShare has the following fields: *)
(* CycleReward is in Qa *)

(*  SSNAddress        : ByStr20 *)
(*                      Address of the SSN. *)
(*  CycleReward       : Uint128 *)
(*                      Integer representation of reward assigned by the verifier to this SSN for this cycle. *)
(*                      It's floor(NumberOfDSEpochsInCurrentCycle * 110,000 * VerificationPassed) *)
(* https://github.com/Zilliqa/ZIP/blob/zip-11-author-fix/zips/zip-11.md#verifier *)

type SsnRewardShare =
| SsnRewardShare of ByStr20 Uint128

(*  SSNAddress        : ByStr20 *)
(*                      Address of the SSN. *)
(*  CycleReward       : Uint128 *)
(*                      Integer representation of reward assigned by the verifier to this SSN for this cycle. *)
(*  TotalStakeAmount  : Uint128 *)
(*                      Total stake amount at a specific cycle.                                               *)
type SsnStakeRewardShare = 
| SsnStakeRewardShare of ByStr20 Uint128 Uint128

(* SSNCycleInfo Data Type *)

(*   Each SSNCycleInfo has the following fields: *)
(*    TotalStakeDuringTheCycle            : Uint128 *)
(*                                          Represents the amount staked during this cycle for the given SSN. *)
(*    TotalRewardEarnedDuringTheCycle    : Uint128 *)
(*                                         Represents the total reward earned during this cycle for the given SSN. . *)

type SSNCycleInfo =
| SSNCycleInfo of Uint128 Uint128

(* Used in order to be able to iterate over the procedure CalcStakeRewards *)
(* deleg, ssn_operator, reward_cycle *)

type TmpArg =
| TmpArg of ByStr20 ByStr20 Uint32

let one_msg =
  fun (m : Message) =>
    let e = Nil {Message} in
    Cons {Message} m e

let uint128_one =  Uint128 1
let uint128_zero = Uint128 0
let uint128_10_power_7 = Uint128 10000000
let uint128_100 = Uint128 100

let uint32_one = Uint32 1
let uint32_zero = Uint32 0


let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end

let option_map_uint128_uint128_value =
  let f = @option_value (Map Uint128 Uint128) in
  let emt = Emp Uint128 Uint128 in
  f emt

let option_uint128_value =
  let f = @option_value Uint128 in
  f uint128_zero
  
let option_uint32_value =
  let f = @option_value Uint32 in
  f uint32_zero

let sub_one_to_zero =
  fun (x: Uint32) =>
  let less_than_one = builtin lt x uint32_one in
  match less_than_one with
  | True =>
    uint32_zero
  | False =>
    let res = builtin sub x uint32_one in
    res
  end

let option_add =
  fun (x_opt: Option Uint128) =>
  fun (y_opt: Option Uint128) =>
    match x_opt with
    | Some x =>
      let y = option_uint128_value y_opt in
      let res = builtin add x y in
      Some {Uint128} res
    | None => y_opt
    end

let change_rate =
  fun (old: Uint128) =>
  fun (new: Uint128) =>
    let a = builtin lt old new in
    match a with
    | True =>
      builtin sub new old
    | False =>
      builtin sub old new
    end

let iota : Uint32 -> Uint32 -> List Uint32 =
  fun (m : Uint32) => fun (n : Uint32) =>
    let m_lt_n = builtin lt m n in
    match m_lt_n with
    | True =>
        let delta = builtin sub n m in
        let delta_nat = builtin to_nat delta in
        let nil = Nil {Uint32} in
        let acc_init = Pair {(List Uint32) Uint32} nil n in
        let one = Uint32 1 in
        let step = fun (xs_n : Pair (List Uint32) Uint32) => fun (ignore : Nat) =>
          match xs_n with
          | Pair xs n =>
              let new_n = builtin sub n one in
              let new_xs = Cons {Uint32} new_n xs in
              Pair {(List Uint32) Uint32} new_xs new_n
          end in
        let fold = @nat_fold (Pair (List Uint32) Uint32) in
        let xs_m = fold step acc_init delta_nat in
        match xs_m with
        | Pair xs m => xs
        end
    | False => Nil {Uint32}
    end

let map_to_stake_rewards = 
  fun (total_stake: Uint128) =>
  fun (element: SsnRewardShare) =>
    match element with
    | SsnRewardShare ssnaddr cycle_reward => SsnStakeRewardShare ssnaddr cycle_reward total_stake 
    end

let bool_active = True
let bool_inactive = False
let addfunds_tag = "AddFunds"

type Error =
  | ContractFrozenFailure
  | VerifierValidationFailed
  | AdminValidationFailed
  | ProxyValidationFailed
  | DelegDoesNotExistAtSSN
  | DelegHasBufferedDeposit
  | ChangeCommError
  | SSNNotExist
  | SSNAlreadyExist
  | DelegHasUnwithdrawRewards
  | DelegHasNoSufficientAmt
  | SSNNoComm
  | DelegStakeNotEnough
  | ExceedMaxChangeRate
  | ExceedMaxCommRate
  | InvalidTotalAmt
  | VerifierNotSet
  | VerifierRecvAddrNotSet
  | ReDelegInvalidSSNAddr
  | AvailableRewardsError

let make_error =
  fun (result: Error) =>
    let result_code =
      match result with
      | ContractFrozenFailure => Int32 -1
      | VerifierValidationFailed => Int32 -2
      | AdminValidationFailed => Int32 -3
      | ProxyValidationFailed => Int32 -4
      | DelegDoesNotExistAtSSN => Int32 -5
      | DelegHasBufferedDeposit => Int32 -6
      | ChangeCommError => Int32 -7
      | SSNNotExist => Int32 -8
      | SSNAlreadyExist => Int32 -9
      | DelegHasUnwithdrawRewards => Int32 -10
      | DelegHasNoSufficientAmt => Int32 -11
      | SSNNoComm => Int32 -12
      | DelegStakeNotEnough => Int32 -13
      | ExceedMaxChangeRate => Int32 -14
      | ExceedMaxCommRate => Int32 -15
      | InvalidTotalAmt => Int32 -16
      | VerifierNotSet => Int32 -17
      | VerifierRecvAddrNotSet => Int32 -18
      | ReDelegInvalidSSNAddr => Int32 -19
      | AvailableRewardsError => Int32 -20
      end
    in
    { _exception: "Error"; code: result_code }
(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract SSNList(
  init_admin: ByStr20,
  init_proxy_address: ByStr20,
  init_gzil_address: ByStr20
)

(* Keeps track of SSNS *)
(* AddressOfSSN -> SSNInfo *)
field ssnlist: Map ByStr20 Ssn = Emp ByStr20 Ssn

(* Record commission for SSN for each reward cycle *)
(* AddressofSSN -> (RewardCycle -> commission ) *)
field comm_for_ssn: Map ByStr20 (Map Uint32 Uint128) = Emp ByStr20 (Map Uint32 Uint128)

(* Following data structure helps to calculate rewards for delegators *)
(* Keeps track of stakes deposited at SSNs *)
(* Record deposit amount for every deleg for every ssn *)
(* AddressofDeleg -> (AddressofSSN -> StakeAmount) *)
field deposit_amt_deleg: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(* AddressofSSN -> (AddressofDeleg -> StakeAmount) *)
(* Used by offchain services like wallets *)
field ssn_deleg_amt: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(* Keeps track of buffered deposit for a delegator *)
(* AddressOfDeleg -> (AddressofSSN -> (RewardCycleNumber -> BufferedStakeAmountDuringTheCycle)) *)
(* The BufferedStakeAmount will only be truely delegated at next cycle *)
field buff_deposit_deleg: Map ByStr20 (Map ByStr20 (Map Uint32 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint32 Uint128))

(* Keeps track of stake deposits for a delegator that can be considered for reward calcuation *)
(* AddressofDeleg -> (AddressofSSN -> (RewardCycleNumber -> StakeAmount)) *)
field direct_deposit_deleg: Map ByStr20 (Map ByStr20 (Map Uint32 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint32 Uint128))

(* Keeps track of the cycle number when a deleg last withdrew its rewards *)
(* AddressOfDeleg -> ( AddressOfSSN -> CycleNumberWhenLastWithdrawn) *)
(* notice here, the last withdraw cycle also indicated the earlist deposit cycle this round *)
(* this will help reduce some calculation for DistributeStakeRewards, also can avoid some corner cases *)
field last_withdraw_cycle_deleg: Map ByStr20 (Map ByStr20 Uint32) = Emp ByStr20 (Map ByStr20 Uint32)

(* Keeps track of the cycle number when a deleg last buffered deposit its delegate *)
(* AddressOfDeleg -> ( AddressOfSSN -> CycleNumberWhenLastDeposit) *)
field last_buf_deposit_cycle_deleg: Map ByStr20 (Map ByStr20 Uint32) = Emp ByStr20 (Map ByStr20 Uint32)

(* AddressOfSSN -> (RewardCycleNumber -> Pair (TotalStakeDuringTheCycleForSSN, TotalRewardEarnedDuringTheCycle) *)
field stake_ssn_per_cycle: Map ByStr20 (Map Uint32 SSNCycleInfo) = Emp ByStr20 (Map Uint32 SSNCycleInfo)

(* AddressOfDeleg -> AddressOfSSN -> EffectCycleNum -> Deposit *)
field deleg_stake_per_cycle: Map ByStr20 (Map ByStr20 (Map Uint32 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint32 Uint128))

field withdrawal_pending: Map ByStr20 (Map BNum Uint128) = Emp ByStr20 (Map BNum Uint128)

field bnum_req: Uint128 = Uint128 24000

(* Temporary storage maps *)
(* Used during CalcRewardsDelegPerCycle *)
field cycle_rewards_deleg: Uint128 = uint128_zero

(* Used during AssignStakeReward *)
(* Record the latest rewards earned by verifier *)
field verifier_reward: Uint128 = uint128_zero

field available_withdrawal: Uint128 = uint128_zero

field current_deleg: Option ByStr20 = None {ByStr20}

field verifier: Option ByStr20 = None {ByStr20}

field verifier_receiving_addr: Option ByStr20 = None {ByStr20}

(* 10 mil ZIL expressed in Qa where 1 ZIL = 10^12 Qa *)
field minstake: Uint128 = Uint128 10000000000000000000

(* 1000 ZIL expresssed in Qa where 1 ZIL = 10^12 Qa *)
field mindelegstake: Uint128 = Uint128 1000000000000000

field contractadmin: ByStr20  = init_admin
field gziladdr: ByStr20 = init_gzil_address
field lastrewardcycle: Uint32 = uint32_one
field paused: Bool = True

(* 1% *)
field maxcommchangerate: Uint128 = uint128_one

(* 100% expressed as an integer multipled by 10^7 *)
field maxcommrate: Uint128 = Uint128 1000000000
field totalstakeamount: Uint128 = uint128_zero

(* Procedures *)
(* Internal functions, used like Solidity modifiers *)
procedure TruncateDeleg(deleg: ByStr20, ssnaddr: ByStr20)
  delete deposit_amt_deleg[deleg][ssnaddr];
  delete ssn_deleg_amt[ssnaddr][deleg];
  delete buff_deposit_deleg[deleg][ssnaddr];
  delete direct_deposit_deleg[deleg][ssnaddr];
  delete last_withdraw_cycle_deleg[deleg][ssnaddr];
  delete deleg_stake_per_cycle[deleg][ssnaddr];
  delete last_buf_deposit_cycle_deleg[deleg][ssnaddr]
end

procedure ThrowError(err: Error)
  e = make_error err;
  throw e
end

procedure ValidateRate(rate: Uint128)
  max_rate <- maxcommrate;
  validate = uint128_le rate max_rate;
  match validate with
  | True =>
  | False =>
    e = ExceedMaxCommRate;
    ThrowError e
  end
end

procedure ValidateChangeRate(old: Uint128, new: Uint128)
  maxcommchangerate_l <- maxcommchangerate;
  absolute_change = change_rate old new;
  absolute_change = builtin div absolute_change uint128_10_power_7;
  valid = uint128_le absolute_change maxcommchangerate_l;
  match valid with
  | True =>
  | False =>
    e = ExceedMaxChangeRate;
    ThrowError e
  end
end

procedure IncreaseTotalStakeAmt(amt: Uint128)
  current_amt <- totalstakeamount;
  new_amt = builtin add current_amt amt;
  totalstakeamount := new_amt
end

procedure DecreaseTotalStakeAmt(amt: Uint128)
  current_amt <- totalstakeamount;
  valid = uint128_le amt current_amt;
  match valid with
  | True =>
    new_amt = builtin sub current_amt amt;
    totalstakeamount := new_amt
  | False =>
    e = InvalidTotalAmt;
    ThrowError e
  end
end

procedure IncreaseTotalStakeAmtOnStatus(amt: Uint128, status: Bool)
  match status with
  | True =>
    e = { _eventname: "SSNActive"; increase_amt: amt };
    event e;
    IncreaseTotalStakeAmt amt
  | False =>
  end  
end

procedure DecreaseTotalStakeAmtOnStatus(amt: Uint128, status: Bool)
  match status with
  | True =>
  | False =>
    e = { _eventname: "SSNInactive"; decreased_amt: amt };
    event e;
    DecreaseTotalStakeAmt amt
  end
end

(* Check if the initiator is verifier *)
procedure CallerIsVerifier(initiator: ByStr20)
  verifier_tmp <- verifier;
  match verifier_tmp with
  | Some v =>
    is_verifier = builtin eq initiator v;
    match is_verifier with
    | True =>
    | False =>
      e = VerifierValidationFailed;
      ThrowError e
    end
  | None =>
    e = VerifierNotSet;
    ThrowError e
  end
end

(* Check if the initiator is admin *)
procedure IsAdmin(initiator: ByStr20)
  contractadmin_tmp <- contractadmin;
  is_admin = builtin eq initiator contractadmin_tmp;
  match is_admin with
  | True  =>
  | False =>
    e = AdminValidationFailed;
    ThrowError e
  end
end

(* Check if the caller is the proxy *)
procedure IsProxy()
  is_proxy = builtin eq _sender init_proxy_address;
  match is_proxy with
  | True  =>
  | False =>
    e = ProxyValidationFailed;
    ThrowError e
  end
end

(* Check if the contract is not paused *)
procedure IsNotPaused()
  paused_tmp <- paused;
  match paused_tmp with
  | False =>
  | True  =>
    e = ContractFrozenFailure;
    ThrowError e
  end
end

(* Check if the contract is paused *)
procedure IsPaused()
  paused_tmp <- paused;
  match paused_tmp with
  | False =>
    e = ContractFrozenFailure;
    ThrowError e
  | True => 
  end
end

procedure TransferFunds(tag: String, amt: Uint128, recipient: ByStr20)
    msg = {_tag: tag; _recipient: recipient; _amount: amt};
    msgs = one_msg msg;
    send msgs
end

(* current_block > withdraw_number + bnum_req *)
procedure CalculateTotalWithdrawal(withdraw: Pair BNum Uint128)
  current_deleg_o <- current_deleg;
  match current_deleg_o with
  | Some current_deleg =>
    match withdraw with
    | Pair withdraw_number amt =>
      current_bnum <- & BLOCKNUMBER;
      current_bnum_req <- bnum_req;
      bnum = builtin badd withdraw_number current_bnum_req;
      can_withdraw = builtin blt bnum current_bnum;
      match can_withdraw with
      | True =>
          delete withdrawal_pending[current_deleg][withdraw_number];
          current_amt <- available_withdrawal;
          current_amt = builtin add current_amt amt;
          available_withdrawal := current_amt
      | False => 
      end
    end
  | None => (* Won't reach *)
  end
end

procedure AssertCorrectRewards(remaining_rewards: Uint128, ssn_rewards: Uint128)
  validate = uint128_le ssn_rewards remaining_rewards;
  match validate with
  | True =>
  | False =>
    e = AvailableRewardsError;
    ThrowError e
  end
end

procedure UpdateStakeReward(entry: SsnStakeRewardShare)
  lastreward_blk <- lastrewardcycle;
  match entry with
  | SsnStakeRewardShare ssnaddr cycle_reward total_stake =>
    curval <- ssnlist[ssnaddr];
    match curval with
    | None =>
      e = SSNNotExist;
      ThrowError e
    | Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
      match active_status with
      | False =>
        e = { _eventname: "SSN inactive"; ssn_addr: ssnaddr};
        event e
      | True  =>
        (* To calculate rewards belong to this ssn operator *)
        new_rewards_tmp = builtin mul stake_amt cycle_reward;
        new_rewards = builtin div new_rewards_tmp total_stake;


        current_verifier_reward <- verifier_reward;

        AssertCorrectRewards current_verifier_reward new_rewards;
        new_current_verifier_reward = builtin sub current_verifier_reward new_rewards;
        verifier_reward := new_current_verifier_reward;

        (* To calculate commission *)
        reward_comm_tmp = builtin mul new_rewards comm;
        reward_comm_tmp = builtin div reward_comm_tmp uint128_100;
        reward_comm_tmp = builtin div reward_comm_tmp uint128_10_power_7;
        total_reward_comm = builtin add reward_comm_tmp comm_rewards;

        (* To calculate rewards can be distributed to delegators *)
        delegate_reward = builtin sub new_rewards reward_comm_tmp;

        p = SSNCycleInfo stake_amt delegate_reward;
        stake_ssn_per_cycle[ssnaddr][lastreward_blk] := p;

        (* Update ssn info *)
        new_stake_amt = builtin add stake_amt buffdeposit;
        deleg_reward = builtin add delegate_reward rewards;
        ssn = Ssn active_status new_stake_amt deleg_reward name urlraw urlapi uint128_zero comm total_reward_comm rec_addr;
        ssnlist[ssnaddr] := ssn;
        IncreaseTotalStakeAmt buffdeposit;
        e = { _eventname: "SSN assign reward"; ssnaddr: ssnaddr; cycle_number: lastreward_blk; delegate_rewards: delegate_reward; comm_rewards:  reward_comm_tmp};
        event e
      end
    end
  end
end

(* this procedure is to send rewards to deleg *)
procedure SendDelegRewards(addr: ByStr20, amt: Uint128)
  to_send = builtin eq amt uint128_zero;
  match to_send with
  | True =>
  | False =>
    TransferFunds addfunds_tag amt addr;
    e = { _eventname: "Send deleg rewards"; addr: addr; amt:  amt};
    event e
  end
end

(* Check if a delegs exists for a given SSN *)
procedure DelegExists(ssnaddr: ByStr20, deleg: ByStr20)
  if_exists <- exists deposit_amt_deleg[deleg][ssnaddr];
  match if_exists with
  | True  =>
  | False =>
    e = DelegDoesNotExistAtSSN;
    ThrowError e
    end
end

procedure FillLastWithdrawCycle(ssnaddr: ByStr20, deleg : ByStr20)
  lwcd_o <- last_withdraw_cycle_deleg[deleg][ssnaddr];
  match lwcd_o with
  | Some lwcd =>
  | None =>
    lrc <- lastrewardcycle;
    last_withdraw_cycle_deleg[deleg][ssnaddr] := lrc
  end
end

procedure FillInDepositDelegAmt(ssnaddr: ByStr20, deleg: ByStr20, amount: Uint128)
  deposit_amt <- deposit_amt_deleg[deleg][ssnaddr];
  match deposit_amt with
  | Some amt =>
    new_amt = builtin add amt amount;
    deposit_amt_deleg[deleg][ssnaddr] := new_amt;
    ssn_deleg_amt[ssnaddr][deleg] := new_amt
  | None =>
    deposit_amt_deleg[deleg][ssnaddr] := amount;
    ssn_deleg_amt[ssnaddr][deleg] := amount
  end
end

procedure AssertNoRewards(ssnaddr: ByStr20, deleg: ByStr20, total_rewards: Uint128)
  no_total_rewards = builtin eq total_rewards uint128_zero;
  match no_total_rewards with
  | True =>
  | False =>
    lrcd_tmp <- last_withdraw_cycle_deleg[deleg][ssnaddr];
    lrcd = option_uint32_value lrcd_tmp;
    lrc <- lastrewardcycle;
    has_reward = builtin lt lrcd lrc;
    match has_reward with
    | True =>
      e = DelegHasUnwithdrawRewards;
      ThrowError e
    | False =>
    end
  end
end

procedure AsseertNoBufferedDeposit(ssnaddr: ByStr20, deleg: ByStr20)
  ldcd_o <- last_buf_deposit_cycle_deleg[deleg][ssnaddr];
  ldcd = option_uint32_value ldcd_o;
  lrc <- lastrewardcycle;
  (* in fact, lrc will only more than or equal to ldcd, equal means he delegates this around and withdraw this around as well *)
  has_buffered = uint32_le lrc ldcd;
  match has_buffered with
  | True =>
    e = DelegHasBufferedDeposit;
    ThrowError e
  | False =>
  end
end

procedure IsDelegstakeSufficient(amount: Uint128)
  mindelegstake_l <- mindelegstake;
  suffi =  uint128_le mindelegstake_l amount;
  match suffi with
  | True =>
  | False =>
    e = DelegStakeNotEnough;
    ThrowError e
  end
end

procedure AdjustDeleg(ssnaddr: ByStr20, deleg: ByStr20, total_amount: Uint128, withdraw_amount: Uint128)
  sufficient = uint128_le withdraw_amount total_amount;
  match sufficient with
  | True =>
    need_truncate =  builtin eq withdraw_amount total_amount;
    match need_truncate with
    | True =>
      (* Remove all info map recorded for this deleg *)
      TruncateDeleg deleg ssnaddr
    | False =>
      (* Readjust all rest deleg to this cycle *)
      lrc <- lastrewardcycle;
      rest_deleg = builtin sub total_amount withdraw_amount;
      (* rest delegate should also meet mindelegstake *)
      IsDelegstakeSufficient rest_deleg;
      TruncateDeleg deleg ssnaddr;
      (* Refer to transition TruncateDeleg, here we don't use Fillin transition because we *)
      (* know they are all empty, and this can reduce some gasfee *)
      deposit_amt_deleg[deleg][ssnaddr] := rest_deleg;
      ssn_deleg_amt[ssnaddr][deleg] := rest_deleg;
      direct_deposit_deleg[deleg][ssnaddr][lrc] := rest_deleg;
      last_withdraw_cycle_deleg[deleg][ssnaddr] := lrc
    end
  | False =>
    e = DelegHasNoSufficientAmt;
    ThrowError e
  end
end

procedure UnDelegateStakeAmt(initiator: ByStr20, ssn: ByStr20, redeleg_amt: Uint128)
  ssn_o <- ssnlist[ssn];
  deleg <- deposit_amt_deleg[initiator][ssn];
  lrc <- lastrewardcycle;
  match ssn_o with
  | Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
    match deleg with
    | Some amt =>
      AssertNoRewards ssn initiator rewards;
      AsseertNoBufferedDeposit ssn initiator;
      AdjustDeleg ssn initiator amt redeleg_amt;
      (* Illegal withdraw amount could be handled in procedure AdjustDeleg *)
      new_amt = builtin sub stake_amt redeleg_amt;
      minstake_tmp <- minstake;
      status = uint128_le minstake_tmp new_amt;
      ssn_option_tmp = Ssn status new_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
      ssnlist[ssn] := ssn_option_tmp;
      e = { _eventname: "Remove delegate from SSN"; ssn_addr: ssn; deleg_address: initiator; amt: redeleg_amt };
      event e;
      match active_status with
      | True =>
        (* If the original status is active, we can substract from totalstakeamt, otherwise dont do so *)
        DecreaseTotalStakeAmt redeleg_amt;
        event_decrease = { _eventname: "DecreaseTotalStakeAmt"; decreased_amt: redeleg_amt };
        event event_decrease;
        (* If ssn becomes inactive, we need to decrease the rest ones as well *)
        DecreaseTotalStakeAmtOnStatus new_amt status
      | False =>
        event_decrease = { _eventname: "SSNInactiveBefore" };
        event event_decrease
      end
    | None =>
      e = DelegDoesNotExistAtSSN;
      ThrowError e
    end
  | None =>
    e = SSNNotExist;
    ThrowError e
  end
end

procedure WithdrawalStakeAmt(initiator: ByStr20, ssn: ByStr20, withdraw_amount: Uint128)
  ssn_o <- ssnlist[ssn];
  deleg <- deposit_amt_deleg[initiator][ssn];
  match ssn_o with
  | Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
    match deleg with
    | Some amt =>
      AssertNoRewards ssn initiator rewards;
      AsseertNoBufferedDeposit ssn initiator;
      AdjustDeleg ssn initiator amt withdraw_amount;
      (* Illegal withdraw amount could be handled in procedure AdjustDeleg *)
      new_amt = builtin sub stake_amt withdraw_amount;
      minstake_tmp <- minstake;
      status = uint128_le minstake_tmp new_amt;
      ssn_option_tmp = Ssn status new_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
      ssnlist[ssn] := ssn_option_tmp;
      withdrawal_bnum <- & BLOCKNUMBER;
      withdraw_amt_o <- withdrawal_pending[initiator][withdrawal_bnum];
      withdraw_amt_pending = match withdraw_amt_o with
      | Some v => builtin add v withdraw_amount
      | None => withdraw_amount
      end;
      withdrawal_pending[initiator][withdrawal_bnum] := withdraw_amt_pending;
      e = { _eventname: "Deleg withdraw deposit"; ssn_addr: ssn; deleg_address: initiator; withdraw_amount: withdraw_amount };
      event e;
      match active_status with
      | True =>
        (* If the original status is active, we can substract from totalstakeamt, otherwise dont do so *)
        DecreaseTotalStakeAmt withdraw_amount;
        event_decrease = { _eventname: "DecreaseTotalStakeAmt"; decreased_amt: withdraw_amount };
        event event_decrease;
        (* If ssn becomes inactive, we need to decrease the rest as well *)
        DecreaseTotalStakeAmtOnStatus new_amt status
      | False =>
        event_decrease = { _eventname: "SSNInactiveBefore" };
        event event_decrease
      end
    | None =>
      e = DelegDoesNotExistAtSSN;
      ThrowError e
    end
  | None =>
    e = SSNNotExist;
    ThrowError e
  end
end

procedure IncreaseReward(deleg: ByStr20, reward: Uint128)
  exist_reward <- cycle_rewards_deleg;
  new_reward = builtin add exist_reward reward;
  cycle_rewards_deleg := new_reward
end

procedure CalcStakeRewards(tmp_arg: TmpArg)
  match tmp_arg with
  | TmpArg deleg ssn_operator reward_cycle =>
    last_reward_cycle = builtin sub reward_cycle uint32_one;
    last2_reward_cycle = sub_one_to_zero last_reward_cycle;
    cur_opt <- direct_deposit_deleg[deleg][ssn_operator][last_reward_cycle];
    buf_opt <- buff_deposit_deleg[deleg][ssn_operator][last2_reward_cycle];
    comb_opt = option_add cur_opt buf_opt;

    last_amt_o <- deleg_stake_per_cycle[deleg][ssn_operator][last_reward_cycle];
    last_amt = option_uint128_value last_amt_o;
    staking_and_rewards_per_cycle_for_ssn_opt <- stake_ssn_per_cycle[ssn_operator][reward_cycle];
    (* the rewards for this cycle also computed within this procedure, so we no long keep histric data *)
    delete deleg_stake_per_cycle[deleg][ssn_operator][last_reward_cycle];
    delete direct_deposit_deleg[deleg][ssn_operator][last_reward_cycle];
    delete buff_deposit_deleg[deleg][ssn_operator][last2_reward_cycle];

    staking_of_deleg = match comb_opt with
    | Some stake => builtin add last_amt stake
    | None => last_amt
    end;
    deleg_stake_per_cycle[deleg][ssn_operator][reward_cycle] := staking_of_deleg;
    
    
    match staking_and_rewards_per_cycle_for_ssn_opt with
    | Some (SSNCycleInfo total_staking total_rewards) =>
      reward_tmp = builtin mul total_rewards staking_of_deleg;
      reward = builtin div reward_tmp total_staking;
      IncreaseReward deleg reward
    | None =>
    end

  end
end

procedure MintCall(recipient: ByStr20, amount: Uint128)
  addr <- gziladdr;
  msg_to_gzil = {_tag: "Mint"; _recipient: addr; _amount: uint128_zero; 
                  recipient: recipient; amount: amount};
  msgs = one_msg msg_to_gzil;
  send msgs
end



procedure WithdrawalStakeRewards(deleg: ByStr20, ssn_operator: ByStr20)
  last_withdraw_cycle_deleg_m <- last_withdraw_cycle_deleg[deleg][ssn_operator];
  last_withdraw_cycle = option_uint32_value last_withdraw_cycle_deleg_m;
  lrc <- lastrewardcycle;

  m = builtin add last_withdraw_cycle uint32_one;
  n = builtin add lrc uint32_one;
  list_need_compute_rewards = iota m n;
  
  (* Combine deleg and ssn_operator with list_need_compute_rewards *)
  mapper = @list_map Uint32 TmpArg;
  f = fun (cycle: Uint32) => TmpArg deleg ssn_operator cycle;
  combined_args_list = mapper f list_need_compute_rewards;

  (* Calculate rewards *)
  cycle_rewards_deleg := uint128_zero;
  forall combined_args_list CalcStakeRewards;

  (* Send rewards out and mint gzil *)
  reward <- cycle_rewards_deleg;
  SendDelegRewards deleg reward;
  MintCall deleg reward;

  ssn_o <- ssnlist[ssn_operator];
  match ssn_o with
  | Some (Ssn active_status stake_amt total_rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
    rest_rewards = builtin sub total_rewards reward;
    ssn = Ssn active_status stake_amt rest_rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
    ssnlist[ssn_operator] := ssn
  | None => throw
  end;
  e = { _eventname: "WithdrawalStakeRewards"; rewards: reward};
  event e;
  last_withdraw_cycle_deleg[deleg][ssn_operator] := lrc;
  msg_to_delegator = {_tag : "WithdrawStakeRewardsSuccessCallBack"; _recipient : deleg; _amount : uint128_zero; 
  ssnaddr : ssn_operator; rewards : reward};
  msg = one_msg msg_to_delegator;
  send msg
end

procedure Delegate(ssnaddr: ByStr20, initiator: ByStr20, amount: Uint128)
  curval <- ssnlist[ssnaddr];
  match curval with
  | None =>
    e = SSNNotExist;
    ThrowError e
  | Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
    IsDelegstakeSufficient amount;
    lrc <- lastrewardcycle;
    (* The delegated stake can be accepted. *) 
    FillInDepositDelegAmt ssnaddr initiator amount;
    (* If it is the first time delegator delegates to a give SSN, then we need to fill last_withdraw_cycle_deleg with lastrewardcycle *)
    (* otherwise, the rewards calculation will start from cycle 1 which is wrong *)
    FillLastWithdrawCycle ssnaddr initiator;
    (* It is buffered if the SSN is active if not it is added to the stake_amount. *)
    match active_status with
    | True  =>
      last_buf_deposit_cycle_deleg[initiator][ssnaddr] := lrc;
      new_buff_amt  = builtin add amount buffdeposit;
      (* The SSN is active so add the delegated stake to the buffer *)
      ssn = Ssn bool_active stake_amt rewards name urlraw urlapi new_buff_amt comm comm_rewards rec_addr;
      ssnlist[ssnaddr] := ssn;
      (* record this to buffer deposit for deleg *)
      stake_amt_for_deleg_option  <- buff_deposit_deleg[initiator][ssnaddr][lrc];
      match stake_amt_for_deleg_option  with
      | Some stake_amt_for_deleg =>
        new_stake_amt_for_deleg = builtin add stake_amt_for_deleg amount;
        buff_deposit_deleg[initiator][ssnaddr][lrc] := new_stake_amt_for_deleg
      | None =>
        buff_deposit_deleg[initiator][ssnaddr][lrc] := amount
      end
    | False =>
      minstake_tmp <- minstake;
      (* The SSN is inactive so add the delegated stake to stake_amount *)
      new_stake_amt  = builtin add amount stake_amt;
      status = uint128_le minstake_tmp new_stake_amt;
      (* The SSN becomes active if the total stake after deposit is greater than the minimum required. *)
      ssn = Ssn status new_stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
      ssnlist[ssnaddr] := ssn;
      (* If ssn becomes active, then we need to increase totalstakeamount *)
      IncreaseTotalStakeAmtOnStatus new_stake_amt status;
      (* record this to direct deposit for deleg *)
      stake_amt_for_deleg_option  <- direct_deposit_deleg[initiator][ssnaddr][lrc];
      match stake_amt_for_deleg_option  with
      | Some stake_amt_for_deleg =>
        new_stake_amt_for_deleg = builtin add stake_amt_for_deleg amount;
        direct_deposit_deleg[initiator][ssnaddr][lrc] := new_stake_amt_for_deleg
      | None =>
        direct_deposit_deleg[initiator][ssnaddr][lrc] := amount
      end
    end
  end  
end

(***************************************************)
(*                  Transition                     *)
(***************************************************)

(***************************************************)
(*            House keeping transition             *)
(***************************************************)

(* @dev: pause the contract. Used by admin only. *)
(* @param initiator: The original caller who called the proxy. *)
transition Pause(initiator: ByStr20)
  IsProxy;
  IsAdmin initiator;
  paused := bool_active
end

(* @dev: unpause/unfreeze the contract. Used by admin only. *)
(* @param initiator: The original caller who called the proxy. *)
transition UnPause(initiator: ByStr20)
  IsProxy;
  IsAdmin initiator;
  paused := bool_inactive
end

(* @dev: Set the admin of the contract. Used by admin only. *)
(* @param admin: New admin value *)
(* @param initiator: The original caller who called the proxy. *)
transition UpdateAdmin(admin: ByStr20, initiator: ByStr20)
  IsProxy;
  IsAdmin initiator;
  contractadmin := admin
end

(* @dev: Set the verifier of the contract. Used by admin only. *)
(* @param verif: New verifier value *)
(* @param initiator: The original caller who called the proxy *)
transition UpdateVerifier(verif: ByStr20, initiator: ByStr20)
  IsProxy;
  IsAdmin initiator;
  newverifier = Some {ByStr20} verif;
  verifier := newverifier
end

(* @dev: Set the verifier receiving address of the contract. Used by admin only. *)
(* @param addr: New verifier receiving address *)
(* @param initiator: The original caller who called the proxy *)
transition UpdateVerifierRewardAddr(addr: ByStr20, initiator: ByStr20)
  IsProxy;
  IsAdmin initiator;
  newAddr = Some {ByStr20} addr;
  verifier_receiving_addr := newAddr
end

(* @dev: Set the staking parameters of contract. Used by admin only. *)
(* @param min_stake: New minstake value *)
(* @param min_deleg_stake: New mindelegstake value *)
(* @param initiator: The original caller who called the proxy *)
transition UpdateStakingParameters(min_stake: Uint128, min_deleg_stake: Uint128, max_comm_change_rate: Uint128, initiator: ByStr20)
  IsProxy;
  IsAdmin initiator;
  minstake := min_stake;
  mindelegstake := min_deleg_stake;
  maxcommchangerate := max_comm_change_rate
end

transition ChangeBNumReq(input_bnum_req: Uint128, initiator: ByStr20)
  IsProxy;
  IsAdmin initiator;
  bnum_req := input_bnum_req
end

transition UpdateGzilAddr(gzil_addr: ByStr20, initiator: ByStr20)
  IsProxy;
  IsAdmin initiator;
  gziladdr := gzil_addr
end

transition AddSSN(ssnaddr: ByStr20, name: String, urlraw: String, urlapi: String, comm: Uint128, initiator: ByStr20)
  IsProxy;
  IsAdmin initiator;
  already_exists <- exists ssnlist[ssnaddr];
  match already_exists with
  | True  =>
    e = SSNAlreadyExist;
    ThrowError e
  | False =>
    ValidateRate comm;
    status = bool_inactive;
    stake_amt = Uint128 0;
    rewards = Uint128 0;
    buff_deposit = Uint128 0;
    comm_rewards = Uint128 0;
    s = Ssn status stake_amt rewards name urlraw urlapi buff_deposit comm comm_rewards ssnaddr;
    ssnlist[ssnaddr] := s;
    lrc <- lastrewardcycle;
    comm_for_ssn[ssnaddr][lrc] := comm;
    e = { _eventname: "SSN added"; ssn_addr: ssnaddr };
    event e
  end
end

transition UpdateSSN(ssnaddr: ByStr20, new_name: String, new_urlraw: String, new_urlapi: String, initiator: ByStr20)
  IsProxy;
  IsAdmin initiator;
  ssn_o <- ssnlist[ssnaddr];
  match ssn_o with
  | Some (Ssn active_status staking_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
    ssn = Ssn active_status staking_amt deleg_reward new_name new_urlraw new_urlapi buffdeposit comm comm_rewards rec_addr;
    ssnlist[ssnaddr] := ssn;
    e = { _eventname: "UpdateSSN"; ssnaddr: ssnaddr; new_name: new_name; new_urlraw: new_urlraw; new_urlapi: new_urlapi; initiator: initiator };
    event e
  | None =>
    e = SSNNotExist;
    ThrowError e
  end
end

(***************************************************)
(*             SSN operator transition             *)
(***************************************************)

(* @dev : To update the commision rate for a given SSN *)
(* @param new_rate: The new commision rate *)
(* @param initiator: The original caller who called the proxy *)
(* If the percentage is 5.2%, then, the value of this field will be 5.2 x 10^7 represented as an integer *)
(* The max rate is 100%, so the max new rate will be 100 x 10^7 which is 10^9 *)
transition UpdateComm(new_rate: Uint128, initiator: ByStr20)
  IsNotPaused;
  IsProxy;
  curval <- ssnlist[initiator];
  match curval with
  | Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
    lrc <- lastrewardcycle;
    old_comm_option <- comm_for_ssn[initiator][lrc];
    match old_comm_option with
    | Some old_comm =>
      e = ChangeCommError;
      ThrowError e
    | None =>
      ValidateRate new_rate;
      ValidateChangeRate comm new_rate;
      comm_for_ssn[initiator][lrc] := new_rate;
      ssn =  Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit new_rate comm_rewards rec_addr;
      ssnlist[initiator] := ssn;
      e = { _eventname: "UpdateComm"; ssn_addr: initiator; new_rate: new_rate };
      event e
    end
  | None =>
    e = SSNNotExist;
    ThrowError e
  end
end

(* @dev: Withdraw comm. Can be called by a ssn operator. *)
(* @param initiator: The original caller who called the proxy *)
transition WithdrawComm(initiator: ByStr20)
  IsNotPaused;
  IsProxy;
  curval <- ssnlist[initiator];
  match curval with
  | None =>
    e = SSNNotExist;
    ThrowError e
  | Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
    has_comm = uint128_gt comm_rewards uint128_zero;
    match has_comm with
    | True =>
      e = { _eventname: "SSN withdraw reward"; ssn_addr: initiator; withdraw_comm: comm_rewards };
      event e;
      ssn = Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm uint128_zero rec_addr;
      ssnlist[initiator] := ssn;
      TransferFunds addfunds_tag comm_rewards rec_addr
    | False =>
      e = SSNNoComm;
      ThrowError e
    end
  end
end

(* @dev : To update the received address for a given SSN *)
(* @param new_addr: The new received address *)
(* @param initiator: The original caller who called the proxy. This is SSN address. *)
transition UpdateReceivingAddr(new_addr: ByStr20, initiator: ByStr20)
  IsNotPaused;
  IsProxy;
  curval <- ssnlist[initiator];
  match curval with
  | Some (Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
    ssn =  Ssn active_status stake_amt rewards name urlraw urlapi buffdeposit comm comm_rewards new_addr;
    ssnlist[initiator] := ssn;
    e = { _eventname: "UpdateReceivingAddr"; ssn_addr: initiator; new_addr: new_addr };
    event e
  | None =>
    e = SSNNotExist;
    ThrowError e
  end
end

(***************************************************)
(*                Delegator transition             *)
(***************************************************)

(* @dev : To delegate the stake to the contract. *)
(* @param ssnaddr: The address of the SSN to which the deleg wants to stake *)
(* @param initiator: The original caller who called the proxy aka the deleg. *)
transition DelegateStake(ssnaddr: ByStr20, initiator: ByStr20)
  IsNotPaused;
  IsProxy;
  (* Accept the deposit from SSN and add to contract balance. *)
  (* Transfer back to initiator if any of the validation failed *)
  accept; 
  amount = _amount;
  Delegate ssnaddr initiator amount;
  e = { _eventname: "DelegateStake"; ssn_addr: ssnaddr; delegator: initiator; amount: amount };
  event e;
  msg_to_delegator = {_tag : "DelegateStakeSuccessCallBack"; _recipient : initiator; _amount : uint128_zero; 
  ssnaddr : ssnaddr; amount : amount};
  msg = one_msg msg_to_delegator;
  send msg
end

(* @dev: Withdraw stake reward. Can be called by a deleg. *)
(* @param ssnaddr: The address of the SSN to which the deleg wants to stake *)
(* @param initiator: The original caller who called the proxy *)
transition WithdrawStakeRewards(ssnaddr: ByStr20, initiator: ByStr20)
  IsNotPaused;
  IsProxy;
  DelegExists ssnaddr initiator;
  WithdrawalStakeRewards initiator ssnaddr
end

(* @dev: Withdraw all amount owed by the contract. Used by delegs. *)
(* @param ssnaddr: Address of the SSN to which stake had been delegated. *)
(* @param amt: The amount which the delegators wanr to withdraw*)
(* @param initiator: The original caller who called the proxy. *)
transition WithdrawStakeAmt(ssnaddr: ByStr20, amt: Uint128, initiator: ByStr20)
  IsNotPaused;
  IsProxy;
  WithdrawalStakeAmt initiator ssnaddr amt;
  msg_to_delegator = {_tag : "WithdrawStakeAmtSuccessCallBack"; _recipient : initiator; _amount : uint128_zero; 
  ssnaddr : ssnaddr; amount : amt};
  msg = one_msg msg_to_delegator;
  send msg
end

transition CompleteWithdrawal(initiator: ByStr20)
  IsNotPaused;
  IsProxy;
  withdraw_map_o <- withdrawal_pending[initiator];
  match withdraw_map_o with
  | Some withdraw_map =>
    withdraw_list = builtin to_list withdraw_map;
    (* To init tmp fields *)
    withdrawal_zero = uint128_zero;
    available_withdrawal := withdrawal_zero;
    c = Some {ByStr20} initiator;
    current_deleg := c;

    (* Calculate withdrawal that can be transferred *)
    forall withdraw_list CalculateTotalWithdrawal;
    withdraw_amt <- available_withdrawal;
    transfer = builtin eq withdraw_amt uint128_zero;
    match transfer with
    | True =>
      e = { _eventname: "NoUnbondedStake"; ssnaddr: initiator };
      event e;
      msg_to_delegator = {_tag : "CompleteWithdrawalNoUnbondedStakeCallBack"; _recipient : initiator; _amount : uint128_zero; 
      amount : uint128_zero};
      msg = one_msg msg_to_delegator;
      send msg
    | False =>
      e = { _eventname: "CompleteWithdrawal"; ssnaddr: initiator; amount: withdraw_amt };
      event e;
      TransferFunds addfunds_tag withdraw_amt initiator;
      msg_to_delegator = {_tag : "CompleteWithdrawalSuccessCallBack"; _recipient : initiator; _amount : uint128_zero; 
      amount : withdraw_amt};
      msg = one_msg msg_to_delegator;
      send msg
    end
  | None =>
    e = { _eventname: "NoPendingWithdrawal"; ssnaddr: initiator };
    event e
  end
end

transition ReDelegateStake(ssnaddr: ByStr20, to_ssn: ByStr20, amount: Uint128, initiator: ByStr20)
  IsNotPaused;
  IsProxy;
  same_ssn = builtin eq ssnaddr to_ssn;
  match same_ssn with
  | True =>
    e = ReDelegInvalidSSNAddr;
    ThrowError e
  | False =>
    UnDelegateStakeAmt initiator ssnaddr amount;
    Delegate to_ssn initiator amount;
    e = { _eventname: "ReDelegateStakeSuccess"; ssnaddr: ssnaddr; to_ssn: to_ssn; delegator: initiator; delegate_amount: amount };
    event e;
    msg_to_delegator = {_tag : "ReDelegateStakeSuccessCallBack"; _recipient : initiator; _amount : uint128_zero; 
    ssnaddr: ssnaddr; tossn: to_ssn; amount : amount};
    msg = one_msg msg_to_delegator;
    send msg
  end
  
end

(***************************************************)
(*                 Verifier transition             *)
(***************************************************)

(* @dev: Assign stake reward to all ssn from ssnlist. Used by verifier only. *)
(* @param ssnrewardlist: List of SsnRewardShare *)
(* @param initiator: The original caller who called the proxy *)
transition AssignStakeReward(ssnreward_list: List SsnRewardShare, initiator: ByStr20)
  IsNotPaused;
  IsProxy;
  CallerIsVerifier initiator;
  lrc <- lastrewardcycle;
  accept;
  newLastRewardCycleNum = builtin add uint32_one lrc;
  lastrewardcycle := newLastRewardCycleNum;
  (* _amount: total rewards for ssn operator, delegators and verifier *)
  verifier_reward := _amount;
  
  total_stake_amt <- totalstakeamount;
  f = map_to_stake_rewards total_stake_amt;

  mapper = @list_map SsnRewardShare SsnStakeRewardShare;
  ssn_stake_reward_list = mapper f ssnreward_list;
  forall ssn_stake_reward_list UpdateStakeReward;
  verifier_reward_amt <- verifier_reward;
  verifier_o <- verifier_receiving_addr;
  match verifier_o with
  | Some v => 
    is_zero = builtin eq verifier_reward_amt uint128_zero;
    match is_zero with
    | True =>
    | False =>
      TransferFunds addfunds_tag verifier_reward_amt v
    end
  | None =>
    e = VerifierRecvAddrNotSet;
    ThrowError e
  end

end

(***************************************************)
(*                  Generic transition             *)
(***************************************************)

(* @dev: Move funds from initiator to recipient, i.e., contract address. *)
(* @param initiator: The original caller who called the proxy. *)
transition AddFunds(initiator: ByStr20)
  IsProxy;
  accept;
  e = { _eventname : "Funds deposit "; funder : initiator };
  event e
end

(***************************************************)
(*         Contract upgrade transition             *)
(***************************************************)

(* @dev   Adds new ssn to ssnlist. Used by admin only. *)
(* @param ssnaddr: Address of the ssn to be added *)
(* @param stake_amt: Stake amount of ssn *)
(* @param rewards: Rewards of the ssn to be added *)
(* @param name: Human readable name *)
(* @param urlraw: string representing "ip:port" of the ssn serving raw api request *)
(* @param urlapi: string representing url exposed by ssn serving public api request *)
(* @param buffered_deposit: Any buffered stake deposit *)
(* @param comm: Percentage of incoming rewards that the SSN takes *)
(* @param comm_rewards: Number of ZILs earned as comm *)
(* @param min_delegate_amt: Minimum nb. of ZILs required for delegation *)
(* @param rec_addr: Address that will be used to receive comm *)
(* @param initiator: The original caller who called the proxy *)
transition AddSSNAfterUpgrade(ssnaddr: ByStr20, stake_amt: Uint128, rewards: Uint128, name: String, urlraw: String, urlapi: String, buff_deposit: Uint128,  comm: Uint128, comm_rewards: Uint128, rec_addr: ByStr20, initiator: ByStr20)
  IsProxy;
  IsAdmin initiator;
  already_exists <- exists ssnlist[ssnaddr];
  match already_exists with
  | True  =>
    e = { _eventname: "SSN already exists"; ssn_addr: ssnaddr };
    event e
  | False =>
    minstake_tmp <- minstake;
    status = uint128_le minstake_tmp stake_amt;
    s = Ssn status stake_amt rewards name urlraw urlapi buff_deposit comm comm_rewards rec_addr;
    ssnlist[ssnaddr] := s;
    lrc <- lastrewardcycle;
    comm_for_ssn[ssnaddr][lrc] := comm;
    e = { _eventname: "SSN added"; ssn_addr: ssnaddr };
    event e
  end
end

(* @dev: Adds or deletes a new deleg. Used by admin only during contract upgrade. *)
(* @param ssnaddr: Address of the ssn *)
(* @param deleg: Address of the deleg *)
(* @param stake_amt: Stake amount *)
(* @param initiator: The original caller who called the proxy *)
(* Its very crucial that after this operation, we should recovery direct and buffered map, as well as *)
(* lastrewardcycle last_withdraw_cycle_deleg last_buf_deposit_cycle_deleg totalstakeamount *)
transition UpdateDeleg(ssnaddr: ByStr20, deleg: ByStr20, stake_amt: Uint128, initiator: ByStr20)
  IsProxy;
  IsAdmin initiator;
  ssn_o <- ssnlist[ssnaddr];
  minstake_tmp <- minstake;
  match ssn_o with
  | Some (Ssn active_status staking_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards rec_addr) =>
    is_delete = builtin eq stake_amt uint128_zero;
    match is_delete with
    | True =>
      alr_deleg_amt_o <- deposit_amt_deleg[deleg][ssnaddr];
      match alr_deleg_amt_o with
      | Some alr_deleg =>
        TruncateDeleg deleg ssnaddr;
        new_stake_amt = builtin sub staking_amt alr_deleg;
        status = uint128_le minstake_tmp new_stake_amt;
        ssn = Ssn status new_stake_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
        ssnlist[ssnaddr] := ssn;
        e = { _eventname: "Deleg deleted"; ssn_addr: ssnaddr; deleg_address: deleg };
        event e;
        TransferFunds addfunds_tag alr_deleg deleg 
      | None =>
      end
    | False =>
      FillInDepositDelegAmt ssnaddr deleg stake_amt;
      new_stake_amt = builtin add stake_amt staking_amt;
      status = uint128_le minstake_tmp new_stake_amt;
      ssn = Ssn status new_stake_amt deleg_reward name urlraw urlapi buffdeposit comm comm_rewards rec_addr;
      ssnlist[ssnaddr] := ssn;
      e = { _eventname: "Deleg added"; ssn_addr: ssnaddr; deleg_address: deleg };
      event e
    end
  | None =>
    e = SSNNotExist;
    ThrowError e
  end
end

transition PopulateStakeSSNPerCycle(ssn_addr: ByStr20, cycle: Uint32, info: SSNCycleInfo, initiator: ByStr20)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  stake_ssn_per_cycle[ssn_addr][cycle] := info
end

transition PopulateLastWithdrawCycleForDeleg(deleg_addr: ByStr20, ssn_addr: ByStr20, cycle: Uint32, initiator: ByStr20)
  IsPaused;  
  IsProxy;
  IsAdmin initiator;
  last_withdraw_cycle_deleg[deleg_addr][ssn_addr] := cycle
end

transition PopulateBuffDeposit(deleg_addr: ByStr20, ssn_addr: ByStr20, cycle: Uint32, amt: Uint128, initiator: ByStr20)
  IsPaused;  
  IsProxy;
  IsAdmin initiator;
  buff_deposit_deleg[deleg_addr][ssn_addr][cycle] := amt
end

transition PopulateDirectDeposit(deleg_addr: ByStr20, ssn_addr: ByStr20, cycle: Uint32, amt: Uint128, initiator: ByStr20)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  direct_deposit_deleg[deleg_addr][ssn_addr][cycle] := amt
end

transition PopulateCommForSSN(ssn_addr: ByStr20, cycle: Uint32, comm: Uint128, initiator: ByStr20)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  comm_for_ssn[ssn_addr][cycle] := comm
end

transition PopulateTotalStakeAmt(amt: Uint128, initiator: ByStr20)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  totalstakeamount := amt
end

(* @dev:  Drain the contract's balance. Used by current admin only *)
(*        in event of contract upgrade or emergency. *)
(* @param initiator: The original caller who called the proxy *)
(* @param amt: The amount (Qa) to be drained from the contract back to the admin address *)
transition DrainContractBalance(amt: Uint128, initiator: ByStr20)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  bal <- _balance;
  less_than = builtin lt bal amt;
  match less_than with
  | True => throw
  | False =>
    TransferFunds addfunds_tag amt initiator
  end
end
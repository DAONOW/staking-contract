scilla_version 0
import ListUtils IntUtils
library SSNList
(* A non-custodial staking contract with admin privileges *)
(* SSN Data Type *)
(* Each SSN has the following fields: *)

(* ActiveStatus      : Bool *)
(*                     Represents whether the SSN has the minnimum stake amount and therefore ready to participate in staking and receive rewards. *)
(* StakeAmount       : Uint128 *)
(*                     Total stake that can be used for reward calculation. *)
(* StakeRewards      : Uint128 *)
(*                     (Unwithdrawn) Reward accumulated so far across all cycles. It only includes the reward that the SSN can distribute to its delegs. *)
(*                     It does not include SSN's own comm. *)
(* Name              : String *)
(*                     A human-readable name for this SSN. *)
(* URLRaw            : String *)
(*                     Represents "ip:port" of the SSN serving raw API requests. *)
(* URLApi            : String *)
(*                     Representing URL exposed by SSN serving public API requests. *)
(* BufferedDeposit   : Uint128 *)
(*                     Stake deposit that cannot be counted as a part of reward calculation for the ongoing reward cycle. But, to be considered *)
(*                     for the next one. *)
(* Commission        : Uint128 *)
(*                     Percentage of incoming rewards that the SSN takes. *)
(* CommissionRewards : Uint128 *)
(*                     Number of ZILs earned as comm by the SSN. *)
(* ReceivedAddress   : ByStr20 *)
(*                     Address will be used to receive comm. *)
(* Invariant 1: StakeAmount + BufferedDeposit < MaxStake < ContractMaxStake *)
(* Invariant 2: ActiveStatus = (Minstake < StakeAmount)  *)
type Ssn =
| Ssn of Bool Uint128 Uint128 String String String Uint128 Uint128 Uint128 ByStr20
(* SSNRewardShare Data Type *)
(* SSNRewardShare has the following fields: *)

(*  SSNAddress        : ByStr20 *)
(*                      Address of the SSN. *)
(*  RewardPercentage  : Uint128 *)
(*                      This is the integer representation of the percentage of the staked amount that will be given as reward to the SSN. *)
(*                      If the percentage is 5.2%, then, the value of this field will be 5.2 x 10^7 represented as an integer. *)
(*                      If the percentage is 10%, and the SSN has a stake of 100 ZILs, then the reward in ZILs will be 10% of 100 = 10 ZILs. *)
type SsnRewardShare =
| SsnRewardShare of ByStr20 Uint128
(* Deleg Data Type *)
(* Each deleg has the following fields: *)

(* StakeAmount       : Uint128 *)
(*                     Represents the amount staked so far. This is the sum total of amount staked across all SSNs. *)

type Deleg =
| Deleg of Uint128
(* DelegCycleInfo Data Type *)

(*    Each DelegCycleInfo has the following fields: *)
(*    SSNAddress          : ByStr20 *)
(*                          Address of the SSN. *)
(*    StakeDuringTheCycle : Uint128 *)
(*                          Represents the amount staked during this cycle for the given SSN. *)
(*    DelegAddress    : ByStr20 *)
(*                      Address of Deleg. *)
type DelegCycleInfo =
| DelegCycleInfo of ByStr20 Uint128 ByStr20
(* SSNCycleInfo Data Type *)

(*   Each SSNCycleInfo has the following fields: *)
(*    TotalStakeDuringTheCycle            : Uint128 *)
(*                                          Represents the amount staked during this cycle for the given SSN. *)
(*    TotalRewardEarnedDuringTheCycle    : Uint128 *)
(*                                         Represents the amount staked during this cycle for the given SSN. *)
type SSNCycleInfo =
| SSNCycleInfo of Uint128 Uint128
(* DelegAndRewards Data Type *)
(*   Each DelegAndRewards has the following fields: *)
(*   DelegAddress    : ByStr20 *)
(*                     Address of Deleg. *)
(*   RewardToBeSent  : Uint128 *)
(*                     Reward that can be sent to the deleg. *)
type DelegAndRewards =
| DelegAndRewards of ByStr20 Uint128
let one_msg =
  fun (m : Message) =>
    let e = Nil {Message} in
    Cons {Message} m e
let uint128_one =  Uint128 1
let uint128_zero = Uint128 0
(* This function help us to tell if current block number need to be reward *)
let reward_filter =
  fun (lastrewardcycle : Uint128) =>
    fun (current_pair : Pair Uint128 DelegCycleInfo) =>
        match current_pair with
        | Pair currentblock (DelegCycleInfo ssn block deleg) =>
          builtin lt lastrewardcycle currentblock
      end
(* left < element <= right *)
(* This function is used for filting out those cycles that need to compute rewards for delegs *)
let list_between =
  fun (left : Uint128) =>
    fun (right : Uint128) =>
      fun (element : Uint128) =>
        let res = builtin lt left element in
        match res with
        | True =>
          let res = builtin lt right element in
          match res with
          | True => False
          | False => True
          end
        | False => False
        end
(* This function is used for calculating the exact staking amount per cycle for delegs *)
(* Example: *)
(* Input: [1:1000,2:2000,3:3000] *)
(* [1:1000] => [1:1000,2:2000+1000] => [1:1000,2:3000,3:3000+3000] *)
let caculate_all_stake_per_cycle =
  fun (delegate_map : Map Uint128 Uint128) =>
    fun (result_map : Map Uint128 Uint128) =>
      fun(k : Uint128) =>
        let m = builtin sub k uint128_one in
        let result_map_o = builtin get result_map m in
        let delegate_map_o = builtin get delegate_map k in
        match result_map_o with
        | Some last_amount =>
          match delegate_map_o with
          | Some delegate_amount =>
            let amount = builtin add last_amount delegate_amount in
            builtin put result_map k amount
          | None =>
            builtin put result_map k last_amount
          end
        | None =>
          match delegate_map_o with
          | Some delegate_amount =>
            builtin put result_map k delegate_amount
          | None =>  result_map
          end
        end
(* This function is used for combining direct deposit and buffered deposit into one with correct secquence *)
(* Example: *)
(* Direct deposit: [1:1000,2:2000:3:3000] *)
(* Buffered deposit: [1:1000,2:2000:3:3000]*)
(* Result deposit: [1:1000,2:2000+1000:3:3000+2000] *)
let combine_buffered_and_direct =
  fun (direct : Map Uint128 Uint128) =>
    fun (buffered : Map Uint128 Uint128) =>
      fun(result : Map Uint128 Uint128) =>
        fun(k : Uint128) =>
          let m = builtin sub k uint128_one in
           (* if it takes effect from this cycle, then it must be deposited in last cycle *)
          let direct_o = builtin get direct k in
          let buffered_o = builtin get buffered m in
          match direct_o with
          | Some direct_amount =>
            match buffered_o with
            | Some buffered_amount =>
              let amount = builtin add direct_amount buffered_amount in
              builtin put result k amount
            | None =>
              builtin put result k direct_amount
            end
          | None =>
            match buffered_o with
            | Some buffered_amount =>
              builtin put result k buffered_amount
            | None =>
              result
            end
          end
let calculate_rewards_per_cycle_for_deleg =
  fun (deleg : ByStr20) =>
  fun (staking_per_cycle_for_deleg : Map Uint128 Uint128) =>
    fun (staking_and_rewards_per_cycle_for_ssn : Map Uint128 SSNCycleInfo) =>
      (* record rewards should be sent per cycle for deleg *)
      fun (result_map : Map Uint128 DelegAndRewards) =>
        fun (cycle : Uint128) =>
          let staking_per_cycle_for_deleg_o = builtin get staking_per_cycle_for_deleg cycle in
          let staking_and_rewards_per_cycle_for_ssn_o = builtin get staking_and_rewards_per_cycle_for_ssn cycle in
          match staking_per_cycle_for_deleg_o with
          | Some staking_of_deleg =>
            match staking_and_rewards_per_cycle_for_ssn_o with
            | Some staking_and_rewards_of_ssn_adt =>
              match staking_and_rewards_of_ssn_adt with
              | SSNCycleInfo total_staking total_rewards =>
                let reward_tmp = builtin mul total_rewards staking_of_deleg in
                let reward_tmp = builtin div reward_tmp total_staking in
                let deleg_and_rewards = DelegAndRewards deleg reward_tmp in
                builtin put result_map cycle deleg_and_rewards
              end
            | None => result_map
            end
          | None => result_map
          end
  let deposit_value_or_empty =
    fun (optional_value : Option (Map Uint128 Uint128)) =>
      match optional_value with
      | Some value => value
      | None =>  Emp Uint128 Uint128
      end
  let block_or_zero =
    fun (optional_value : Option Uint128) =>
      match optional_value with
      | Some value => value
      | None => uint128_zero
      end
let bool_active = True
let bool_inactive = False
let uint128_10_power_7 = Uint128 10000000
let empty_tag = ""
let multisig_tag_addfunds = "AddFunds"
type Error =
  | ContractFreezedFailure
  | VerifierValidationFailed
  | AdminValidationFailed
  | ProxyValidationFailed
  | DelegDoesNotExistAtSSN
  | DelegDepositBlowMin
  | UpdateStakingParamError
  | DelegHasBufferedDeposit
  | ChangeCommissionError
  | SSNNotExist
  | DelegNotExist
let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | ContractFreezedFailure => Int32 -1
      | VerifierValidationFailed => Int32 -2
      | AdminValidationFailed => Int32 -3
      | ProxyValidationFailed => Int32 -4
      | DelegDoesNotExistAtSSN => Int32 -5
      | DelegDepositBlowMin => Int32 -6
      | UpdateStakingParamError => Int32 -7
      | DelegHasBufferedDeposit => Int32 -8
      | ChangeCommissionError => Int32 -9
      | SSNNotExist => Int32 -10
      | DelegNotExist => Int32 -11
      end
    in
    { _exception : "Error"; code : result_code }
(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract SSNList(
  init_admin : ByStr20,
  proxy_address : ByStr20
)
(* Keeps track of SSNS *)
(* AddressOfSSN -> SSNInfo *)
field ssnlist : Map ByStr20 Ssn = Emp ByStr20 Ssn
(* Keeps track of the delegs for each SSN.*)
(* AddressOfSSN -> (AddressOfDeleg -> DelegInfo) *)
field delegs : Map ByStr20 (Map ByStr20 Deleg) = Emp ByStr20 (Map ByStr20 Deleg)
(* Keeps track of stakes deposited at SSNs *)
(* AddressOfSSN -> (RewardCycleNumber -> Pair (TotalStakeDuringTheCycleForSSN, TotalRewardEarnedDuringTheCycle) *)
field stake_ssn_per_cycle : Map ByStr20 (Map Uint128 SSNCycleInfo) = Emp ByStr20 (Map Uint128 SSNCycleInfo)
(* Keeps track of the cycle number when a deleg last withdrew its rewards *)
(* AddressOfDeleg -> ( AddressOfSSN -> CycleNumberWhenLastWithdrawn) *)
field last_withdraw_cycle_deleg : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
(* Keeps track of buffered deposit for a deleg *)
(* AddressOfDeleg -> (AddressofSSN -> (RewardCycleNumber -> BufferedStakeAmountDuringTheCycle)) *)
(* The BufferedStakeAmount will only be truely delegated at next cycle *)
field buffered_deposit_deleg : Map ByStr20 (Map ByStr20 (Map Uint128 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint128 Uint128))
(* Keeps track of stake deposits for a deleator that can be considered for reward calcuation *)
(* AddressofDeleg -> (AddressofSSN -> (RewardCycleNumber -> StakeAmount)) *)
field direct_deposit_deleg : Map ByStr20 (Map ByStr20 (Map Uint128 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint128 Uint128))
(* Record deposit amount for every deleg for every ssn *)
(* AddressofDeleg -> (AddressofSSN -> StakeAmount) *)
field deposit_amount_deleg : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
(* Record comm for ssn of every cycle*)
(* AddressofSSN -> (Cycle -> comm ) *)
field comm_for_ssn : Map ByStr20 (Map Uint128 Uint128) = Emp ByStr20 (Map Uint128 Uint128)
field reward_cycle_list : List Uint128   =  Nil {Uint128}
field verifier : Option ByStr20 = None {ByStr20}
field minstake : Uint128 = Uint128 0
field maxstake : Uint128 = Uint128 0
field contractmaxstake : Uint128 = Uint128 0
(* In case of contract upgrade, this field is indirectly updated when SSNs are added *)
field totalstakedeposit : Uint128 = Uint128 0
field contractadmin : ByStr20  = init_admin
field lastrewardcycle : Uint128 = Uint128 0
field paused : Bool = True
(* Procedures *)
(* Internal functions, used like Solidity modifiers *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end
(* Check if the initiator is verifier *)
procedure CallerIsVerifier (initiator : ByStr20)
  verifier_tmp <- verifier;
  match verifier_tmp with
  | Some v =>
    is_verifier = builtin eq initiator v;
    match is_verifier with
    | True =>
    | False =>
      e = VerifierValidationFailed;
      ThrowError e
    end
  | None =>
    e = AdminValidationFailed;
    ThrowError e
  end
end
(* Check if the initiator is admin *)
procedure IsAdmin(initiator : ByStr20)
  contractadmin_tmp <- contractadmin;
  is_admin = builtin eq initiator contractadmin_tmp;
  match is_admin with
  | True  =>
  | False =>
    e = AdminValidationFailed;
    ThrowError e
  end
end
(* Check if the caller is the proxy *)
procedure IsProxy()
  is_proxy = builtin eq _sender proxy_address;
  match is_proxy with
  | True  =>
  | False =>
    e = ProxyValidationFailed;
    ThrowError e
  end
end
(* Check if the contract is paused *)
procedure IsPaused()
  paused_tmp <- paused;
  match paused_tmp with
  | False =>
  | True  =>
    e = ContractFreezedFailure;
    ThrowError e
  end
end
(* Can be called by the contract admin only *)
(* It is expected that transfer only happens to an exterally owned account*)
procedure TransferFunds(tag: String, amount : Uint128, recipient : ByStr20)
    msg = {_tag : tag; _recipient : recipient; _amount : amount};
    msgs = one_msg msg;
    send msgs
end
procedure UpdateStakeReward(entry : SsnRewardShare)
  lastreward_block <- lastrewardcycle;
  match entry with
  | SsnRewardShare ssnaddr reward_percent =>
    curval <- ssnlist[ssnaddr];
    match curval with
    | None =>
      e = SSNNotExist;
      ThrowError e
    | Some (Ssn active_status stake_amount rewards name urlraw urlapi buffdeposit comm comm_rewards received_address) =>
      match active_status with
      | False => throw
      | True  =>
        hundred = Uint128 100;
        new_reward = builtin mul stake_amount reward_percent;
        new_reward = builtin div new_reward hundred;
        new_reward = builtin div new_reward uint128_10_power_7;
        reward_comm_tmp = builtin mul new_reward comm;
        reward_comm_tmp = builtin div reward_comm_tmp hundred;
        reward_comm_tmp = builtin div reward_comm_tmp uint128_10_power_7;
        total_reward_comm = builtin add reward_comm_tmp comm_rewards;
        expected_reward = builtin sub new_reward total_reward_comm;
        deleg_reward = builtin add expected_reward rewards;
        new_stake_amount = builtin add stake_amount buffdeposit;
        (* During this cylce, the SSN only earned t as rewards that could be given to delegs *)
        p = SSNCycleInfo stake_amount expected_reward;
        stake_ssn_per_cycle[ssnaddr][lastreward_block] := p;
        ssn = Ssn active_status new_stake_amount deleg_reward name urlraw urlapi uint128_zero comm total_reward_comm received_address;
        ssnlist[ssnaddr] := ssn;
        e = { _eventname : "SSN assign reward"; ssn_address : ssnaddr; total_reward : total_reward_comm };
        event e
      end
    end
  end
end
(* this procedure is to send rewards to deleg for every reward cycle *)
procedure SendDelegRewards(entry : Pair Uint128 DelegAndRewards)
  match entry with
  | Pair cycle deleg_and_rewards  =>
    match deleg_and_rewards with
    | DelegAndRewards address amount =>
      TransferFunds multisig_tag_addfunds amount address;
      e = { _eventname : "Send deleg rewards event"; address : address; amount :  amount};
      event e
    end
  end
end
(* Check if a delegs exists for a given SSN *)
procedure DelegExists(ssnaddr: ByStr20, deleg: ByStr20)
  if_exists <- exists delegs[ssnaddr][deleg];
  match if_exists with
  | True  =>
  | False =>
    e = DelegDoesNotExistAtSSN;
    ThrowError e
    end
end
procedure FillInDelegAmount(ssnaddr: ByStr20, deleg : ByStr20)
  deposit_amount <- deposit_amount_deleg[deleg][ssnaddr];
  match deposit_amount with
  | Some amount =>
    new_amount = builtin add amount _amount;
    deposit_amount_deleg[deleg][ssnaddr] := new_amount
  | None =>
    deposit_amount_deleg[deleg][ssnaddr] := _amount
  end
end
procedure FillInDelegs(ssnaddr : ByStr20, deleg : ByStr20)
  d <- delegs[ssnaddr][deleg];
  match d with
  | Some (Deleg amount) =>
    new_amount_deleg = builtin add _amount amount;
    d_new = Deleg new_amount_deleg;
    delegs[ssnaddr][deleg] := d_new
  | None =>
    d_new = Deleg _amount;
    delegs[ssnaddr][deleg] := d_new
  end
end
procedure HasRewardToWithdraw(ssnaddr : ByStr20, deleg : ByStr20)
  last_reward_cycle_deleg_tmp <- last_withdraw_cycle_deleg[deleg][ssnaddr];
  last_reward_cycle_deleg = block_or_zero last_reward_cycle_deleg_tmp;
  last_reward_cycle <- lastrewardcycle;
  has_reward = builtin lt last_reward_cycle_deleg last_reward_cycle;
  match has_reward with
  | True =>
    throw
  | False =>
  end
end
procedure DistributeStakeAmount(initiator: ByStr20, ssn: ByStr20)
  deleg <- delegs[ssn][initiator];
  last_reward_cycle <- lastrewardcycle;
  ssn_option <- ssnlist[ssn];
  match deleg with
  | Some (Deleg amount) =>
    (* first we need to make sure there is no deposit within buffered stake *)
    has_buffered_value <- buffered_deposit_deleg[initiator][ssn][last_reward_cycle];
    match has_buffered_value with
    | Some value => throw
    | None =>
      HasRewardToWithdraw ssn initiator;
      deposit_amount_option <- deposit_amount_deleg[initiator][ssn];
      match deposit_amount_option with
      | Some deposit_amount =>
        delete buffered_deposit_deleg[initiator][ssn];
        delete direct_deposit_deleg[initiator][ssn];
        delete deposit_amount_deleg[initiator][ssn];
        delete last_withdraw_cycle_deleg[initiator][ssn];
        match ssn_option with
        | Some (Ssn active_status stake_amount rewards name urlraw urlapi buffdeposit comm commision_rewards received_address) =>
          new_amount = builtin sub stake_amount deposit_amount;
          minstake_tmp <- minstake;
          status = builtin lt minstake_tmp new_amount;
          ssn_option = Ssn status new_amount rewards name urlraw urlapi buffdeposit comm commision_rewards received_address;
          ssnlist[ssn] := ssn_option;
          new_amount_for_deleg = builtin sub amount deposit_amount;
          deleg_option = Deleg new_amount_for_deleg;
          delegs[ssn][initiator] := deleg_option;
          TransferFunds multisig_tag_addfunds deposit_amount initiator;
          e = { _eventname : "Deleg withdraw deposit"; ssn_address : ssn; deleg_address : initiator; deposit_amount : deposit_amount };
          event e
        | None =>
          e = DelegHasBufferedDeposit;
          ThrowError e
        end
      | None =>
        e = SSNNotExist;
        ThrowError e
      end
    end
  | None =>
    e = DelegDoesNotExistAtSSN;
    ThrowError e
  end
end
procedure DistributeStakeRewards(deleg: ByStr20, ssn_operator: ByStr20)
  last_withdraw_cycle_deleg_m <- last_withdraw_cycle_deleg[deleg][ssn_operator];
  last_withdraw_cycle = block_or_zero last_withdraw_cycle_deleg_m;
  last_reward_cycle <- lastrewardcycle;
  reward_cycle_list <- reward_cycle_list;
  list_between_fun = list_between last_withdraw_cycle last_reward_cycle;
  list_between_fun_uint128 = @list_filter Uint128;
  (* those are the cycles that we want to compute for computing rewards *)
  list_need_compute_rewards = list_between_fun_uint128 list_between_fun reward_cycle_list;
  (* direct deposit *)
  direct_deposit_deleg_m <- direct_deposit_deleg[deleg][ssn_operator];
  direct_deposits_for_deleg = deposit_value_or_empty direct_deposit_deleg_m;
  (* buffered deposit *)
  buffered_deposit_deleg_m <- buffered_deposit_deleg[deleg][ssn_operator];
  buffered_deposits_for_deleg = deposit_value_or_empty buffered_deposit_deleg_m;
  (* combine two deposit list *)
  init_map = Emp Uint128 Uint128;
  foldl = @list_foldl Uint128 Map Uint128 Uint128;
  staking_init_map = Emp Uint128 Uint128;
  iter = combine_buffered_and_direct direct_deposits_for_deleg buffered_deposits_for_deleg;
  combined_direct_and_buffered_map = foldl iter init_map list_need_compute_rewards;
  (* to calculate final staking per cycle for delegs *)
  iter = caculate_all_stake_per_cycle combined_direct_and_buffered_map;
  stake_deleg_per_cycle = foldl iter staking_init_map list_need_compute_rewards;
  stake_ssn_per_cycle_m <- stake_ssn_per_cycle[ssn_operator];
  match stake_ssn_per_cycle_m with
  | Some stake_ssn_per_cycle =>
    (* to calculate staking rewards per cycle for deleg *)
    reward_per_cycle_for_deleg_init = Emp Uint128 DelegAndRewards;
    foldl_a = @list_foldl Uint128 Map Uint128 DelegAndRewards;
    calculate_rewards_per_cycle_for_deleg_iter = calculate_rewards_per_cycle_for_deleg deleg stake_deleg_per_cycle stake_ssn_per_cycle;
    rewards_deleg_per_cycle = foldl_a calculate_rewards_per_cycle_for_deleg_iter reward_per_cycle_for_deleg_init list_need_compute_rewards;
    (* to send those rewards and update last withdraw cycle of deleg *)
    rewards_deleg_per_cycle_list = builtin to_list rewards_deleg_per_cycle;
    forall rewards_deleg_per_cycle_list SendDelegRewards;
    last_withdraw_cycle_deleg[deleg][ssn_operator] := last_reward_cycle;
    e = { _eventname : "Deleg update cycle"; ssn_address : ssn_operator; deleg_address : deleg };
    event e
  | None => (* ssn has no rewards *)
  end
end
(* Transitions *)
(* @dev: pause the contract. Used by admin only. *)
(* @param initiator: The original caller who called the proxy. *)
transition Pause(initiator : ByStr20)
  IsProxy;
  IsAdmin initiator;
  paused := bool_active
end
(* @dev: unpause/unfreeze the contract. Used by admin only. *)
(* @param initiator: The original caller who called the proxy. *)
transition UnPause(initiator : ByStr20)
  IsProxy;
  IsAdmin initiator;
  paused := bool_inactive
end
(* @dev: Set the admin of the contract. Used by admin only. *)
(* @param admin: New admin value *)
(* @param initiator: The original caller who called the proxy. *)
transition UpdateAdmin(admin : ByStr20, initiator : ByStr20)
  IsProxy;
  IsAdmin initiator;
  contractadmin := admin
end
(* @dev: Set the verifier of the contract. Used by admin only. *)
(* @param verif: New verifier value *)
(* @param initiator: The original caller who called the proxy *)
transition UpdateVerifier(verif : ByStr20, initiator : ByStr20)
  IsProxy;
  IsAdmin initiator;
  newverifier = Some {ByStr20} verif;
  verifier := newverifier
end
(* @dev: Drain the entire contract's balance. Used by current admin only in case of emergency. *)
(* @param initiator: The original caller who called the proxy *)
transition DrainContractBalance(initiator : ByStr20, amount : Uint128)
  IsProxy;
  IsAdmin initiator;
  bal <- _balance;
  less_than = builtin lt bal amount;
  match less_than with
  | True => throw
  | False =>
    TransferFunds multisig_tag_addfunds amount initiator
  end
end
(* @dev: Set the staking parameters of contract. Used by admin only. *)
(* @param min_stake: New minstake value *)
(* @param max_stake: New maxstake value *)
(* @param contract_max_stake: New contract maxstake value *)
(* @param initiator: The original caller who called the proxy *)
transition UpdateStakingParameters (min_stake : Uint128, max_stake : Uint128, contract_max_stake : Uint128, initiator : ByStr20)
  IsProxy;
  IsAdmin initiator;
  min_less_than_max = builtin lt min_stake max_stake;
  match min_less_than_max with
  | True =>
    max_less_than_contract_max = builtin lt max_stake contract_max_stake;
    match max_less_than_contract_max with
    | True =>
      minstake := min_stake;
      maxstake := max_stake;
      contractmaxstake := contract_max_stake;
      e = { _eventname : "Update staking parameter event"; sender : initiator};
      event e
    | False =>
      e = UpdateStakingParamError;
      ThrowError e
    end
  | False =>
     e = UpdateStakingParamError;
     ThrowError e
  end
end
(* @dev   Adds new ssn to ssnlist. Used by admin only. *)
(* @param ssnaddr: Address of the ssn to be added *)
(* @param stake_amount: Stake amount of ssn *)
(* @param rewards: Rewards of the ssn to be added *)
(* @param name: Human readable name *)
(* @param urlraw: string representing "ip:port" of the ssn serving raw api request *)
(* @param urlapi: string representing url exposed by ssn serving public api request *)
(* @param buffered_deposit: Any buffered stake deposit *)
(* @param comm: Percentage of incoming rewards that the SSN takes *)
(* @param comm_rewards: Number of ZILs earned as comm *)
(* @param min_delegate_amt: Minimum nb. of ZILs required for delegation *)
(* @param received_address: Address that will be used to receive comm *)
(* @param initiator: The original caller who called the proxy *)
transition AddSSN(ssnaddr : ByStr20, stake_amt : Uint128, rewards : Uint128, name : String, urlraw : String, urlapi : String, buff_deposit : Uint128,  comm : Uint128, comm_rewards : Uint128, min_delegate_amt : Uint128, received_addr : ByStr20, initiator : ByStr20)
  IsProxy;
  IsAdmin initiator;
  already_exists <- exists ssnlist[ssnaddr];
  match already_exists with
  | True  =>
    e = { _eventname : "SSN already exists"; ssn_address : ssnaddr };
    event e
  | False =>
    minstake_tmp <- minstake;
    maxstake_tmp <- maxstake;
    total_amt = builtin add stake_amt buff_deposit;
    pass = builtin lt maxstake_tmp total_amt;
    match pass with
    | True  =>
      e = { _eventname : "Stake deposit > max_stake"; ssn_address : ssnaddr; requested_deposit : stake_amt; max_stake : maxstake_tmp };
      event e
    | False =>
      status = builtin lt minstake_tmp stake_amt;
      (* Update the total stake deposit *)
      totalstakedeposit_tmp <- totalstakedeposit;
      totalstakedeposit_tmp = builtin add totalstakedeposit_tmp stake_amt;
      totalstakedeposit := totalstakedeposit_tmp;
      s = Ssn status stake_amt rewards name urlraw urlapi buff_deposit comm comm_rewards received_addr;
      ssnlist[ssnaddr] := s;
      last_reward_cycle <- lastrewardcycle;
      comm_for_ssn[ssnaddr][last_reward_cycle] := comm;
      e = { _eventname : "SSN added"; ssn_address : ssnaddr };
      event e
    end
  end
end
(* @dev: Adds a new deleg. Used by admin only during contract upgrade. *)
(* @param ssnaddr: Address of the ssn *)
(* @param deleg: Address of the deleg *)
(* @param stake_amount: Stake amount *)
(* @param rewards: Rewards of the ssn to be added *)
(* @param initiator: The original caller who called the proxy *)
(* TODO This could be expensive *)
(* TODO Missing check on the minimum stake amount *)
transition AddDeleg(ssnaddr : ByStr20, deleg : ByStr20, stake_amount : Uint128, initiator : ByStr20)
  IsProxy;
  IsAdmin initiator;
  alr_exists <- exists delegs[ssnaddr][deleg];
  match alr_exists with
  | True =>
    e = { _eventname : "Deleg exists"; ssn_address : ssnaddr; deleg_address : deleg };
    event e
  | False =>
    d = Deleg stake_amount;
    delegs[ssnaddr][deleg] := d;
    e = { _eventname : "Deleg added"; ssn_address : ssnaddr; deleg_address : deleg };
    event e
  end
end
(* @dev: Remove a specific ssn from ssnlist. Used by admin only. *)
(* @param ssnaddr: Address of the ssn to be removed *)
(* @param initiator: The original caller who called the proxy *)
transition RemoveSSN(ssnaddr : ByStr20, initiator : ByStr20)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  already_exists <- exists ssnlist[ssnaddr];
  match already_exists with
  | False =>
    e = SSNNotExist;
    ThrowError e
  | True =>
    delete ssnlist[ssnaddr];
    delete comm_for_ssn[ssnaddr];
    e = { _eventname : "SSN removed"; ssn_address : ssnaddr };
    event e
  end
end
(* @dev: Remove a specific deleg for a given SSN. Used by admin only. *)
(* @param ssnaddr: Address of the ssn *)
(* @param deleg: Address of the deleg to be removed *)
(* @param initiator: The original caller who called the proxy *)
transition RemoveDeleg(ssnaddr : ByStr20, deleg : ByStr20, initiator : ByStr20)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  already_exists <- exists delegs[ssnaddr][deleg];
  match already_exists with
  | False =>
    e = DelegNotExist;
    ThrowError e
  | True =>
    (* Refund SSN delegs *)
    DistributeStakeRewards deleg ssnaddr;
    DistributeStakeAmount deleg ssnaddr;
    delete delegs[ssnaddr][deleg];
    delete deposit_amount_deleg[deleg][ssnaddr];
    e = { _eventname : "Deleg removed"; ssn_address : ssnaddr; deleg_address : deleg};
    event e
  end
end

(* @dev : To update the commision rate for a given SSN *)
(* @param new_rate: The new commision rate *)
(* @param initiator: The original caller who called the proxy. This is SSN address. *)
transition UpdateCommission(new_rate : Uint128, initiator : ByStr20)
  IsPaused;
  IsProxy;
  curval <- ssnlist[initiator];
  match curval with
  | Some (Ssn active_status stake_amount rewards name urlraw urlapi buffdeposit comm commision_rewards received_address) =>
    last_reward_cycle <- lastrewardcycle;
    old_comm_option <- comm_for_ssn[initiator][last_reward_cycle];
    match old_comm_option with
    | Some old_comm =>
      e = ChangeCommissionError;
      ThrowError e
    | None =>
      comm_for_ssn[initiator][last_reward_cycle] := comm;
      ssn =  Ssn active_status stake_amount rewards name urlraw urlapi buffdeposit new_rate commision_rewards received_address;
      ssnlist[initiator] := ssn
    end
  | None =>
    e = SSNNotExist;
    ThrowError e
  end
end

(* @dev : To update the received address for a given SSN *)
(* @param new_addr: The new received address *)
(* @param initiator: The original caller who called the proxy. This is SSN address. *)
transition UpdateReceivedAddr(new_addr : ByStr20, initiator : ByStr20)
  IsPaused;
  IsProxy;
  curval <- ssnlist[initiator];
  match curval with
  | Some (Ssn active_status stake_amount rewards name urlraw urlapi buffdeposit comm commision_rewards received_addr) =>
    ssn =  Ssn active_status stake_amount rewards name urlraw urlapi buffdeposit comm commision_rewards new_addr;
    ssnlist[initiator] := ssn
  | None =>
    e = SSNNotExist;
    ThrowError e
  end
end

(* @dev : To delegate the stake to the contract. *)
(* @param ssnaddr: The address of the SSN to which the deleg wants to stake *)
(* @param initiator: The original caller who called the proxy aka the deleg. *)
transition DelegateStake(ssnaddr : ByStr20, initiator : ByStr20)
  IsPaused;
  IsProxy;
  (* Accept the deposit from SSN and add to contract balance. *)
  (* Transfer back to initiator if any of the validation failed *)
  accept;
  curval <- ssnlist[ssnaddr];
  match curval with
  | None =>
    e = SSNNotExist;
    ThrowError e
  | Some (Ssn active_status stake_amount rewards name urlraw urlapi buffdeposit comm commision_rewards received_address) =>
    minstake_tmp <- minstake;
    maxstake_tmp <- maxstake;
    new_buff_amount  = builtin add _amount buffdeposit;
    new_stake_amount = builtin add new_buff_amount stake_amount;
    pass = builtin lt maxstake_tmp new_stake_amount;
    match pass with
    | True  => (* stake deposit above maxstake limit for SSNs *)
      e = { _exception : "Deleg stake deposit above max_stake limit"; ssn_address : ssnaddr; deleg_address : initiator; requested_deposit : _amount; max_stake : maxstake_tmp };
      throw e
    | False =>
      last_reward_cycle <- lastrewardcycle;
      (*The delegated stake can be accepted. It is buffered if the SSN is active if not it is added to the stake_amount. *)
      FillInDelegAmount ssnaddr initiator;
      FillInDelegs ssnaddr initiator;
      match active_status with
      | True  =>
        (* The SSN is active so add the delegated stake to the buffer *)
        ssn = Ssn bool_active stake_amount rewards name urlraw urlapi new_buff_amount comm commision_rewards received_address;
        ssnlist[ssnaddr] := ssn;
        (* record this to buffer deposit for deleg *)
        stake_amount_for_deleg_option <- buffered_deposit_deleg[initiator][ssnaddr][last_reward_cycle];
        match stake_amount_for_deleg_option with
        | Some stake_amount_for_deleg =>
          new_stake_amount_for_deleg = builtin add stake_amount_for_deleg _amount;
          buffered_deposit_deleg[initiator][ssnaddr][last_reward_cycle] := new_stake_amount_for_deleg
        | None =>
          buffered_deposit_deleg[initiator][ssnaddr][last_reward_cycle] := _amount
        end
      | False =>
        (* The SSN is inactive so add the delegated stake to stake_amount *)
        new_stake_amount  = builtin add _amount stake_amount;
        status = uint128_le minstake_tmp new_stake_amount;
        (* The SSN becomes active if the total stake after deposit is greater than the minimum required. *)
        ssn = Ssn status new_stake_amount rewards name urlraw urlapi buffdeposit comm commision_rewards received_address;
        ssnlist[ssnaddr] := ssn;
        d <- delegs[ssnaddr][initiator];
        (* record this to direct deposit for deleg *)
        stake_amount_for_deleg_option <- direct_deposit_deleg[initiator][ssnaddr][last_reward_cycle];
        match stake_amount_for_deleg_option with
          | Some stake_amount_for_deleg =>
            new_stake_amount_for_deleg = builtin add stake_amount_for_deleg _amount;
            direct_deposit_deleg[initiator][ssnaddr][last_reward_cycle] := new_stake_amount_for_deleg
          | None =>
            direct_deposit_deleg[initiator][ssnaddr][last_reward_cycle] := _amount
        end
      end
    end
  end
end
(* @dev: Assign stake reward to all ssn from ssnlist. Used by verifier only. *)
(* @param ssnrewardlist: List of SsnRewardShare *)
(* @param initiator: The original caller who called the proxy *)
transition AssignStakeReward(ssnreward_list : List SsnRewardShare, initiator : ByStr20)
  IsPaused;
  IsProxy;
  CallerIsVerifier initiator;
  last_reward_cycle <- lastrewardcycle;
  forall ssnreward_list UpdateStakeReward;
  newLastRewardCycleNum = builtin add uint128_one last_reward_cycle;
  lastrewardcycle := newLastRewardCycleNum;
  reward_cycle_list <- reward_cycle_list;
  new_reward_cycle_list = Cons {Uint128} newLastRewardCycleNum reward_cycle_list;
  reward_cycle_list := new_reward_cycle_list
end
(* @dev: Withdraw comm. Can be called by a ssn operator. *)
(* @param initiator: The original caller who called the proxy *)
transition WithdrawCommission(initiator : ByStr20)
  IsPaused;
  IsProxy;
  curval <- ssnlist[initiator];
  match curval with
  | None =>
    e = SSNNotExist;
    ThrowError e
  | Some (Ssn active_status stake_amount rewards name urlraw urlapi buffdeposit comm comm_rewards received_address) =>
    TransferFunds multisig_tag_addfunds comm_rewards received_address;
    e = { _eventname : "SSN withdraw reward"; ssn_address : initiator; withdraw_total_reward : rewards };
    event e;
    ssn = Ssn active_status stake_amount rewards name urlraw urlapi buffdeposit comm uint128_zero received_address;
    ssnlist[initiator] := ssn
  end
end
(* @dev: Withdraw stake reward. Can be called by a deleg. *)
(* @param initiator: The original caller who called the proxy *)
transition WithdrawStakeRewards(ssn_operator : ByStr20, deleg : ByStr20)
  IsPaused;
  IsProxy;
  DelegExists ssn_operator deleg;
  DistributeStakeRewards deleg ssn_operator
end
(* @dev: Withdraw all amount owed by the contract. Used by delegs. *)
(* @param ssn: Address of the SSN to which stake had been delegated. *)
(* @param initiator: The original caller who called the proxy. *)
(* @note: Withdraws stake + buffer + reward in one go. *)
transition WithdrawStakeAmount(ssn: ByStr20, initiator : ByStr20)
  IsPaused;
  IsProxy;
  DistributeStakeAmount initiator ssn
end
(* @dev: Move funds from initiator to recipient, i.e., contract address. *)
(* @param initiator: The original caller who called the proxy. *)
transition AddFunds(initiator : ByStr20)
  IsPaused;
  IsProxy;
  accept;
  e = { _eventname : "Verifier deposit funds"; verifier : initiator };
  event e
end
transition UpdateLastRewardCycle(initiator : ByStr20, cycle : Uint128)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  lastrewardcycle := cycle
end
transition UpdateRewardCycleList(initiator : ByStr20, list: List Uint128)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  reward_cycle_list := list
end
transition PopulateCommissionForSSN(initiator : ByStr20, ssn_address : ByStr20, cycle : Uint128, comm : Uint128)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  comm_for_ssn[ssn_address][cycle] := comm
end
transition PopulateStakeSSNPerCycle(initiator : ByStr20, ssn_address : ByStr20, cycle : Uint128, info : SSNCycleInfo)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  stake_ssn_per_cycle[ssn_address][cycle] := info
end
transition PopulateLastWithdrawCycleForDeleg(initiator : ByStr20, deleg_address : ByStr20, ssn_address : ByStr20, cycle : Uint128)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  last_withdraw_cycle_deleg[deleg_address][ssn_address] := cycle
end
transition PopulateBufferedDeposit(initiator : ByStr20, deleg_address : ByStr20, ssn_address : ByStr20, cycle : Uint128, amount : Uint128)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  buffered_deposit_deleg[deleg_address][ssn_address][cycle] := amount
end
transition PopulateDirectDeposit(initiator : ByStr20, deleg_address : ByStr20, ssn_address : ByStr20, cycle : Uint128, amount : Uint128)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  direct_deposit_deleg[deleg_address][ssn_address][cycle] := amount
end
transition PopulateDepositAmountForDeleg(initiator : ByStr20, deleg_address : ByStr20, ssn_address : ByStr20, amount : Uint128)
  IsPaused;
  IsProxy;
  IsAdmin initiator;
  deposit_amount_deleg[deleg_address][ssn_address] := amount
end
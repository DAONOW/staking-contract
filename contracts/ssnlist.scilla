scilla_version 0

library SSNList

let one_msg =
  fun (m : Message) =>
    let e = Nil {Message} in
    Cons {Message} m e

let uint128_zero = Uint128 0
let bool_active = True
let bool_inactive = False
let uint128_10_power_7 = Uint128 10000000
let empty_tag = ""
let multisig_tag_addfunds = "AddFunds"
(* events *)

let mk_contract_freezed_error =
  fun (sender : ByStr20) =>
    { _exception : "Contract freezed failure"; sender : sender }

let mk_verifier_validation_failed_error =
  fun (sender : ByStr20) =>
    { _exception : "Verifier validation failed"; sender : sender }

let mk_admin_validation_failed_error =
  fun (sender : ByStr20) =>
    { _exception : "Admin validation failed"; sender : sender }

let mk_proxy_validation_failed_error =
  fun (sender : ByStr20) =>
    { _exception : "Proxy validation failed"; sender : sender }

let mk_ssn_already_exists_event =
  fun (ssn : ByStr20) =>
    { _eventname : "SSN already exists"; ssn_address : ssn }

let mk_delegator_already_exists_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator already exists"; ssn_address : ssn; delegator_address : delegator }

let mk_ssn_added_event =
  fun (ssn : ByStr20) =>
    { _eventname : "SSN added"; ssn_address : ssn }

let mk_delegator_added_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator added"; ssn_address : ssn; delegator_address : delegator }

let mk_ssn_not_exists_event =
  fun (ssn : ByStr20) =>
    { _eventname : "SSN doesn't exist"; ssn_address : ssn }

let mk_delegator_not_exists_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator doesn't exist"; ssn_address : ssn; delegator_address : delegator}

let mk_ssn_removed_event =
  fun (ssn : ByStr20) =>
    { _eventname : "SSN removed"; ssn_address : ssn }

let mk_delegator_removed_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator removed"; ssn_address : ssn; delegator_address : delegator}

let mk_stake_deposit_event =
  fun (ssn : ByStr20) =>
  fun (amount : Uint128) =>
    { _eventname : "SSN updated stake"; ssn_address : ssn; new_stake_amount : amount }

let mk_delegate_stake_deposit_event =
    fun (ssn : ByStr20) =>
    fun (delegator : ByStr20) =>
    fun (amount : Uint128) =>
      { _eventname : "Stake Delegated"; ssn_address : ssn; delegator : delegator; stake_amount : amount }

let mk_stake_deposit_below_stake_limit_event =
  fun (ssn : ByStr20) =>
  fun (amount : Uint128) =>
  fun (minstake : Uint128) =>
    { _eventname : "SSN stake deposit below min_stake limit"; ssn_address : ssn; requested_deposit : amount; min_stake : minstake }

let mk_stake_deposit_above_stake_limit_event =
  fun (ssn : ByStr20) =>
  fun (amount : Uint128) =>
  fun (maxstake : Uint128) =>
    { _eventname : "SSN stake deposit above max_stake limit"; ssn_address : ssn; requested_deposit : amount; max_stake : maxstake }

let mk_delegated_stake_deposit_above_stake_limit_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
  fun (amount : Uint128) =>
  fun (maxstake : Uint128) =>
    { _eventname : "Delegator stake deposit above max_stake limit"; ssn_address : ssn; delegator_address : delegator; requested_deposit : amount; max_stake : maxstake }

let mk_total_stake_deposit_above_contract_stake_limit_event =
  fun (ssn : ByStr20) =>
  fun (amount : Uint128) =>
  fun (contractmaxstake : Uint128) =>
    { _eventname : "SSN stake deposit will result in contract stake deposit go above limit"; ssn_address : ssn; requested_deposit : amount; contract_max_stake : contractmaxstake }

let mk_delegator_no_withdraw_record_event = 
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator no withdraw record"; ssn_address : ssn; delegator_address : delegator }

let mk_delegator_rewards_event = 
  fun (ssn : ByStr20) => 
  fun (delegator : ByStr20) =>
  fun (rewards : Uint128) =>
    { _eventname : "Delegator rewards"; ssn_address : ssn; delegator_address : delegator; rewards : rewards}

let mk_assign_stake_reward_event =
  fun (ssn : ByStr20) =>
  fun (total_reward : Uint128) =>
    { _eventname : "SSN assign reward"; ssn_address : ssn; total_reward : total_reward }

let mk_withdraw_stake_rewards_event =
  fun (ssn : ByStr20) =>
  fun (total_reward: Uint128) =>
    { _eventname : "SSN withdraw reward"; ssn_address : ssn; withdraw_total_reward : total_reward }

 let mk_deposit_funds_event =
  fun (sender : ByStr20) =>
    { _eventname : "Verifier deposit funds"; verifier : sender }

 let mk_withdraw_below_stake_limit_event =
    fun (ssn : ByStr20) =>
    fun (minstake: Uint128) =>
      { _eventname : "SSN withdrawal below min_stake limit"; ssn_address : ssn; minstake_limit : minstake }

 let mk_withdraw_above_stake_event =
    fun (ssn : ByStr20) =>
      { _eventname : "SSN withdrawal above stake"; ssn_address : ssn }

 let mk_withdraw_stake_buffered_deposit_exist =
    fun (ssn : ByStr20) =>
    fun (buffdeposit: Uint128) =>
      { _eventname : "SSN withdrawal not allowed when some deposit is bufferred"; ssn_address : ssn; buffered_stake_amount : buffdeposit }

(* Ssn - active_status , stake_amount, rewards, urlraw, urlapi, buffereddeposit, commission_rate, commision_rewards *)
(* Invariant 1: stake_amount + buffered_deposit < maxstake *)
(* Invariant 2: active_status = (minstake < stake_amount) *)

type Ssn =
| Ssn of Bool Uint128 Uint128 String String Uint128 Uint128 Uint128

type SsnRewardShare =
| SsnRewardShare of ByStr20 Uint128

(* 
    Each delegator has the following fields:

    StakeAmount       : Uint128
                        Represents the amount staked so far. This is the sum total of
                        amount staked across all SSNs. 
    StakeRewards      : Uint128
                        The rewards accumulatd so far from all SSNs. This is the sum total of reward accumulated across all SSNs. 
    Buffereddeposit   : Uint128
                        The deposit that needs to be in buffer until the next reward cycle and cannot be immediately
                        considered as a part of the staking. This is the sum total of buffereddeposits made across all SSNs.  
*)    

type Delegator =
| Delegator of Uint128 Uint128 Uint128

type PairForStakeSSNCycle =
| PairForStakeSSNCycle of Uint128 Uint128

(* AddressofSSN StakeAtThatBlock AddressofDelegator*)
type PairForDelegatorCycle = 
| PairForDelegatorCycle of ByStr20 Uint128 ByStr20

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract SSNList(
  init_admin : ByStr20,
  proxy_address : ByStr20
)

(* Mutable fields *)

field ssnlist : Map ByStr20 Ssn = Emp ByStr20 Ssn
(* Keeps track of the delegators for each SSN.*)
(* AddressofSSN -> (AddressOfDelegator -> DelegatorInfo) *)
field delegators : Map ByStr20 (Map ByStr20 Delegator) = Emp ByStr20 (Map ByStr20 Delegator)
(* AddressofSSN -> (Blocknum -> Pair (TotalStakeAtThatBlockForTheSSN, TotalRewardEarned) *)
field stakeSSNPerCyle : Map ByStr20 (Map Uint32 PairForStakeSSNCycle) = Emp ByStr20 (Map Uint32 PairForStakeSSNCycle)
(* AddressofDelegator -> (Blocknum -> Pair(AddressofSSN StakeAtThatBlock)) *)
field stakeDelegatorPerCyle : Map ByStr20 (Map Uint32 PairForDelegatorCycle) = Emp ByStr20 (Map Uint32 PairForDelegatorCycle)
(* AddressofDelegator -> Blocknum *)
field lastWithdrawCycleForDelegator : Map ByStr20 Uint32 = Emp ByStr20 Uint32

field verifier : Option ByStr20 = None {ByStr20}
field minstake : Uint128 = Uint128 0
field maxstake : Uint128 = Uint128 0
field contractmaxstake : Uint128 = Uint128 0
field totalstakedeposit : Uint128 = Uint128 0
field contractadmin : ByStr20  = init_admin
field lastrewardblocknum : Uint32 = Uint32 0
field paused : Bool = True

(* Procedures *)

(* Can be called by the verifier only *)
procedure validate_verifier (initiator : ByStr20)
  verifier_l <- verifier;
  match verifier_l with
  | Some v =>
    is_verifier = builtin eq initiator v;
    match is_verifier with
    | True =>
    | False =>
      e = mk_verifier_validation_failed_error initiator;
      throw e
    end
  | None =>
    e = mk_admin_validation_failed_error initiator;
    throw e
  end
end

(* Can be called by the current contract admin only *)
procedure validate_admin (initiator : ByStr20)
  contractadmin_l <- contractadmin;
  is_admin = builtin eq initiator contractadmin_l;
  match is_admin with
  | True =>
  | False =>
    e = mk_admin_validation_failed_error initiator;
    throw e
  end
end

(* Can be called by the proxy only *)
procedure validate_proxy ()
  is_proxy = builtin eq _sender proxy_address;
  match is_proxy with
  | True =>
  | False =>
    e = mk_proxy_validation_failed_error _sender;
    throw e
  end
end

(* Can be called by the proxy only *)
procedure is_paused ()
  paused_l <- paused;
  match paused_l with
  | False =>
  | True =>
    e = mk_contract_freezed_error _sender;
    throw e
  end
end

(* Can be called by the contract admin only *)
(* It is expected that transfer only happens to an exterally owned account*)
procedure TransferFunds (tag: String, amount : Uint128, recipient : ByStr20)
    msg = {_tag : tag; _recipient : recipient; _amount : amount};
    msgs = one_msg msg;
    send msgs
end

(* Can be called by the proxy only *)
procedure update_stake_reward (entry : SsnRewardShare)
  lastreward_block <- lastrewardblocknum;
  match entry with
  | SsnRewardShare ssnaddr reward_percent =>
    curval <- ssnlist[ssnaddr];
    match curval with
    | None =>
      e = mk_ssn_not_exists_event ssnaddr;
      event e
    | Some (Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit commission commission_rewards) =>
      match active_status with
      | False => throw
      | True  => 
        hundred = Uint128 100;
        new_reward = builtin mul stake_amount reward_percent;
        new_reward = builtin div new_reward hundred;
        new_reward = builtin div new_reward uint128_10_power_7;
       
        reward_commission_tmp = builtin mul new_reward commission;
        reward_commission_tmp = builtin div reward_commission_tmp hundred;
        reward_commission_tmp = builtin div reward_commission_tmp uint128_10_power_7;
        total_reward_commission = builtin add reward_commission_tmp commission_rewards;

        delegator_reward = let t = builtin sub new_reward total_reward_commission in builtin add t rewards;

        new_stake_amount = builtin add stake_amount buffereddeposit;
        p = PairForStakeSSNCycle stake_amount delegator_reward;
        stakeSSNPerCyle[ssnaddr][lastreward_block] := p;
        
        ssn = Ssn active_status new_stake_amount delegator_reward urlraw urlapi uint128_zero commission total_reward_commission;
        ssnlist[ssnaddr] := ssn;
        e = mk_assign_stake_reward_event ssnaddr total_reward_commission;
        event e
      end
    end
  end
end

procedure update_delegator_rewards(entry: Pair Uint32 PairForDelegatorCycle)
  match entry with
  | Pair blockNumber addrAndStakeAmount =>
    match addrAndStakeAmount with
    | PairForDelegatorCycle ssnAddress delegateAmount delegatorAddress =>
      totalStakeAndReward_o <- stakeSSNPerCyle[ssnAddress][blockNumber];
      match totalStakeAndReward_o with
      | Some totalStakeAndReward =>
        match totalStakeAndReward with
        | PairForStakeSSNCycle totalStake totalRewards =>
          reward_tmp = builtin mul totalRewards delegateAmount;
          reward_tmp = builtin div reward_tmp totalStake;

          delegator_o <- delegators[ssnAddress][delegatorAddress];

          match delegator_o with
          | Some delegator =>
            match delegator with
            | Delegator stakeAmount stakeRewards buffereddeposit =>
              newStakeRewards = builtin add stakeRewards reward_tmp;
              d = Delegator stakeAmount newStakeRewards buffereddeposit;
              delegators[ssnAddress][delegatorAddress] := d;
              e = mk_delegator_rewards_event ssnAddress delegatorAddress reward_tmp;
              event e
            end
          | None =>
          end

        end
      | None =>
      end
    end
  end
  
end



(* Transitions *)

(* @dev: pause/freeze the contract. Used by admin only. *)
(* @param initiator: The original caller who called the proxy *)
transition pause(initiator: ByStr20)
    validate_proxy;
    validate_admin initiator;
    paused := bool_active
end

(* @dev: unpause/unfreeze the contract. Used by admin only. *)
(* @param initiator: The original caller who called the proxy *)
transition unpause(initiator: ByStr20)
    validate_proxy;
    validate_admin initiator;
    paused := bool_inactive
end

(* @dev: Set the admin of contract. Used by admin only. *)
(* @param admin: New admin value *)
(* @param initiator: The original caller who called the proxy *)
transition update_admin (admin : ByStr20, initiator: ByStr20)
  validate_proxy;
  validate_admin initiator;
  contractadmin := admin
end

(* @dev: Set the verifier of contract. Used by admin only. *)
(* @param verif: New verifier value *)
(* @param initiator: The original caller who called the proxy *)
transition update_verifier (verif : ByStr20, initiator: ByStr20)
  validate_proxy;
  validate_admin initiator;
  newverifier = Some {ByStr20} verif;
  verifier := newverifier
end

(* @dev: Drain the entire contract balance. Used by current admin only. *)
(* @param initiator: The original caller who called the proxy *)
transition drain_contract_balance (initiator : ByStr20)
  validate_proxy;
  validate_admin initiator;
  bal <- _balance;
  TransferFunds multisig_tag_addfunds bal initiator
end

(* @dev: Set the minstake of contract. Used by admin only. *)
(* @param min_stake: New minstake value *)
(* @param initiator: The original caller who called the proxy *)
transition update_minstake (min_stake : Uint128, initiator : ByStr20)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  minstake := min_stake
end

(* @dev: Set the maxstake of contract. Used by admin only. *)
(* @param max_stake: New maxstake value *)
(* @param initiator: The original caller who called the proxy *)
transition update_maxstake (max_stake : Uint128, initiator : ByStr20)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  maxstake := max_stake
end

(* @dev: Set the maxstake of contract. Used by admin only. *)
(* @param max_stake: New maxstake value *)
(* @param initiator: The original caller who called the proxy *)
transition update_contractmaxstake (max_stake : Uint128, initiator : ByStr20)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  contractmaxstake := max_stake
end

(* @dev: Adds new ssn to ssnlist. Used by admin only. *)
(* @param ssnaddr: Address of the ssn to be added *)
(* @param stake_amount: Stake amount of ssn *)
(* @param rewards: Rewards of the ssn to be added *)
(* @param urlraw: string representing "ip:port" of the ssn serving raw api request *)
(* @param urlapi: string representing url exposed by ssn serving public api request *)
(* @param buffered_deposit: Any buffered stake deposit *)
(* @param initiator: The original caller who called the proxy *)
transition add_ssn(ssnaddr : ByStr20, stake_amount : Uint128, rewards : Uint128, urlraw : String, urlapi : String, buffered_deposit : Uint128, initiator : ByStr20, commission : Uint128, commission_rewards : Uint128)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  already_exists <- exists ssnlist[ssnaddr];
  match already_exists with
  | True  =>
    e = mk_ssn_already_exists_event ssnaddr;
    event e
  | False =>
    minstake_l <- minstake;
    maxstake_l <- maxstake;
    total_amount = builtin add stake_amount buffered_deposit;
    pass = builtin lt maxstake_l total_amount;
    match pass with
    | True  =>         
      e = mk_stake_deposit_above_stake_limit_event ssnaddr stake_amount maxstake_l;
      event e
    | False =>
      status = builtin lt minstake_l stake_amount;
      (* Update the total stake deposit *)
      totalstakedeposit_l <- totalstakedeposit;
      totalstakedeposit_l = builtin add totalstakedeposit_l stake_amount;
      totalstakedeposit := totalstakedeposit_l;
      s = Ssn status stake_amount rewards urlraw urlapi buffered_deposit commission commission_rewards;
      ssnlist[ssnaddr] := s;
      e = mk_ssn_added_event ssnaddr;
      event e
    end
  end
end

(* @dev: Adds new delegator. Used by admin only during contract upgrade. *)
(* @param ssnaddr: Address of the ssn *)
(* @param delegator: Address of the delegator *)
(* @param stake_amount: Stake amount *)
(* @param rewards: Rewards of the ssn to be added *)
(* @param buffered_deposit: Any buffered stake deposit *)
(* @param initiator: The original caller who called the proxy *)
transition add_delegator (ssnaddr : ByStr20, delegator : ByStr20, stake_amount : Uint128, rewards : Uint128, buffered_deposit : Uint128, initiator : ByStr20)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  already_exists <- exists delegators[ssnaddr][delegator];
  match already_exists with
  | True =>
    e = mk_delegator_already_exists_event ssnaddr delegator;
    event e
  | False =>
    d = Delegator stake_amount rewards buffered_deposit;
    delegators[ssnaddr][delegator] := d;
    e = mk_delegator_added_event ssnaddr delegator;
    event e
  end
end

(* @dev: Remove a specific ssn from ssnlist. Used by admin only. *)
(* @param ssnaddr: Address of the ssn to be removed *)
(* @param initiator: The original caller who called the proxy *)
transition remove_ssn (ssnaddr : ByStr20, initiator: ByStr20)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  already_exists <- exists ssnlist[ssnaddr];
  match already_exists with
  | False =>
    e = mk_ssn_not_exists_event ssnaddr;
    event e
  | True =>
    delete ssnlist[ssnaddr];
    e = mk_ssn_removed_event ssnaddr;
    event e
  end
end

(* @dev: Remove a specific delegator for a given SSN. Used by admin only. *)
(* @param ssnaddr: Address of the ssn to be removed *)
(* @param initiator: The original caller who called the proxy *)
transition remove_delegator (ssnaddr : ByStr20, delegator : ByStr20, initiator: ByStr20)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  already_exists <- exists delegators[ssnaddr][delegator];
  match already_exists with
  | False =>
    e = mk_delegator_not_exists_event ssnaddr delegator;
    event e
  | True =>
    delete delegators[ssnaddr][delegator];
    e = mk_delegator_removed_event ssnaddr delegator;
    event e
  end
end

(* This is to be called in case the SSn is providing a non-custodial staking service *)
(* @param initiator: The original caller who called the proxy aka the delegator *)
(* @param ssnaddr: The address of the SSN to which the initiator wants to delegate his tokens *)

transition update_commission(new_rate : Uint128, initiator : ByStr20)
  is_paused;
  validate_proxy;
  curval <- ssnlist[initiator];
  match curval with
  | Some (Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit commission commision_rewards) =>
    ssn =  Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit new_rate commision_rewards;
    ssnlist[initiator] := ssn
  | None =>
    e = mk_ssn_not_exists_event initiator;
    event e
  end
end

transition delegate_stake(ssnaddr : ByStr20, initiator: ByStr20)
  is_paused;
  validate_proxy;
  (* Accept the deposit from SSN and add to contract balance. *)
  (* Transfer back to initiator if any of the validation failed *)
  accept;
  curval <- ssnlist[ssnaddr];
  match curval with
  | None =>
    TransferFunds empty_tag _amount initiator;
    e = mk_ssn_not_exists_event initiator;
    event e
  | Some (Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit commission commision_rewards) =>
    minstake_l <- minstake;
    maxstake_l <- maxstake;
    new_buff_amount  = builtin add _amount buffereddeposit;
    new_stake_amount = builtin add new_buff_amount stake_amount;
    pass = builtin lt maxstake_l new_stake_amount;
    match pass with
    | True  => (* stake deposit above maxstake limit for SSNs *)
      TransferFunds empty_tag _amount initiator;
      e = mk_delegated_stake_deposit_above_stake_limit_event ssnaddr initiator _amount maxstake_l;
      event e
    | False => 
      (*The delegated stake can be accepted. It is buffered if the SSN is active if not it is added to the stake_amount. *)
      match active_status with
      | True  => 
        (* The SSN is active so add the delegated stake to the buffer *)
        ssn = Ssn bool_active stake_amount rewards urlraw urlapi new_buff_amount commission commision_rewards;
        ssnlist[ssnaddr] := ssn;
        d <- delegators[ssnaddr][initiator];
        match d with
        | Some (Delegator amount reward buffered_deposit) =>
          new_buff_amount_delegator = builtin add _amount buffered_deposit;
          d_new = Delegator amount reward new_buff_amount_delegator;
          delegators[ssnaddr][initiator] := d_new
        | None =>
          d_new = Delegator uint128_zero uint128_zero _amount;
          delegators[ssnaddr][initiator] := d_new
        end
      | False =>
        (* The SSN is inactive so add the delegated stake to stake_amount *)
        new_stake_amount  = builtin add _amount stake_amount;
        status = builtin lt minstake_l new_stake_amount;
        (* The SSN becomes active if the total stake after deposit is greater than the minimum required. *)
        ssn = Ssn status new_stake_amount rewards urlraw urlapi buffereddeposit commission commision_rewards;
        ssnlist[ssnaddr] := ssn;
        d <- delegators[ssnaddr][initiator];
        match d with
        | Some (Delegator amount reward buffered_deposit) =>
          new_stake_amount_delegator = builtin add _amount amount;
          d_new = Delegator new_stake_amount_delegator reward buffered_deposit;
          delegators[ssnaddr][initiator] := d_new
        | None =>
          d_new = Delegator _amount uint128_zero uint128_zero;
          delegators[ssnaddr][initiator] := d_new
        end
      end
    end
  end
end

(* @dev: Assign stake reward to all ssn from ssnlist. Used by verifier only. *)
(* @param ssnrewardlist: List of SsnRewardShare *)
(* @param reward_blocknum: tx block num when ssns were verified *)
(* @param initiator: The original caller who called the proxy *)
transition assign_stake_reward(ssnreward_list : List SsnRewardShare, reward_blocknum : Uint32, initiator: ByStr20)
  is_paused;
  validate_proxy;
  validate_verifier initiator;
  last_reward_block <- lastrewardblocknum;
  res = builtin lt reward_blocknum last_reward_block;
  match res with
  | True  => 
  | False =>
    forall ssnreward_list update_stake_reward;
    lastrewardblocknum := reward_blocknum
  end 
end

(* @dev: Withdraw stake reward. Can be called by a delegator. *)
(* @param initiator: The original caller who called the proxy *)
transition withdraw_stake_rewards (ssnaddr : ByStr20, initiator : ByStr20)
  is_paused;
  validate_proxy;

  curval <- ssnlist[ssnaddr];
  match curval with
  | None =>
    e = mk_ssn_not_exists_event initiator;
    event e
  | Some (Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit commission commission_rewards) =>
    lastWithdrawCycle <- lastWithdrawCycleForDelegator[initiator];
    match lastWithdrawCycle with
    | Some lastWithdrawBlock =>
      (* todo *)
    | None =>
      (* if there is no withdraw yet, should go through all stakeDelegatorPerCyle *)
      stakeDelegatorPerCyle_m <- stakeDelegatorPerCyle[initiator];
      match stakeDelegatorPerCyle_m with 
      | Some data =>
        cycle_list = builtin to_list data;

        forall cycle_list update_delegator_rewards;
        e = mk_delegator_no_withdraw_record_event ssnaddr initiator;
        event e
      | None =>
        e =  mk_delegator_no_withdraw_record_event ssnaddr initiator;
        event e
      end  
    end
  end
end

transition withdraw_commission(initiator : ByStr20)
  is_paused;
  validate_proxy;
  curval <- ssnlist[initiator];
  match curval with
  | None =>
    e = mk_ssn_not_exists_event initiator;
    event e
  | Some (Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit commission commission_rewards) =>
    TransferFunds empty_tag commission_rewards initiator;
    e = mk_withdraw_stake_rewards_event initiator rewards;  
    ssn = Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit commission uint128_zero;
    ssnlist[initiator] := ssn
  end
end


(* @dev: Move token amount from contract account to initiator. Used by ssn only. *)
(* @param amount: token amount to be withdrawed *)
(* @param initiator: The original caller who called the proxy *)
transition withdraw_stake_amount (amount : Uint128, initiator: ByStr20)
  is_paused;
  validate_proxy;
  curval <- ssnlist[initiator];
  match curval with
  | None =>
    e = mk_ssn_not_exists_event initiator;
    event e
  | Some (Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit commission commission_rewards) =>
    pass = builtin eq buffereddeposit uint128_zero;
    match pass with
    | False =>
      e = mk_withdraw_stake_buffered_deposit_exist initiator buffereddeposit;
      event e
    | True =>
      pass = builtin lt amount stake_amount;
      match pass with
      | True => (* Partial withdrawal. so check for min balance after withdrawal for min stake limit *)
          bal_left = builtin sub stake_amount amount;
          minstake_l <- minstake;
          pass = builtin lt bal_left minstake_l;
          match pass with
          | True =>
            e = mk_withdraw_below_stake_limit_event initiator minstake_l;
            event e
          | False => (* pass minstake check for withdrawal *)
            (* Update the stake amount *)
            ssn = Ssn active_status bal_left rewards urlraw urlapi buffereddeposit commission commission_rewards;
            ssnlist[initiator] := ssn;
            (* Update the total stake deposit with contract *)
            totalstakedeposit_l <- totalstakedeposit;
            tmp = builtin sub totalstakedeposit_l amount;
            totalstakedeposit := tmp;
            TransferFunds empty_tag amount initiator
          end
      | False => (* requested withdrawal equals balance or greater than balance *)
          pass = builtin eq amount stake_amount;
          match pass with
          | False => (* withdrawal above available balance *)
            e = mk_withdraw_above_stake_event initiator;
            event e
          | True => (* pass withdrawal checks *)
            pass = builtin eq rewards uint128_zero;
            match pass with
            | True =>
              (* entire stake withdrawed and also reward is withdrawed, so remove ssn *)
              delete ssnlist[initiator]
            | False =>
              ssn = Ssn bool_inactive uint128_zero rewards urlraw urlapi buffereddeposit commission commission_rewards;
              ssnlist[initiator] := ssn
            end;
            totalstakedeposit_l <- totalstakedeposit;
            tmp = builtin sub totalstakedeposit_l amount;
            totalstakedeposit := tmp;
            TransferFunds empty_tag amount initiator
          end
        end
    end
  end
end

(* @dev: Move token amount from initiator to recipient i.e. contract address. *)
(* @param initiator: The original caller who called the proxy *)
transition deposit_funds (initiator : ByStr20)
  is_paused;
  validate_proxy;
  accept;
  e = mk_deposit_funds_event initiator;
  event e
end
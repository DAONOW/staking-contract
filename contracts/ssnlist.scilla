scilla_version 0

import ListUtils

library SSNList

(* A non-custodial staking contract with admin privileges *)

(* SSN Data Type *)
(* 
  Each SSN has the following fields:

  ActiveStatus      : Bool
                      Represents whether the SSN has the minnimum stake amount and therefore ready to participate in staking and receive rewards.
  StakeAmount       : Uint128
                      Total stake that can be used for reward calculation. 
  StakeRewards      : Uint128
                      (Unwithdrawn) Reward accumulated so far across all cycles. It only includes the reward that the SSN can distribute to its delegators.
                      It does not include SSN's own commission.
  Name              : String
                      A human-readable name for this SSN.
  URLRaw            : String
                      Represents "ip:port" of the SSN serving raw API requests.
  URLApi            : String 
                      Representing URL exposed by SSN serving public API requests.
  BufferedDeposit   : Uint128
                      Stake deposit that cannot be counted as a part of reward calculation for the ongoing reward cycle. But, to be considered
                      for the next one.
  Commission        : Uint128
                      Percentage of incoming rewards that the SSN takes.
  CommissionRewards : Uint128
                      Number of ZILs earned as commission by the SSN.
  ReceivedAddress   : ByStr20
                      Address will be used to receive commission.
*)    
(* Invariant 1: StakeAmount + BufferedDeposit < MaxStake < ContractMaxStake *)
(* Invariant 2: ActiveStatus = (Minstake < StakeAmount)  *)

type Ssn =
| Ssn of Bool Uint128 Uint128 String String String Uint128 Uint128 Uint128 ByStr20

(* SSNRewardShare Data Type *)
(* 
  SSNRewardShare has the following fields:

  SSNAddress        : ByStr20
                      Address of the SSN.
  RewardPercentage  : Uint128
                      This is the integer representation of the percentage of the staked amount that will be given as reward to the SSN.
                      If the percentage is 5.2%, then, the value of this field will be 5.2 x 10^7 represented as an integer.
                      If the percentage is 10%, and the SSN has a stake of 100 ZILs, then the reward in ZILs will be 10% of 100 = 10 ZILs.
*)
    
type SsnRewardShare =
| SsnRewardShare of ByStr20 Uint128


(* Delegator Data Type *)
(* 
    Each delegator has the following fields:

    StakeAmount       : Uint128
                        Represents the amount staked so far. This is the sum total of amount staked across all SSNs. 
    StakeRewards      : Uint128
                        The rewards accumulatd so far from all SSNs. This is the sum total of reward accumulated across all SSNs. 
                            considered as a part of the staking. This is the sum total of buffereddeposits made across all SSNs.  
*)    

type Delegator =
| Delegator of Uint128 Uint128

(* DelegatorCycleInfo Data Type *)
(* 
    Each DelegatorCycleInfo has the following fields:
    SSNAddress          : ByStr20
                          Address of the SSN.
    StakeDuringTheCycle : Uint128 
                          Represents the amount staked during this cycle for the given SSN.
    DelegatorAddress    : ByStr20
                          Address of Delegator. 
*)    

type DelegatorCycleInfo = 
| DelegatorCycleInfo of ByStr20 Uint128 ByStr20

(* SSNCycleInfo Data Type *)
(* 
    Each SSNCycleInfo has the following fields:
    TotalStakeDuringTheCycle            : Uint128 
                                          Represents the amount staked during this cycle for the given SSN.
    TotalRewardEarnedDuringTheCycle    : Uint128 
                                         Represents the amount staked during this cycle for the given SSN.
*)    

type SSNCycleInfo =
| SSNCycleInfo of Uint128 Uint128

(* DelegatorAndRewards Data Type *)
(* 
    Each DelegatorAndRewards has the following fields:
    DelegatorAddress    : ByStr20
                          Address of Delegator.
    RewardToBeSent      : Uint128 
                          Reward that can be sent to the delegator.
*)    

type DelegatorAndRewards = 
| DelegatorAndRewards of ByStr20 Uint128

let one_msg =
  fun (m : Message) =>
    let e = Nil {Message} in
    Cons {Message} m e

let uint128_one =  Uint128 1

let uint128_zero = Uint128 0

(* This function help us to tell if current block number need to be reward *)
let reward_filter = 
  fun (lastrewardcycle : Uint128) =>
    fun (current_pair : Pair Uint128 DelegatorCycleInfo) => 
        match current_pair with
        | Pair currentblock (DelegatorCycleInfo ssn block delegator) =>
          builtin lt lastrewardcycle currentblock
      end

(* left < element <= right *)
(* This function is used for filting out those cycles that need to compute rewards for delegators *)
let list_between =
  fun (left : Uint128) =>
    fun (right : Uint128) =>
      fun (element : Uint128) => 
        let res = builtin lt left element in
        match res with
        | True =>
          let res = builtin lt right element in
          match res with
          | True => False
          | False => True
          end
        | False => False
        end

(* This function is used for calculating the exact staking amount per cycle for delegators *)
(* Example: *)
(* Input: [1:1000,2:2000,3:3000] *)
(* [1:1000] => [1:1000,2:2000+1000] => [1:1000,2:3000,3:3000+3000] *)
let caculate_all_stake_per_cycle = 
  fun (delegate_map : Map Uint128 Uint128) => 
    fun (result_map : Map Uint128 Uint128) => 
      fun(k : Uint128) =>
        let m = builtin sub k uint128_one in
        let result_map_o = builtin get result_map m in 
        let delegate_map_o = builtin get delegate_map k in
        match result_map_o with
        | Some last_amount =>
          match delegate_map_o with
          | Some delegate_amount =>
            let amount = builtin add last_amount delegate_amount in
            builtin put result_map k amount
          | None =>
            builtin put result_map k last_amount
          end
        | None =>
          match delegate_map_o with
          | Some delegate_amount =>
            builtin put result_map k delegate_amount
          | None =>  result_map
          end
        end

(* This function is used for combining direct deposit and buffered deposit into one with correct secquence *)
(* Example: *)
(* Direct deposit: [1:1000,2:2000:3:3000] *)
(* Buffered deposit: [1:1000,2:2000:3:3000]*)
(* Result deposit: [1:1000,2:2000+1000:3:3000+2000] *)
let combine_buffered_and_direct = 
  fun (direct : Map Uint128 Uint128) =>
    fun (buffered : Map Uint128 Uint128) =>
      fun(result : Map Uint128 Uint128) => 
        fun(k : Uint128) =>
          let m = builtin sub k uint128_one in
           (* if it takes effect from this cycle, then it must be deposited in last cycle *)
          let direct_o = builtin get direct k in
          let buffered_o = builtin get buffered m in
          match direct_o with
          | Some direct_amount =>
            match buffered_o with
            | Some buffered_amount =>
              let amount = builtin add direct_amount buffered_amount in 
              builtin put result k amount
            | None =>
              builtin put result k direct_amount
            end
          | None =>
            match buffered_o with
            | Some buffered_amount =>
              builtin put result k buffered_amount 
            | None =>
              result
            end
          end

let calculate_rewards_per_cycle_for_delegator = 
  fun (delegator : ByStr20) =>
  fun (staking_per_cycle_for_delegator : Map Uint128 Uint128) =>
    fun (staking_and_rewards_per_cycle_for_ssn : Map Uint128 SSNCycleInfo) =>
      (* record rewards should be sent per cycle for delegator *)
      fun (result_map : Map Uint128 DelegatorAndRewards) => 
        fun (cycle : Uint128) =>
          let staking_per_cycle_for_delegator_o = builtin get staking_per_cycle_for_delegator cycle in
          let staking_and_rewards_per_cycle_for_ssn_o = builtin get staking_and_rewards_per_cycle_for_ssn cycle in
          match staking_per_cycle_for_delegator_o with
          | Some staking_of_delegator =>
            match staking_and_rewards_per_cycle_for_ssn_o with
            | Some staking_and_rewards_of_ssn_adt =>
              match staking_and_rewards_of_ssn_adt with
              | SSNCycleInfo total_staking total_rewards =>
                let reward_tmp = builtin mul total_rewards staking_of_delegator in
                let reward_tmp = builtin div reward_tmp total_staking in
                let delegator_and_rewards = DelegatorAndRewards delegator reward_tmp in
                builtin put result_map cycle delegator_and_rewards
              end
            | None => result_map
            end
          | None => result_map
          end

  let deposit_value_or_empty = 
    fun (optional_value : Option (Map Uint128 Uint128)) =>
      match optional_value with
      | Some value => value
      | None =>  Emp Uint128 Uint128
      end

  let block_or_zero = 
    fun (optional_value : Option Uint128) =>
      match optional_value with
      | Some value => value
      | None => uint128_zero
      end
          

let bool_active = True
let bool_inactive = False
let uint128_10_power_7 = Uint128 10000000
let empty_tag = ""
let multisig_tag_addfunds = "AddFunds"


(* errors and events *)
let mk_contract_frozen_error =
  fun (sender : ByStr20) =>
    { _exception : "Contract freezed failure"; sender : sender }

let mk_verifier_validation_failed_error =
  fun (sender : ByStr20) =>
    { _exception : "Verifier validation failed"; sender : sender }

let mk_admin_validation_failed_error =
  fun (sender : ByStr20) =>
    { _exception : "Admin validation failed"; sender : sender }

let mk_proxy_validation_failed_error =
  fun (sender : ByStr20) =>
    { _exception : "Proxy validation failed"; sender : sender }

let mk_delegator_existence_failed_error =
    fun (ssn : ByStr20) =>
    fun (delegator : ByStr20) =>
      { _exception : "Delegator does not exist at SSN"; delegator : delegator; ssn : ssn}

let mk_stake_deposit_below_min_for_ssn_error =
      fun (ssn : ByStr20) =>
      fun (delegator : ByStr20) =>
      fun (amount : Uint128) =>
        { _exception : "Delegator stake deposit below min_stake for this SSN"; delegator : delegator; ssn : ssn; stake : amount}
        
        
let mk_update_staking_parameter_error =
  fun (sender : ByStr20) =>
  fun (min_stake : Uint128) =>
  fun (max_stake : Uint128) =>
  fun (contract_max_stake : Uint128) =>
    { _exception : "Update staking parameter error"; sender : sender; min_stake : min_stake; max_stake : max_stake; contract_max_stake : contract_max_stake }

 
let mk_delegator_has_buffered_deposit_error = 
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _exception : "Delegator still has buffered deposit"; ssn_address : ssn; delegator_address : delegator }

let mk_change_commission_error = 
  fun (ssn : ByStr20) =>
    { _exception: "SSN has already set a commission for this cycle"; ssn_address : ssn}
    

let mk_ssn_already_exists_event =
  fun (ssn : ByStr20) =>
    { _eventname : "SSN already exists"; ssn_address : ssn }

let mk_delegator_already_exists_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator already exists"; ssn_address : ssn; delegator_address : delegator }

let mk_ssn_added_event =
  fun (ssn : ByStr20) =>
    { _eventname : "SSN added"; ssn_address : ssn }

let mk_delegator_added_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator added"; ssn_address : ssn; delegator_address : delegator }

let mk_ssn_not_exists_event =
  fun (ssn : ByStr20) =>
    { _eventname : "SSN doesn't exist"; ssn_address : ssn }

let mk_delegator_not_exists_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator doesn't exist"; ssn_address : ssn; delegator_address : delegator}

let mk_ssn_removed_event =
  fun (ssn : ByStr20) =>
    { _eventname : "SSN removed"; ssn_address : ssn }

let mk_delegator_removed_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator removed"; ssn_address : ssn; delegator_address : delegator}

let mk_stake_deposit_event =
  fun (ssn : ByStr20) =>
  fun (amount : Uint128) =>
    { _eventname : "SSN updated stake"; ssn_address : ssn; new_stake_amount : amount }

let mk_delegate_stake_deposit_event =
    fun (ssn : ByStr20) =>
    fun (delegator : ByStr20) =>
    fun (amount : Uint128) =>
      { _eventname : "Stake Delegated"; ssn_address : ssn; delegator : delegator; stake_amount : amount }

let mk_stake_deposit_below_stake_limit_event =
  fun (ssn : ByStr20) =>
  fun (amount : Uint128) =>
  fun (minstake : Uint128) =>
    { _eventname : "SSN stake deposit below min_stake limit"; ssn_address : ssn; requested_deposit : amount; min_stake : minstake }

let mk_stake_deposit_above_stake_limit_event =
  fun (ssn : ByStr20) =>
  fun (amount : Uint128) =>
  fun (maxstake : Uint128) =>
    { _eventname : "SSN stake deposit above max_stake limit"; ssn_address : ssn; requested_deposit : amount; max_stake : maxstake }

let mk_delegated_stake_deposit_above_stake_limit_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
  fun (amount : Uint128) =>
  fun (maxstake : Uint128) =>
    { _eventname : "Delegator stake deposit above max_stake limit"; ssn_address : ssn; delegator_address : delegator; requested_deposit : amount; max_stake : maxstake }

let mk_total_stake_deposit_above_contract_stake_limit_event =
  fun (ssn : ByStr20) =>
  fun (amount : Uint128) =>
  fun (contractmaxstake : Uint128) =>
    { _eventname : "SSN stake deposit will result in contract stake deposit go above limit"; ssn_address : ssn; requested_deposit : amount; contract_max_stake : contractmaxstake }

let mk_delegator_no_withdraw_record_event = 
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator no withdraw record"; ssn_address : ssn; delegator_address : delegator }

let mk_delegator_withdraw_rewards_event = 
  fun (ssn: ByStr20) =>
  fun (delegator : ByStr20) => 
  fun (amount : Uint128) =>
    { _eventname : "Delegator withdraw rewards"; ssn_address : ssn; delegator_address : delegator; rewards_amount : amount }

let mk_delegator_withdraw_deposit_amount_event = 
  fun (ssn: ByStr20) =>
  fun (delegator: ByStr20) =>
  fun (amount: Uint128) =>
    { _eventname : "Delegator withdraw deposit"; ssn_address : ssn; delegator_address : delegator; deposit_amount : amount }


let mk_delegator_rewards_event = 
  fun (ssn : ByStr20) => 
  fun (delegator : ByStr20) =>
  fun (rewards : Uint128) =>
    { _eventname : "Delegator rewards"; ssn_address : ssn; delegator_address : delegator; rewards : rewards}

let mk_delegator_withdraw_all_event = 
  fun (ssn : ByStr20) =>
    fun (delegator : ByStr20) =>
      { _eventname : "Delegator withdraws entire amount"; ssn_address : ssn; delegator_address : delegator}


let mk_update_delegate_cycle_event = 
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator update cycle"; ssn_address : ssn; delegator_address : delegator }

let mk_assign_stake_reward_event =
  fun (ssn : ByStr20) =>
  fun (total_reward : Uint128) =>
    { _eventname : "SSN assign reward"; ssn_address : ssn; total_reward : total_reward }

let mk_withdraw_stake_rewards_event =
  fun (ssn : ByStr20) =>
  fun (total_reward: Uint128) =>
    { _eventname : "SSN withdraw reward"; ssn_address : ssn; withdraw_total_reward : total_reward }

 let mk_deposit_funds_event =
  fun (sender : ByStr20) =>
    { _eventname : "Verifier deposit funds"; verifier : sender }

 let mk_withdraw_below_stake_limit_event =
    fun (ssn : ByStr20) =>
    fun (minstake: Uint128) =>
      { _eventname : "SSN withdrawal below min_stake limit"; ssn_address : ssn; minstake_limit : minstake }

 let mk_withdraw_above_stake_event =
    fun (ssn : ByStr20) =>
      { _eventname : "SSN withdrawal above stake"; ssn_address : ssn }

 let mk_withdraw_stake_buffered_deposit_exist =
    fun (ssn : ByStr20) =>
    fun (buffdeposit: Uint128) =>
      { _eventname : "SSN withdrawal not allowed when some deposit is bufferred"; ssn_address : ssn; buffered_stake_amount : buffdeposit }
      
 let mk_update_staking_parameter_event =
    fun (sender : ByStr20) =>
      { _eventname : "Update staking parameter event"; sender : sender}

 let mk_send_delegator_rewards_event = 
    fun (address : ByStr20) =>
    fun (amount : Uint128) =>
      { _eventname : "Send delegator rewards event"; address : address; amount :  amount}



(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract SSNList(
  init_admin : ByStr20,
  proxy_address : ByStr20
)


(* Keeps track of SSNS *)
(* AddressOfSSN -> SSNInfo *)
field ssnlist : Map ByStr20 Ssn = Emp ByStr20 Ssn

(* Keeps track of the delegators for each SSN.*)
(* AddressOfSSN -> (AddressOfDelegator -> DelegatorInfo) *)
field delegators : Map ByStr20 (Map ByStr20 Delegator) = Emp ByStr20 (Map ByStr20 Delegator)

(* Keeps track of stakes deposited at SSNs *)
(* AddressOfSSN -> (RewardCycleNumber -> Pair (TotalStakeDuringTheCycleForSSN, TotalRewardEarnedDuringTheCycle) *)
field stakeSSNPerCyle : Map ByStr20 (Map Uint128 SSNCycleInfo) = Emp ByStr20 (Map Uint128 SSNCycleInfo)

(* Keeps track of the cycle number when a delegator last withdrew its rewards *)
(* AddressOfDelegator -> ( AddressOfSSN -> CycleNumberWhenLastWithdrawn) *)
field lastWithdrawCycleForDelegator : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(* Keeps track of buffered deposit for a delegator *)
(* AddressOfDelegator -> (AddressofSSN -> (RewardCycleNumber -> BufferedStakeAmountDuringTheCycle)) *)
(* The BufferedStakeAmount will only be truely delegated at next cycle *)
field bufferedDepositForDelegator : Map ByStr20 (Map ByStr20 (Map Uint128 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint128 Uint128))

(* Keeps track of stake deposits for a deleator that can be considered for reward calcuation *)
(* AddressofDelegator -> (AddressofSSN -> (RewardCycleNumber -> StakeAmount)) *)
field directDepositForDelegator : Map ByStr20 (Map ByStr20 (Map Uint128 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint128 Uint128))

(* Record deposit amount for every delegator for every ssn *)
(* AddressofDelegator -> (AddressofSSN -> StakeAmount) *)
field depositAmountForDelegator : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(* Record commission for ssn of every cycle*)
(* AddressofSSN -> (Cycle -> commission ) *)
field commissionForSSN : Map ByStr20 (Map Uint128 Uint128) = Emp ByStr20 (Map Uint128 Uint128)

(* TODO Let's assume that rewardCylce is a counter. This counter gets increased everytime reward is added by the verifer.
   This should simplify some of the contract logic. 
*)

field rewardCycleList : List Uint128   =  Nil {Uint128} 

field verifier : Option ByStr20 = None {ByStr20}
field minstake : Uint128 = Uint128 0
field maxstake : Uint128 = Uint128 0
field contractmaxstake : Uint128 = Uint128 0

(* In case of contract upgrade, this field is indirectly updated when SSNs are added *)
field totalstakedeposit : Uint128 = Uint128 0

field contractadmin : ByStr20  = init_admin
field lastrewardcycle : Uint128 = Uint128 0
field paused : Bool = True

(* Procedures *)

(* Check if the initiator is verifier *)
procedure CallerIsVerifier (initiator : ByStr20)
  verifier_l <- verifier;
  match verifier_l with
  | Some v =>
    is_verifier = builtin eq initiator v;
    match is_verifier with
    | True =>
    | False =>
      e = mk_verifier_validation_failed_error initiator;
      throw e
    end
  | None =>
    e = mk_admin_validation_failed_error initiator;
    throw e
  end
end

(* Check if the initiator is admin *)
procedure CallerIsAdmin(initiator : ByStr20)
  contractadmin_l <- contractadmin;
  is_admin = builtin eq initiator contractadmin_l;
  match is_admin with
  | True  => 
  | False =>
    e = mk_admin_validation_failed_error initiator;
    throw e
  end
end

(* Check if the caller is the proxy *)
procedure CallerIsProxy()
  is_proxy = builtin eq _sender proxy_address;
  match is_proxy with
  | True  =>
  | False =>
    e = mk_proxy_validation_failed_error _sender;
    throw e
  end
end

(* Check if the contract is paused *)
procedure IsPaused()
  paused_l <- paused;
  match paused_l with
  | False =>
  | True  =>
    e = mk_contract_frozen_error _sender;
    throw e
  end
end

(* Can be called by the contract admin only *)
(* It is expected that transfer only happens to an exterally owned account*)
procedure TransferFunds(tag: String, amount : Uint128, recipient : ByStr20)
    msg = {_tag : tag; _recipient : recipient; _amount : amount};
    msgs = one_msg msg;
    send msgs
end


procedure UpdateStakeReward(entry : SsnRewardShare)
  lastreward_block <- lastrewardcycle;
  match entry with
  | SsnRewardShare ssnaddr reward_percent =>
    curval <- ssnlist[ssnaddr];
    match curval with
    | None =>
      e = mk_ssn_not_exists_event ssnaddr;
      event e
    | Some (Ssn active_status stake_amount rewards name urlraw urlapi buffereddeposit commission commission_rewards received_address) =>
      match active_status with
      | False => throw
      | True  => 
        hundred = Uint128 100;

        new_reward = builtin mul stake_amount reward_percent;
        new_reward = builtin div new_reward hundred;
        new_reward = builtin div new_reward uint128_10_power_7;
       
        reward_commission_tmp = builtin mul new_reward commission;
        reward_commission_tmp = builtin div reward_commission_tmp hundred;
        reward_commission_tmp = builtin div reward_commission_tmp uint128_10_power_7;
        total_reward_commission = builtin add reward_commission_tmp commission_rewards;


        reward_should_be_given = builtin sub new_reward total_reward_commission;
        delegator_reward = builtin add reward_should_be_given rewards;

        new_stake_amount = builtin add stake_amount buffereddeposit;
        (* During this cylce, the SSN only earned t as rewards that could be given to delegators *)
        p = SSNCycleInfo stake_amount reward_should_be_given;
        stakeSSNPerCyle[ssnaddr][lastreward_block] := p;

        ssn = Ssn active_status new_stake_amount delegator_reward name urlraw urlapi uint128_zero commission total_reward_commission received_address;
        ssnlist[ssnaddr] := ssn;
        e = mk_assign_stake_reward_event ssnaddr total_reward_commission;
        event e
      end
    end
  end
end

(* this procedure is to send rewards to delegator for every reward cycle *)
procedure send_delegator_rewards(entry : Pair Uint128 DelegatorAndRewards)
  match entry with
  | Pair cycle delegator_and_rewards  =>
    match delegator_and_rewards with
    | DelegatorAndRewards address amount =>
      TransferFunds multisig_tag_addfunds amount address;
      e = mk_send_delegator_rewards_event address amount;
      event e
    end
  end
end


(* Check if a delegators exists for a given SSN *)
procedure DelegatorExists(ssnaddr: ByStr20, delegator: ByStr20)
  if_exists <- exists delegators[ssnaddr][delegator];
  match if_exists with
  | True  =>
  | False => 
    e = mk_delegator_existence_failed_error delegator ssnaddr;  
    throw e
    end
end

procedure FillInDelegatorAmount(ssnaddr: ByStr20, delegator: ByStr20)
  deposit_amount <- depositAmountForDelegator[delegator][ssnaddr];
  match deposit_amount with
  | Some amount =>
    new_amount = builtin add amount _amount;
    depositAmountForDelegator[delegator][ssnaddr] := new_amount
  | None =>
    depositAmountForDelegator[delegator][ssnaddr] := _amount
  end
end

procedure FillInDelegators(ssnaddr: ByStr20, delegator: ByStr20)
  d <- delegators[ssnaddr][delegator];
  match d with
  | Some (Delegator amount reward) =>
    new_amount_delegator = builtin add _amount amount;
    d_new = Delegator new_amount_delegator reward;
    delegators[ssnaddr][delegator] := d_new
  | None =>
    d_new = Delegator _amount uint128_zero;
    delegators[ssnaddr][delegator] := d_new
  end
end

procedure HasRewardToWithdraw(ssnaddr: ByStr20, delegator: ByStr20)
  last_reward_cycle_for_delegator_o <- lastWithdrawCycleForDelegator[delegator][ssnaddr];
  last_reward_cycle_for_delegator = block_or_zero last_reward_cycle_for_delegator_o;
  last_reward_cycle <- lastrewardcycle;
  has_reward = builtin lt last_reward_cycle_for_delegator last_reward_cycle;
  match has_reward with
  | True =>
    throw
  | False =>
  end
  
  
end

(*TODO  We neeed to be careful with this one *)
(* Should we just remove it? *)
procedure MeetMinimumDelegateAmount(ssnaddr : ByStr20, initiator: ByStr20, minimum_delegate_amount: Uint128)
  d <- delegators[ssnaddr][initiator];
  match d with
  | Some (Delegator amount reward) =>
    new_amount = builtin add amount _amount;
    pass = builtin lt new_amount minimum_delegate_amount;
    match pass with
    | True =>
      e = mk_stake_deposit_below_min_for_ssn_error ssnaddr initiator _amount;
      throw e
    | False =>
    end
  | None =>
    pass = builtin lt _amount minimum_delegate_amount;
    match pass with
    | True =>
      e = mk_stake_deposit_below_min_for_ssn_error ssnaddr initiator _amount;
      throw e
    | False =>
    end
  end
end


(* Transitions *)

(* @dev: pause the contract. Used by admin only. *)
(* @param initiator: The original caller who called the proxy. *)
transition Pause(initiator: ByStr20)
  CallerIsProxy;
  CallerIsAdmin initiator;
  paused := bool_active
end

(* @dev: unpause/unfreeze the contract. Used by admin only. *)
(* @param initiator: The original caller who called the proxy. *)
transition UnPause(initiator: ByStr20)
  CallerIsProxy;
  CallerIsAdmin initiator;
  paused := bool_inactive
end

(* @dev: Set the admin of the contract. Used by admin only. *)
(* @param admin: New admin value *)
(* @param initiator: The original caller who called the proxy. *)
transition UpdateAdmin(admin : ByStr20, initiator: ByStr20)
  CallerIsProxy;
  CallerIsAdmin initiator;
  contractadmin := admin
end

(* @dev: Set the verifier of the contract. Used by admin only. *)
(* @param verif: New verifier value *)
(* @param initiator: The original caller who called the proxy *)
transition UpdateVerifier(verif : ByStr20, initiator: ByStr20)
  CallerIsProxy;
  CallerIsAdmin initiator;
  newverifier = Some {ByStr20} verif;
  verifier := newverifier
end

(* @dev: Drain the entire contract's balance. Used by current admin only in case of emergency. *)
(* @param initiator: The original caller who called the proxy *)
transition DrainContractBalance(initiator : ByStr20, amount : Uint128)
  CallerIsProxy;
  CallerIsAdmin initiator;
  bal <- _balance;
  less_than = builtin lt bal amount;
  match less_than with
  | True => throw
  | False => 
    TransferFunds multisig_tag_addfunds amount initiator
  end
end

(* @dev: Set the staking parameters of contract. Used by admin only. *)
(* @param min_stake: New minstake value *)
(* @param max_stake: New maxstake value *)
(* @param contract_max_stake: New contract maxstake value *)
(* @param initiator: The original caller who called the proxy *)
transition update_staking_parameter (min_stake : Uint128, max_stake : Uint128, contract_max_stake : Uint128, initiator : ByStr20)
  CallerIsProxy;
  CallerIsProxy;
  CallerIsAdmin initiator;
  min_less_than_max = builtin lt min_stake max_stake;
  match min_less_than_max with
  | True =>
    max_less_than_contract_max = builtin lt max_stake contract_max_stake;
    match max_less_than_contract_max with
    | True =>
      minstake := min_stake;
      maxstake := max_stake;
      contractmaxstake := contract_max_stake;
      e = mk_update_staking_parameter_event initiator;
      event e
    | False =>
      e = mk_update_staking_parameter_error initiator min_stake max_stake contract_max_stake;
      throw e
    end
  | False =>
     e = mk_update_staking_parameter_error initiator min_stake max_stake contract_max_stake;
     throw e
  end

end


(* @dev   Adds new ssn to ssnlist. Used by admin only. *)
(* @param ssnaddr: Address of the ssn to be added *)
(* @param stake_amount: Stake amount of ssn *)
(* @param rewards: Rewards of the ssn to be added *)
(* @param name: Human readable name *)
(* @param urlraw: string representing "ip:port" of the ssn serving raw api request *)
(* @param urlapi: string representing url exposed by ssn serving public api request *)
(* @param buffered_deposit: Any buffered stake deposit *)
(* @param commission: Percentage of incoming rewards that the SSN takes *)
(* @param commission_rewards: Number of ZILs earned as commission *)
(* @param minimum_delegate_amount: Minimum nb. of ZILs required for delegation *)
(* @param received_address: Address that will be used to receive commission *)
(* @param initiator: The original caller who called the proxy *)
transition AddSSN(ssnaddr : ByStr20, stake_amount : Uint128, rewards : Uint128, name : String, urlraw : String, urlapi : String, buffered_deposit : Uint128,  commission : Uint128, commission_rewards : Uint128, minimum_delegate_amount : Uint128, received_address : ByStr20, initiator : ByStr20)
  IsPaused;
  CallerIsProxy;
  CallerIsAdmin initiator;
  already_exists <- exists ssnlist[ssnaddr];
  match already_exists with
  | True  =>
    e = mk_ssn_already_exists_event ssnaddr;
    event e
  | False =>
    minstake_l <- minstake;
    maxstake_l <- maxstake;
    total_amount = builtin add stake_amount buffered_deposit;
    pass = builtin lt maxstake_l total_amount;
    match pass with
    | True  =>         
      e = mk_stake_deposit_above_stake_limit_event ssnaddr stake_amount maxstake_l;
      event e
    | False =>
      status = builtin lt minstake_l stake_amount;
      (* Update the total stake deposit *)
      totalstakedeposit_l <- totalstakedeposit;
      totalstakedeposit_l = builtin add totalstakedeposit_l stake_amount;
      totalstakedeposit := totalstakedeposit_l;
      s = Ssn status stake_amount rewards name urlraw urlapi buffered_deposit commission commission_rewards received_address;
      ssnlist[ssnaddr] := s;
      last_reward_cycle <- lastrewardcycle;
      commissionForSSN[ssnaddr][last_reward_cycle] := commission;
      e = mk_ssn_added_event ssnaddr;
      event e
    end
  end
end

(* @dev: Adds a new delegator. Used by admin only during contract upgrade. *)
(* @param ssnaddr: Address of the ssn *)
(* @param delegator: Address of the delegator *)
(* @param stake_amount: Stake amount *)
(* @param rewards: Rewards of the ssn to be added *)
(* @param initiator: The original caller who called the proxy *)
(* TODO This could be expensive *)
(* TODO Missing check on the minimum stake amount *)
transition AddDelegator(ssnaddr : ByStr20, delegator : ByStr20, stake_amount : Uint128, rewards : Uint128, initiator : ByStr20)
  IsPaused;
  CallerIsProxy;
  CallerIsAdmin initiator;
  already_exists <- exists delegators[ssnaddr][delegator];
  match already_exists with
  | True =>
    e = mk_delegator_already_exists_event ssnaddr delegator;
    event e
  | False =>
    d = Delegator stake_amount rewards;
    delegators[ssnaddr][delegator] := d;
    e = mk_delegator_added_event ssnaddr delegator;
    event e
  end
end

(* @dev: Remove a specific ssn from ssnlist. Used by admin only. *)
(* @param ssnaddr: Address of the ssn to be removed *)
(* @param initiator: The original caller who called the proxy *)
transition RemoveSSN(ssnaddr : ByStr20, initiator: ByStr20)
  IsPaused;
  CallerIsProxy;
  CallerIsAdmin initiator;
  already_exists <- exists ssnlist[ssnaddr];
  match already_exists with
  | False =>
    e = mk_ssn_not_exists_event ssnaddr;
    event e
  | True =>
    delete ssnlist[ssnaddr];
    delete commissionForSSN[ssnaddr];
    e = mk_ssn_removed_event ssnaddr;
    event e
  end
end

(* @dev: Remove a specific delegator for a given SSN. Used by admin only. *)
(* @param ssnaddr: Address of the ssn *)
(* @param delegator: Address of the delegator to be removed *)
(* @param initiator: The original caller who called the proxy *)
transition RemoveDelegator(ssnaddr : ByStr20, delegator : ByStr20, initiator: ByStr20)
  IsPaused;
  CallerIsProxy;
  CallerIsAdmin initiator;
  already_exists <- exists delegators[ssnaddr][delegator];
  match already_exists with
  | False =>
    e = mk_delegator_not_exists_event ssnaddr delegator;
    event e
  | True =>
    delete delegators[ssnaddr][delegator];
    delete depositAmountForDelegator[delegator][ssnaddr];
    e = mk_delegator_removed_event ssnaddr delegator;
    event e
  end
end

(* @dev : To update the commision rate for a given SSN *)
(* @param new_rate: The new commision rate *)
(* @param initiator: The original caller who called the proxy. This is SSN address. *)
transition UpdateCommission(new_rate : Uint128, initiator : ByStr20)
  IsPaused;
  CallerIsProxy;
  curval <- ssnlist[initiator];
  match curval with
  | Some (Ssn active_status stake_amount rewards name urlraw urlapi buffereddeposit commission commision_rewards received_address) =>
    last_reward_cycle <- lastrewardcycle;
    old_commission_o <- commissionForSSN[initiator][last_reward_cycle];
    match old_commission_o with
    | Some old_commission =>
      e = mk_change_commission_error initiator;
      throw e
    | None =>
      commissionForSSN[initiator][last_reward_cycle] := commission;
      ssn =  Ssn active_status stake_amount rewards name urlraw urlapi buffereddeposit new_rate commision_rewards received_address;
      ssnlist[initiator] := ssn
    end
  | None =>
    e = mk_ssn_not_exists_event initiator;
    event e
  end
end

(* @dev : To update the received address for a given SSN *)
(* @param new_address: The new received address *)
(* @param initiator: The original caller who called the proxy. This is SSN address. *)
transition UpdateReceivedAddress(new_address : ByStr20, initiator : ByStr20)
  IsPaused;
  CallerIsProxy;
  curval <- ssnlist[initiator];
  match curval with
  | Some (Ssn active_status stake_amount rewards name urlraw urlapi buffereddeposit commission commision_rewards received_address) =>
    ssn =  Ssn active_status stake_amount rewards name urlraw urlapi buffereddeposit commission commision_rewards new_address;
    ssnlist[initiator] := ssn
  | None =>
    e = mk_ssn_not_exists_event initiator;
    event e
  end
end

(* @dev : To delegate the stake to the contract. *)
(* @param ssnaddr: The address of the SSN to which the delegator wants to stake *)
(* @param initiator: The original caller who called the proxy aka the delegator. *)
transition DelegateStake(ssnaddr : ByStr20, initiator: ByStr20)
  IsPaused;
  CallerIsProxy;
  (* Accept the deposit from SSN and add to contract balance. *)
  (* Transfer back to initiator if any of the validation failed *)
  accept;
  curval <- ssnlist[ssnaddr];
  match curval with
  | None =>
    TransferFunds empty_tag _amount initiator;
    e = mk_ssn_not_exists_event initiator;
    event e
  | Some (Ssn active_status stake_amount rewards name urlraw urlapi buffereddeposit commission commision_rewards received_address) =>
    minstake_l <- minstake;
    maxstake_l <- maxstake;
    new_buff_amount  = builtin add _amount buffereddeposit;
    new_stake_amount = builtin add new_buff_amount stake_amount;
    pass = builtin lt maxstake_l new_stake_amount;
    match pass with
    | True  => (* stake deposit above maxstake limit for SSNs *)
      TransferFunds multisig_tag_addfunds _amount initiator;
      e = mk_delegated_stake_deposit_above_stake_limit_event ssnaddr initiator _amount maxstake_l;
      event e
    | False => 
      last_reward_cycle <- lastrewardcycle;
      (*The delegated stake can be accepted. It is buffered if the SSN is active if not it is added to the stake_amount. *)
      FillInDelegatorAmount ssnaddr initiator;
      FillInDelegators ssnaddr initiator;
      match active_status with
      | True  => 
        (* The SSN is active so add the delegated stake to the buffer *)
        ssn = Ssn bool_active stake_amount rewards name urlraw urlapi new_buff_amount commission commision_rewards received_address;
        ssnlist[ssnaddr] := ssn;
        (* record this to buffer deposit for delegator *)
        stake_amount_for_delegator_o <- bufferedDepositForDelegator[initiator][ssnaddr][last_reward_cycle];
        match stake_amount_for_delegator_o with
        | Some stake_amount_for_delegator =>
          new_stake_amount_for_delegator = builtin add stake_amount_for_delegator _amount;
          bufferedDepositForDelegator[initiator][ssnaddr][last_reward_cycle] := new_stake_amount_for_delegator
        | None =>
          bufferedDepositForDelegator[initiator][ssnaddr][last_reward_cycle] := _amount
        end
      | False =>
        (* The SSN is inactive so add the delegated stake to stake_amount *)
        new_stake_amount  = builtin add _amount stake_amount;
        status = builtin lt minstake_l new_stake_amount;
        (* The SSN becomes active if the total stake after deposit is greater than the minimum required. *)
        ssn = Ssn status new_stake_amount rewards name urlraw urlapi buffereddeposit commission commision_rewards received_address;
        ssnlist[ssnaddr] := ssn;
        d <- delegators[ssnaddr][initiator];
        (* record this to direct deposit for delegator *)
        stake_amount_for_delegator_o <- directDepositForDelegator[initiator][ssnaddr][last_reward_cycle];
        match stake_amount_for_delegator_o with
          | Some stake_amount_for_delegator =>
            new_stake_amount_for_delegator = builtin add stake_amount_for_delegator _amount;
            directDepositForDelegator[initiator][ssnaddr][last_reward_cycle] := new_stake_amount_for_delegator
          | None =>
            directDepositForDelegator[initiator][ssnaddr][last_reward_cycle] := _amount
        end
      end
    end
  end
end

(* @dev: Assign stake reward to all ssn from ssnlist. Used by verifier only. *)
(* @param ssnrewardlist: List of SsnRewardShare *)
(* @param initiator: The original caller who called the proxy *)
transition AssignStakeReward(ssnreward_list : List SsnRewardShare, initiator: ByStr20)
  IsPaused;
  CallerIsProxy;
  CallerIsVerifier initiator;
  last_reward_cycle <- lastrewardcycle;
  forall ssnreward_list UpdateStakeReward;
  newLastRewardCycleNum = builtin add uint128_one last_reward_cycle;
  lastrewardcycle := newLastRewardCycleNum;
  reward_cycle_list <- rewardCycleList;
  new_reward_cycle_list = Cons {Uint128} newLastRewardCycleNum reward_cycle_list;
  rewardCycleList := new_reward_cycle_list
end


transition WithdrawCommission(initiator : ByStr20)
  IsPaused;
  CallerIsProxy;
  curval <- ssnlist[initiator];
  match curval with
  | None =>
    e = mk_ssn_not_exists_event initiator;
    event e
  | Some (Ssn active_status stake_amount rewards name urlraw urlapi buffereddeposit commission commission_rewards received_address) =>
    TransferFunds multisig_tag_addfunds commission_rewards received_address;
    e = mk_withdraw_stake_rewards_event initiator rewards;
    event e;  
    ssn = Ssn active_status stake_amount rewards name urlraw urlapi buffereddeposit commission uint128_zero received_address;
    ssnlist[initiator] := ssn
  end
end



(* @dev: Withdraw stake reward. Can be called by a delegator. *)
(* @param initiator: The original caller who called the proxy *)
transition WithdrawStakeRewards(ssn_operator: ByStr20, delegator: ByStr20)
  IsPaused;
  CallerIsProxy;
  DelegatorExists ssn_operator delegator;
  lastWithdrawCycleForDelegator_m <- lastWithdrawCycleForDelegator[delegator][ssn_operator];
  last_withdraw_cycle = block_or_zero lastWithdrawCycleForDelegator_m;
  last_reward_cycle <- lastrewardcycle;
  reward_cycle_list <- rewardCycleList;
  list_between_fun = list_between last_withdraw_cycle last_reward_cycle;
  list_between_fun_uint128 = @list_filter Uint128;

  (* those are the cycles that we want to compute for computing rewards *)
  list_need_compute_rewards = list_between_fun_uint128 list_between_fun reward_cycle_list;

  (* direct deposit *)
  directDepositForDelegator_m <- directDepositForDelegator[delegator][ssn_operator];
  direct_deposits_for_delegator = deposit_value_or_empty directDepositForDelegator_m;

  (* buffered deposit *)
  bufferedDepositForDelegator_m <- bufferedDepositForDelegator[delegator][ssn_operator];
  buffered_deposits_for_delegator = deposit_value_or_empty bufferedDepositForDelegator_m;

  (* combine two deposit list *)
  init_map = Emp Uint128 Uint128;
  foldl = @list_foldl Uint128 Map Uint128 Uint128;
  staking_init_map = Emp Uint128 Uint128;
  iter = combine_buffered_and_direct direct_deposits_for_delegator buffered_deposits_for_delegator;
  combined_direct_and_buffered_map = foldl iter init_map list_need_compute_rewards;


  (* to calculate final staking per cycle for delegators *)
  iter = caculate_all_stake_per_cycle combined_direct_and_buffered_map;
  stake_delegator_per_cycle = foldl iter staking_init_map list_need_compute_rewards;

  stake_ssn_per_cycle_m <- stakeSSNPerCyle[ssn_operator];
  match stake_ssn_per_cycle_m with 
  | Some stake_ssn_per_cycle =>
    (* to calculate staking rewards per cycle for delegator *)
    reward_per_cycle_for_delegator_init = Emp Uint128 DelegatorAndRewards;
    foldl_a = @list_foldl Uint128 Map Uint128 DelegatorAndRewards;
    calculate_rewards_per_cycle_for_delegator_iter = calculate_rewards_per_cycle_for_delegator delegator stake_delegator_per_cycle stake_ssn_per_cycle;
    rewards_delegator_per_cycle = foldl_a calculate_rewards_per_cycle_for_delegator_iter reward_per_cycle_for_delegator_init list_need_compute_rewards;

    (* to send those rewards and update last withdraw cycle of delegator *)
    rewards_delegator_per_cycle_list = builtin to_list rewards_delegator_per_cycle;
    forall rewards_delegator_per_cycle_list send_delegator_rewards;
    lastWithdrawCycleForDelegator[delegator][ssn_operator] := last_reward_cycle;
    (* TODO do we have to do soemthing with Delegators map? *)
    (* TODO Should we do something with ssn map here? *)
    (* No and No *)
    e = mk_update_delegate_cycle_event ssn_operator delegator;
    event e
  | None => (* ssn has no rewards *)
  end    
end

(* @dev: Withdraw all amount owed by the contract. Used by delegators. *)
(* @param ssn: Address of the SSN to which stake had been delegated. *)
(* @param initiator: The original caller who called the proxy. *)
(* @note: Withdraws stake + buffer + reward in one go. *)
(* TODO Redo this *)
(* Xiaohuo: its not easy to send all in one, but I just do withdraw stake amount there *)
(* to withdraw deposit amount, there is no deposit still in buffer, and all rewards should be withdrawn already *)
transition WithdrawStakeAmount(ssn: ByStr20, initiator: ByStr20)
  IsPaused;
  CallerIsProxy;
  delegator <- delegators[ssn][initiator];
  last_reward_cycle <- lastrewardcycle;
  ssn_o <- ssnlist[ssn];
  match delegator with
  | Some (Delegator amount reward) =>
    (* first we need to make sure there is no deposit within buffered stake *)
    has_buffered_value <- bufferedDepositForDelegator[initiator][ssn][last_reward_cycle];
    match has_buffered_value with
    | Some value => throw
    | None =>
      HasRewardToWithdraw ssn initiator;
      deposit_amount_o <- depositAmountForDelegator[initiator][ssn];
      match deposit_amount_o with
      | Some deposit_amount =>
        delete bufferedDepositForDelegator[initiator][ssn];
        delete directDepositForDelegator[initiator][ssn];
        delete depositAmountForDelegator[initiator][ssn];
        delete lastWithdrawCycleForDelegator[initiator][ssn];
        match ssn_o with
        | Some (Ssn active_status stake_amount rewards name urlraw urlapi buffereddeposit commission commision_rewards received_address) =>
          new_amount = builtin sub stake_amount deposit_amount;
          minstake_l <- minstake;
          status = builtin lt minstake_l new_amount;
          ssn_o = Ssn status new_amount rewards name urlraw urlapi buffereddeposit commission commision_rewards received_address;
          ssnlist[ssn] := ssn_o;
          new_amount_for_delegator = builtin sub amount deposit_amount;
          delegator_o = Delegator new_amount_for_delegator reward;
          delegators[ssn][initiator] := delegator_o;
          TransferFunds multisig_tag_addfunds deposit_amount initiator;
          e = mk_delegator_withdraw_deposit_amount_event ssn initiator deposit_amount;
          event e
        | None =>
          e = mk_delegator_has_buffered_deposit_error ssn initiator;
          throw e
        end
      | None =>
        e = mk_ssn_not_exists_event initiator;
        event e
      end
    end
    
  | None => 
    e = mk_delegator_existence_failed_error ssn initiator;
    throw e
  end
end

(* @dev: Move funds from initiator to recipient, i.e., contract address. *)
(* @param initiator: The original caller who called the proxy. *)
transition AddFunds(initiator : ByStr20)
  IsPaused;
  CallerIsProxy;
  accept;
  e = mk_deposit_funds_event initiator;
  event e
end

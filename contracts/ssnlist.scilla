scilla_version 0

import ListUtils

library SSNList

(* AddressofSSN StakeAtThatBlock AddressofDelegator*)
type PairForDelegatorCycle = 
| PairForDelegatorCycle of ByStr20 Uint128 ByStr20


type PairForStakeSSNCycle =
| PairForStakeSSNCycle of Uint128 Uint128

type DelegatorAndRewards = 
| DelegatorAndRewards of ByStr20 Uint128


let one_msg =
  fun (m : Message) =>
    let e = Nil {Message} in
    Cons {Message} m e

let uint32_one = Uint32 1

let uint32_zore = Uint32 0

(* This function help us to tell if current block number need to be reward *)
let reward_filter = 
  fun (lastrewardblock : Uint32) =>
    fun (current_pair : Pair Uint32 PairForDelegatorCycle) => 
        match current_pair with
        | Pair currentblock (PairForDelegatorCycle ssn block delegator) =>
          builtin lt lastrewardblock currentblock
      end

(* left < element <= right *)
(* This function is used for filting out those cycles that need to compute rewards for delegators *)
let list_between =
  fun (left : Uint32) =>
    fun (right : Uint32) =>
      fun (element : Uint32) => 
        let res = builtin lt left element in
        match res with
        | True =>
          let res = builtin lt right element in
          match res with
          | True => False
          | False => True
          end
        | False => False
        end

(* This function is used for calculating the exact amount per cycle for delegators *)
(* Input: [1:1000,2:2000,3:3000] *)
(* [1:1000] => [1:1000,2:2000+1000] => [1:1000,2:3000,3:3000+3000] *)
let caculate_all_stake_per_cycle = 
  fun (delegate_map : Map Uint32 Uint128) => 
    fun (result_map : Map Uint32 Uint128) => 
      fun(k : Uint32) =>
        (* todo please take of here, it's an counter or actual block number? *)
        (* todo we may not want to sub by one if it is actual block number *)
        (* todo use a map to record counter => block number if we have to *)
        let m = builtin sub k uint32_one in
        let result_map_o = builtin get result_map m in 
        let delegate_map_o = builtin get delegate_map k in
        match result_map_o with
        | Some last_amount =>
          match delegate_map_o with
          | Some delegate_amount =>
            let amount = builtin add last_amount delegate_amount in
            builtin put result_map k amount
          | None =>
            builtin put result_map k last_amount
          end
        | None =>
          match delegate_map_o with
          | Some delegate_amount =>
            builtin put result_map k delegate_amount
          | None =>  result_map
          end
        end

(* This function is used for combining direct deposit and buffered deposit into one with correct secquence *)
(* Direct deposit: [1:1000,2:2000:3:3000] *)
(* Buffered deposit: [1:1000,2:2000:3:3000]*)
(* Result deposit: [1:1000,2:2000+1000:3:3000+2000] *)
let combine_buffered_and_direct = 
  fun (direct : Map Uint32 Uint128) =>
    fun (buffered : Map Uint32 Uint128) =>
      fun(result : Map Uint32 Uint128) => 
        fun(k : Uint32) =>
          let m = builtin sub k uint32_one in
           (* if it takes effect from this cycle, then it must be deposited in last cycle *)
          let direct_o = builtin get direct k in
          match direct_o with
          | Some direct_amount => 
            let buffered_o = builtin get buffered m in
            match buffered_o with
            | Some buffered_amount =>
              let amount = builtin add direct_amount buffered_amount in 
              builtin put result k amount
            | None =>
              builtin put result k direct_amount
            end
          | None =>
            let buffered_o =  builtin get buffered m in
            match buffered_o with
            | Some buffered_amount =>
              builtin put result k buffered_amount
            | None =>
              result
            end
          end

let calculate_rewards_per_cycly_for_delegator = 
  fun (delegator : ByStr20) =>
  fun (staking_per_cycle_for_delegator : Map Uint32 Uint128) =>
    fun (staking_and_rewards_per_cycle_for_ssn : Map Uint32 PairForStakeSSNCycle) =>
      (* record rewards should be sent per cycle for delegator *)
      fun (result_map : Map Uint32 DelegatorAndRewards) => 
        fun (cycle : Uint32) =>
          let staking_per_cycle_for_delegator_o = builtin get staking_per_cycle_for_delegator cycle in
          let staking_and_rewards_per_cycle_for_ssn_o = builtin get staking_and_rewards_per_cycle_for_ssn cycle in
          match staking_per_cycle_for_delegator_o with
          | Some staking_of_delegator =>
            match staking_and_rewards_per_cycle_for_ssn_o with
            | Some staking_and_rewards_of_ssn_adt =>
              match staking_and_rewards_of_ssn_adt with
              | PairForStakeSSNCycle total_staking total_rewards =>
                let reward_tmp = builtin mul total_rewards staking_of_delegator in
                let reward_tmp = builtin div reward_tmp total_staking in
                let delegator_and_rewards = DelegatorAndRewards delegator reward_tmp in
                builtin put result_map cycle delegator_and_rewards
              end
            | None => result_map
            end
          | None => result_map
          end

  let deposit_value_or_empty = 
    fun (optional_value : Option (Map Uint32 Uint128)) =>
      match optional_value with
      | Some value => value
      | None =>  Emp Uint32 Uint128
      end
          

let uint128_zero = Uint128 0
let bool_active = True
let bool_inactive = False
let uint128_10_power_7 = Uint128 10000000
let empty_tag = ""
let multisig_tag_addfunds = "AddFunds"
(* events *)

let mk_contract_freezed_error =
  fun (sender : ByStr20) =>
    { _exception : "Contract freezed failure"; sender : sender }

let mk_verifier_validation_failed_error =
  fun (sender : ByStr20) =>
    { _exception : "Verifier validation failed"; sender : sender }

let mk_admin_validation_failed_error =
  fun (sender : ByStr20) =>
    { _exception : "Admin validation failed"; sender : sender }

let mk_proxy_validation_failed_error =
  fun (sender : ByStr20) =>
    { _exception : "Proxy validation failed"; sender : sender }

let mk_ssn_already_exists_event =
  fun (ssn : ByStr20) =>
    { _eventname : "SSN already exists"; ssn_address : ssn }

let mk_delegator_already_exists_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator already exists"; ssn_address : ssn; delegator_address : delegator }

let mk_ssn_added_event =
  fun (ssn : ByStr20) =>
    { _eventname : "SSN added"; ssn_address : ssn }

let mk_delegator_added_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator added"; ssn_address : ssn; delegator_address : delegator }

let mk_ssn_not_exists_event =
  fun (ssn : ByStr20) =>
    { _eventname : "SSN doesn't exist"; ssn_address : ssn }

let mk_delegator_not_exists_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator doesn't exist"; ssn_address : ssn; delegator_address : delegator}

let mk_ssn_removed_event =
  fun (ssn : ByStr20) =>
    { _eventname : "SSN removed"; ssn_address : ssn }

let mk_delegator_removed_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator removed"; ssn_address : ssn; delegator_address : delegator}

let mk_stake_deposit_event =
  fun (ssn : ByStr20) =>
  fun (amount : Uint128) =>
    { _eventname : "SSN updated stake"; ssn_address : ssn; new_stake_amount : amount }

let mk_delegate_stake_deposit_event =
    fun (ssn : ByStr20) =>
    fun (delegator : ByStr20) =>
    fun (amount : Uint128) =>
      { _eventname : "Stake Delegated"; ssn_address : ssn; delegator : delegator; stake_amount : amount }

let mk_stake_deposit_below_stake_limit_event =
  fun (ssn : ByStr20) =>
  fun (amount : Uint128) =>
  fun (minstake : Uint128) =>
    { _eventname : "SSN stake deposit below min_stake limit"; ssn_address : ssn; requested_deposit : amount; min_stake : minstake }

let mk_stake_deposit_above_stake_limit_event =
  fun (ssn : ByStr20) =>
  fun (amount : Uint128) =>
  fun (maxstake : Uint128) =>
    { _eventname : "SSN stake deposit above max_stake limit"; ssn_address : ssn; requested_deposit : amount; max_stake : maxstake }

let mk_delegated_stake_deposit_above_stake_limit_event =
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
  fun (amount : Uint128) =>
  fun (maxstake : Uint128) =>
    { _eventname : "Delegator stake deposit above max_stake limit"; ssn_address : ssn; delegator_address : delegator; requested_deposit : amount; max_stake : maxstake }

let mk_total_stake_deposit_above_contract_stake_limit_event =
  fun (ssn : ByStr20) =>
  fun (amount : Uint128) =>
  fun (contractmaxstake : Uint128) =>
    { _eventname : "SSN stake deposit will result in contract stake deposit go above limit"; ssn_address : ssn; requested_deposit : amount; contract_max_stake : contractmaxstake }

let mk_delegator_no_withdraw_record_event = 
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator no withdraw record"; ssn_address : ssn; delegator_address : delegator }

let mk_delegator_withdraw_rewards_event = 
  fun (ssn: ByStr20) =>
  fun (delegator : ByStr20) => 
  fun (amount : Uint128) =>
    { _eventname : "Delegator withdraw rewards"; ssn_address : ssn; delegator_address : delegator; rewards_amount : amount }


let mk_delegator_rewards_event = 
  fun (ssn : ByStr20) => 
  fun (delegator : ByStr20) =>
  fun (rewards : Uint128) =>
    { _eventname : "Delegator rewards"; ssn_address : ssn; delegator_address : delegator; rewards : rewards}

let mk_delegator_withdraw_amount_event = 
  fun (ssn : ByStr20) =>
    fun (delegator : ByStr20) =>
      { _eventname : "Delegator withdraw amount"; ssn_address : ssn; delegator_address : delegator}


let mk_update_delegate_cycle_event = 
  fun (ssn : ByStr20) =>
  fun (delegator : ByStr20) =>
    { _eventname : "Delegator update cycle"; ssn_address : ssn; delegator_address : delegator }

let mk_assign_stake_reward_event =
  fun (ssn : ByStr20) =>
  fun (total_reward : Uint128) =>
    { _eventname : "SSN assign reward"; ssn_address : ssn; total_reward : total_reward }

let mk_withdraw_stake_rewards_event =
  fun (ssn : ByStr20) =>
  fun (total_reward: Uint128) =>
    { _eventname : "SSN withdraw reward"; ssn_address : ssn; withdraw_total_reward : total_reward }

 let mk_deposit_funds_event =
  fun (sender : ByStr20) =>
    { _eventname : "Verifier deposit funds"; verifier : sender }

 let mk_withdraw_below_stake_limit_event =
    fun (ssn : ByStr20) =>
    fun (minstake: Uint128) =>
      { _eventname : "SSN withdrawal below min_stake limit"; ssn_address : ssn; minstake_limit : minstake }

 let mk_withdraw_above_stake_event =
    fun (ssn : ByStr20) =>
      { _eventname : "SSN withdrawal above stake"; ssn_address : ssn }

 let mk_withdraw_stake_buffered_deposit_exist =
    fun (ssn : ByStr20) =>
    fun (buffdeposit: Uint128) =>
      { _eventname : "SSN withdrawal not allowed when some deposit is bufferred"; ssn_address : ssn; buffered_stake_amount : buffdeposit }

(* Ssn - active_status , stake_amount, rewards, urlraw, urlapi, buffereddeposit, commission_rate, commision_rewards *)
(* Invariant 1: stake_amount + buffered_deposit < maxstake *)
(* Invariant 2: active_status = (minstake < stake_amount) *)

type Ssn =
| Ssn of Bool Uint128 Uint128 String String Uint128 Uint128 Uint128

type SsnRewardShare =
| SsnRewardShare of ByStr20 Uint128

(* 
    Each delegator has the following fields:

    StakeAmount       : Uint128
                        Represents the amount staked so far. This is the sum total of
                        amount staked across all SSNs. 
    StakeRewards      : Uint128
                        The rewards accumulatd so far from all SSNs. This is the sum total of reward accumulated across all SSNs. 
    Buffereddeposit   : Uint128
                        The deposit that needs to be in buffer until the next reward cycle and cannot be immediately
                        considered as a part of the staking. This is the sum total of buffereddeposits made across all SSNs.  
*)    

type Delegator =
| Delegator of Uint128 Uint128 Uint128


(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract SSNList(
  init_admin : ByStr20,
  proxy_address : ByStr20
)

(* Mutable fields *)

field ssnlist : Map ByStr20 Ssn = Emp ByStr20 Ssn
(* Keeps track of the delegators for each SSN.*)
(* AddressofSSN -> (AddressOfDelegator -> DelegatorInfo) *)
field delegators : Map ByStr20 (Map ByStr20 Delegator) = Emp ByStr20 (Map ByStr20 Delegator)
(* AddressofSSN -> (Blocknum -> Pair (TotalStakeAtThatBlockForTheSSN, TotalRewardEarned) *)
field stakeSSNPerCyle : Map ByStr20 (Map Uint32 PairForStakeSSNCycle) = Emp ByStr20 (Map Uint32 PairForStakeSSNCycle)
(* AddressofDelegator -> Blocknum *)
field lastWithdrawCycleForDelegator : Map ByStr20 Uint32 = Emp ByStr20 Uint32
(* AddressofDelegator -> (AddressofSSN -> (BlockNum -> StakeAmount)) *)
(* The StakeAmount will only be truely delegated at next around of BlockNum *)
(* todo rename *)
field bufferedDepositForDelegator : Map ByStr20 (Map ByStr20 (Map Uint32 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint32 Uint128))
(* The StakeAmount will be delegated at the BlockNum *)
(* AddressofDelegator -> (AddressofSSN -> (BlockNum -> StakeAmount)) *)
field directDepositForDelegator : Map ByStr20 (Map ByStr20 (Map Uint32 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint32 Uint128))
field rewardCycleList : List Uint32   =  Nil {Uint32} 

field verifier : Option ByStr20 = None {ByStr20}
field minstake : Uint128 = Uint128 0
field maxstake : Uint128 = Uint128 0
field contractmaxstake : Uint128 = Uint128 0
field totalstakedeposit : Uint128 = Uint128 0
field contractadmin : ByStr20  = init_admin
field lastrewardblocknum : Uint32 = Uint32 0
field paused : Bool = True

(* Procedures *)

(* Can be called by the verifier only *)
procedure validate_verifier (initiator : ByStr20)
  verifier_l <- verifier;
  match verifier_l with
  | Some v =>
    is_verifier = builtin eq initiator v;
    match is_verifier with
    | True =>
    | False =>
      e = mk_verifier_validation_failed_error initiator;
      throw e
    end
  | None =>
    e = mk_admin_validation_failed_error initiator;
    throw e
  end
end

(* Can be called by the current contract admin only *)
procedure validate_admin (initiator : ByStr20)
  contractadmin_l <- contractadmin;
  is_admin = builtin eq initiator contractadmin_l;
  match is_admin with
  | True =>
  | False =>
    e = mk_admin_validation_failed_error initiator;
    throw e
  end
end

(* Can be called by the proxy only *)
procedure validate_proxy ()
  is_proxy = builtin eq _sender proxy_address;
  match is_proxy with
  | True =>
  | False =>
    e = mk_proxy_validation_failed_error _sender;
    throw e
  end
end

(* Can be called by the proxy only *)
procedure is_paused ()
  paused_l <- paused;
  match paused_l with
  | False =>
  | True =>
    e = mk_contract_freezed_error _sender;
    throw e
  end
end

(* Can be called by the contract admin only *)
(* It is expected that transfer only happens to an exterally owned account*)
procedure TransferFunds (tag: String, amount : Uint128, recipient : ByStr20)
    msg = {_tag : tag; _recipient : recipient; _amount : amount};
    msgs = one_msg msg;
    send msgs
end

(* Can be called by the proxy only *)
procedure update_stake_reward (entry : SsnRewardShare)
  lastreward_block <- lastrewardblocknum;
  match entry with
  | SsnRewardShare ssnaddr reward_percent =>
    curval <- ssnlist[ssnaddr];
    match curval with
    | None =>
      e = mk_ssn_not_exists_event ssnaddr;
      event e
    | Some (Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit commission commission_rewards) =>
      match active_status with
      | False => throw
      | True  => 
        hundred = Uint128 100;
        new_reward = builtin mul stake_amount reward_percent;
        new_reward = builtin div new_reward hundred;
        new_reward = builtin div new_reward uint128_10_power_7;
       
        reward_commission_tmp = builtin mul new_reward commission;
        reward_commission_tmp = builtin div reward_commission_tmp hundred;
        reward_commission_tmp = builtin div reward_commission_tmp uint128_10_power_7;
        total_reward_commission = builtin add reward_commission_tmp commission_rewards;

        delegator_reward = let t = builtin sub new_reward total_reward_commission in builtin add t rewards;

        new_stake_amount = builtin add stake_amount buffereddeposit;
        p = PairForStakeSSNCycle stake_amount delegator_reward;
        stakeSSNPerCyle[ssnaddr][lastreward_block] := p;

        ssn = Ssn active_status new_stake_amount delegator_reward urlraw urlapi uint128_zero commission total_reward_commission;
        ssnlist[ssnaddr] := ssn;
        e = mk_assign_stake_reward_event ssnaddr total_reward_commission;
        event e
      end
    end
  end
end

(* this procedure is to send rewards to delegator for every reward cycle *)
procedure send_delegator_rewards(entry : Pair Uint32 DelegatorAndRewards)
  match entry with
  | Pair cycle delegator_and_rewards  =>
    match delegator_and_rewards with
    (* todo event? *)
    | DelegatorAndRewards address amount =>
      TransferFunds empty_tag amount address
    end
  end
  
end

procedure if_delegator_exist(ssnaddr: ByStr20, delegator: ByStr20)
  if_exist <- exists delegators[ssnaddr][delegator];
  match if_exist with
  | True =>
  | False =>
    e = mk_delegator_not_exists_event ssnaddr delegator;
    event e;
    throw
  end
end

procedure has_rewards_tobe_withdraw(delegator: ByStr20)
    last_reward_blockbum <- lastrewardblocknum;
    last_withdraw_cycle <- lastWithdrawCycleForDelegator[delegator];
    match last_withdraw_cycle with
    | Some cycle =>
      need_to_reward = builtin lt cycle last_reward_blockbum;
      match need_to_reward with
      | True =>
      | False =>
        e = { _eventname : "No need to rewards" };
        event e;
        throw
      end
    | None =>
      is_reward_block_zero = builtin eq last_reward_blockbum uint32_zore;
      match is_reward_block_zero with
      | True =>
        e = { _eventname : "No rewards record yet" };
        event e;
        throw
      | False =>
      end
    end
end


(* Transitions *)

(* @dev: pause/freeze the contract. Used by admin only. *)
(* @param initiator: The original caller who called the proxy *)
transition pause(initiator: ByStr20)
    validate_proxy;
    validate_admin initiator;
    paused := bool_active
end

(* @dev: unpause/unfreeze the contract. Used by admin only. *)
(* @param initiator: The original caller who called the proxy *)
transition unpause(initiator: ByStr20)
    validate_proxy;
    validate_admin initiator;
    paused := bool_inactive
end

(* @dev: Set the admin of contract. Used by admin only. *)
(* @param admin: New admin value *)
(* @param initiator: The original caller who called the proxy *)
transition update_admin (admin : ByStr20, initiator: ByStr20)
  validate_proxy;
  validate_admin initiator;
  contractadmin := admin
end

(* @dev: Set the verifier of contract. Used by admin only. *)
(* @param verif: New verifier value *)
(* @param initiator: The original caller who called the proxy *)
transition update_verifier (verif : ByStr20, initiator: ByStr20)
  validate_proxy;
  validate_admin initiator;
  newverifier = Some {ByStr20} verif;
  verifier := newverifier
end

(* @dev: Drain the entire contract balance. Used by current admin only. *)
(* @param initiator: The original caller who called the proxy *)
transition drain_contract_balance (initiator : ByStr20)
  validate_proxy;
  validate_admin initiator;
  bal <- _balance;
  TransferFunds multisig_tag_addfunds bal initiator
end

(* @dev: Set the minstake of contract. Used by admin only. *)
(* @param min_stake: New minstake value *)
(* @param initiator: The original caller who called the proxy *)
transition update_minstake (min_stake : Uint128, initiator : ByStr20)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  minstake := min_stake
end

(* @dev: Set the maxstake of contract. Used by admin only. *)
(* @param max_stake: New maxstake value *)
(* @param initiator: The original caller who called the proxy *)
transition update_maxstake (max_stake : Uint128, initiator : ByStr20)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  maxstake := max_stake
end

(* @dev: Set the maxstake of contract. Used by admin only. *)
(* @param max_stake: New maxstake value *)
(* @param initiator: The original caller who called the proxy *)
transition update_contractmaxstake (max_stake : Uint128, initiator : ByStr20)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  contractmaxstake := max_stake
end

(* @dev: Adds new ssn to ssnlist. Used by admin only. *)
(* @param ssnaddr: Address of the ssn to be added *)
(* @param stake_amount: Stake amount of ssn *)
(* @param rewards: Rewards of the ssn to be added *)
(* @param urlraw: string representing "ip:port" of the ssn serving raw api request *)
(* @param urlapi: string representing url exposed by ssn serving public api request *)
(* @param buffered_deposit: Any buffered stake deposit *)
(* @param initiator: The original caller who called the proxy *)
transition add_ssn(ssnaddr : ByStr20, stake_amount : Uint128, rewards : Uint128, urlraw : String, urlapi : String, buffered_deposit : Uint128, initiator : ByStr20, commission : Uint128, commission_rewards : Uint128)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  already_exists <- exists ssnlist[ssnaddr];
  match already_exists with
  | True  =>
    e = mk_ssn_already_exists_event ssnaddr;
    event e
  | False =>
    minstake_l <- minstake;
    maxstake_l <- maxstake;
    total_amount = builtin add stake_amount buffered_deposit;
    pass = builtin lt maxstake_l total_amount;
    match pass with
    | True  =>         
      e = mk_stake_deposit_above_stake_limit_event ssnaddr stake_amount maxstake_l;
      event e
    | False =>
      status = builtin lt minstake_l stake_amount;
      (* Update the total stake deposit *)
      totalstakedeposit_l <- totalstakedeposit;
      totalstakedeposit_l = builtin add totalstakedeposit_l stake_amount;
      totalstakedeposit := totalstakedeposit_l;
      s = Ssn status stake_amount rewards urlraw urlapi buffered_deposit commission commission_rewards;
      ssnlist[ssnaddr] := s;
      e = mk_ssn_added_event ssnaddr;
      event e
    end
  end
end

(* @dev: Adds new delegator. Used by admin only during contract upgrade. *)
(* @param ssnaddr: Address of the ssn *)
(* @param delegator: Address of the delegator *)
(* @param stake_amount: Stake amount *)
(* @param rewards: Rewards of the ssn to be added *)
(* @param buffered_deposit: Any buffered stake deposit *)
(* @param initiator: The original caller who called the proxy *)
transition add_delegator (ssnaddr : ByStr20, delegator : ByStr20, stake_amount : Uint128, rewards : Uint128, buffered_deposit : Uint128, initiator : ByStr20)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  already_exists <- exists delegators[ssnaddr][delegator];
  match already_exists with
  | True =>
    e = mk_delegator_already_exists_event ssnaddr delegator;
    event e
  | False =>
    d = Delegator stake_amount rewards buffered_deposit;
    delegators[ssnaddr][delegator] := d;
    e = mk_delegator_added_event ssnaddr delegator;
    event e
  end
end

(* @dev: Remove a specific ssn from ssnlist. Used by admin only. *)
(* @param ssnaddr: Address of the ssn to be removed *)
(* @param initiator: The original caller who called the proxy *)
transition remove_ssn (ssnaddr : ByStr20, initiator: ByStr20)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  already_exists <- exists ssnlist[ssnaddr];
  match already_exists with
  | False =>
    e = mk_ssn_not_exists_event ssnaddr;
    event e
  | True =>
    delete ssnlist[ssnaddr];
    e = mk_ssn_removed_event ssnaddr;
    event e
  end
end

(* @dev: Remove a specific delegator for a given SSN. Used by admin only. *)
(* @param ssnaddr: Address of the ssn to be removed *)
(* @param initiator: The original caller who called the proxy *)
transition remove_delegator (ssnaddr : ByStr20, delegator : ByStr20, initiator: ByStr20)
  is_paused;
  validate_proxy;
  validate_admin initiator;
  already_exists <- exists delegators[ssnaddr][delegator];
  match already_exists with
  | False =>
    e = mk_delegator_not_exists_event ssnaddr delegator;
    event e
  | True =>
    delete delegators[ssnaddr][delegator];
    e = mk_delegator_removed_event ssnaddr delegator;
    event e
  end
end

(* This is to be called in case the SSn is providing a non-custodial staking service *)
(* @param initiator: The original caller who called the proxy aka the delegator *)
(* @param ssnaddr: The address of the SSN to which the initiator wants to delegate his tokens *)
transition update_commission(new_rate : Uint128, initiator : ByStr20)
  is_paused;
  validate_proxy;
  curval <- ssnlist[initiator];
  match curval with
  | Some (Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit commission commision_rewards) =>
    ssn =  Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit new_rate commision_rewards;
    ssnlist[initiator] := ssn
  | None =>
    e = mk_ssn_not_exists_event initiator;
    event e
  end
end

transition delegate_stake(ssnaddr : ByStr20, initiator: ByStr20)
  is_paused;
  validate_proxy;
  (* Accept the deposit from SSN and add to contract balance. *)
  (* Transfer back to initiator if any of the validation failed *)
  accept;
  curval <- ssnlist[ssnaddr];
  match curval with
  | None =>
    TransferFunds empty_tag _amount initiator;
    e = mk_ssn_not_exists_event initiator;
    event e
  | Some (Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit commission commision_rewards) =>
    minstake_l <- minstake;
    maxstake_l <- maxstake;
    new_buff_amount  = builtin add _amount buffereddeposit;
    new_stake_amount = builtin add new_buff_amount stake_amount;
    pass = builtin lt maxstake_l new_stake_amount;
    last_reward_block_number <- lastrewardblocknum;
    match pass with
    | True  => (* stake deposit above maxstake limit for SSNs *)
      TransferFunds empty_tag _amount initiator;
      e = mk_delegated_stake_deposit_above_stake_limit_event ssnaddr initiator _amount maxstake_l;
      event e
    | False => 
      (*The delegated stake can be accepted. It is buffered if the SSN is active if not it is added to the stake_amount. *)
      match active_status with
      | True  => 
        (* The SSN is active so add the delegated stake to the buffer *)
        ssn = Ssn bool_active stake_amount rewards urlraw urlapi new_buff_amount commission commision_rewards;
        ssnlist[ssnaddr] := ssn;
        (* record this to direct deposit for delegator *)
        stake_amount_for_delegator_o <- directDepositForDelegator[initiator][ssnaddr][last_reward_block_number];
        d <- delegators[ssnaddr][initiator];
        match d with
        | Some (Delegator amount reward buffered_deposit) =>
          new_buff_amount_delegator = builtin add _amount buffered_deposit;
          d_new = Delegator amount reward new_buff_amount_delegator;
          delegators[ssnaddr][initiator] := d_new;
          match stake_amount_for_delegator_o with
          | Some stake_amount_for_delegator =>
            new_stake_amount_for_delegator = builtin add stake_amount_for_delegator _amount;
            directDepositForDelegator[initiator][ssnaddr][last_reward_block_number] := new_stake_amount_for_delegator
          | None =>
            directDepositForDelegator[initiator][ssnaddr][last_reward_block_number] := _amount
          end
        | None =>
          d_new = Delegator uint128_zero uint128_zero _amount;
          delegators[ssnaddr][initiator] := d_new;
          match stake_amount_for_delegator_o with
          | Some stake_amount_for_delegator =>
            new_stake_amount_for_delegator = builtin add stake_amount_for_delegator _amount;
            directDepositForDelegator[initiator][ssnaddr][last_reward_block_number] := new_stake_amount_for_delegator
          | None =>
            directDepositForDelegator[initiator][ssnaddr][last_reward_block_number] := _amount
          end
        end
      | False =>
        (* The SSN is inactive so add the delegated stake to stake_amount *)
        new_stake_amount  = builtin add _amount stake_amount;
        status = builtin lt minstake_l new_stake_amount;
        (* The SSN becomes active if the total stake after deposit is greater than the minimum required. *)
        ssn = Ssn status new_stake_amount rewards urlraw urlapi buffereddeposit commission commision_rewards;
        ssnlist[ssnaddr] := ssn;
        d <- delegators[ssnaddr][initiator];
        (* record this to buffered deposit for delegator *)
        stake_amount_for_delegator_o <- bufferedDepositForDelegator[initiator][ssnaddr][last_reward_block_number];
        match d with
        | Some (Delegator amount reward buffered_deposit) =>
          new_stake_amount_delegator = builtin add _amount amount;
          d_new = Delegator new_stake_amount_delegator reward buffered_deposit;
          delegators[ssnaddr][initiator] := d_new;
          match stake_amount_for_delegator_o with
          | Some stake_amount_for_delegator =>
            new_stake_amount_for_delegator = builtin add stake_amount_for_delegator _amount;
            bufferedDepositForDelegator[initiator][ssnaddr][last_reward_block_number] := new_stake_amount_for_delegator
          | None =>
            bufferedDepositForDelegator[initiator][ssnaddr][last_reward_block_number] := _amount
          end
        | None =>
          d_new = Delegator _amount uint128_zero uint128_zero;
          delegators[ssnaddr][initiator] := d_new;
          match stake_amount_for_delegator_o with
          | Some stake_amount_for_delegator =>
            new_stake_amount_for_delegator = builtin add stake_amount_for_delegator _amount;
            bufferedDepositForDelegator[initiator][ssnaddr][last_reward_block_number] := new_stake_amount_for_delegator
          | None =>
            bufferedDepositForDelegator[initiator][ssnaddr][last_reward_block_number] := _amount
          end
        end
      end
    end
  end
end

(* @dev: Assign stake reward to all ssn from ssnlist. Used by verifier only. *)
(* @param ssnrewardlist: List of SsnRewardShare *)
(* @param reward_blocknum: tx block num when ssns were verified *)
(* @param initiator: The original caller who called the proxy *)
transition assign_stake_reward(ssnreward_list : List SsnRewardShare, reward_blocknum : Uint32, initiator: ByStr20)
  is_paused;
  validate_proxy;
  validate_verifier initiator;
  last_reward_block <- lastrewardblocknum;
  res = builtin lt reward_blocknum last_reward_block;
  match res with
  | True  => 
  | False =>
    forall ssnreward_list update_stake_reward;
    lastrewardblocknum := reward_blocknum;
    reward_cycle_list <- rewardCycleList;
    nil_list = Nil {Uint32};
    to_be_append_list = Cons {Uint32} reward_blocknum nil_list;
    appender = @list_append Uint32;
    new_reward_cycle_list = appender to_be_append_list reward_cycle_list;
    rewardCycleList := new_reward_cycle_list
  end 
end


transition withdraw_commission(initiator : ByStr20)
  is_paused;
  validate_proxy;
  curval <- ssnlist[initiator];
  match curval with
  | None =>
    e = mk_ssn_not_exists_event initiator;
    event e
  | Some (Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit commission commission_rewards) =>
    TransferFunds empty_tag commission_rewards initiator;
    e = mk_withdraw_stake_rewards_event initiator rewards;  
    ssn = Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit commission uint128_zero;
    ssnlist[initiator] := ssn
  end
end


(* @dev: Move token amount from contract account to initiator. Used by ssn only. *)
(* @param amount: token amount to be withdrawed *)
(* @param initiator: The original caller who called the proxy *)
transition withdraw_stake_amount (amount : Uint128, initiator: ByStr20)
  is_paused;
  validate_proxy;
  curval <- ssnlist[initiator];
  match curval with
  | None =>
    e = mk_ssn_not_exists_event initiator;
    event e
  | Some (Ssn active_status stake_amount rewards urlraw urlapi buffereddeposit commission commission_rewards) =>
    pass = builtin eq buffereddeposit uint128_zero;
    match pass with
    | False =>
      e = mk_withdraw_stake_buffered_deposit_exist initiator buffereddeposit;
      event e
    | True =>
      pass = builtin lt amount stake_amount;
      match pass with
      | True => (* Partial withdrawal. so check for min balance after withdrawal for min stake limit *)
          bal_left = builtin sub stake_amount amount;
          minstake_l <- minstake;
          pass = builtin lt bal_left minstake_l;
          match pass with
          | True =>
            e = mk_withdraw_below_stake_limit_event initiator minstake_l;
            event e
          | False => (* pass minstake check for withdrawal *)
            (* Update the stake amount *)
            ssn = Ssn active_status bal_left rewards urlraw urlapi buffereddeposit commission commission_rewards;
            ssnlist[initiator] := ssn;
            (* Update the total stake deposit with contract *)
            totalstakedeposit_l <- totalstakedeposit;
            tmp = builtin sub totalstakedeposit_l amount;
            totalstakedeposit := tmp;
            TransferFunds empty_tag amount initiator
          end
      | False => (* requested withdrawal equals balance or greater than balance *)
          pass = builtin eq amount stake_amount;
          match pass with
          | False => (* withdrawal above available balance *)
            e = mk_withdraw_above_stake_event initiator;
            event e
          | True => (* pass withdrawal checks *)
            pass = builtin eq rewards uint128_zero;
            match pass with
            | True =>
              (* entire stake withdrawed and also reward is withdrawed, so remove ssn *)
              delete ssnlist[initiator]
            | False =>
              ssn = Ssn bool_inactive uint128_zero rewards urlraw urlapi buffereddeposit commission commission_rewards;
              ssnlist[initiator] := ssn
            end;
            totalstakedeposit_l <- totalstakedeposit;
            tmp = builtin sub totalstakedeposit_l amount;
            totalstakedeposit := tmp;
            TransferFunds empty_tag amount initiator
          end
        end
    end
  end
end


(* @dev: Withdraw stake reward. Can be called by a delegator. *)
(* @param initiator: The original caller who called the proxy *)
transition withdraw_stake_rewards(ssn_operator: ByStr20, delegator: ByStr20)
  is_paused;
  validate_proxy;
  if_delegator_exist ssn_operator delegator;
  lastWithdrawCycleForDelegator_m <- lastWithdrawCycleForDelegator[delegator];
  match lastWithdrawCycleForDelegator_m with
  (* it has withdraw record *)
  | Some last_withdraw_block =>
    last_reward_blocknum <- lastrewardblocknum;
    reward_cycle_list <- rewardCycleList;
    list_between_fun = list_between last_withdraw_block last_reward_blocknum;
    list_between_fun_uint32 = @list_filter Uint32;
    (* those are the cycles that we want to compute for computing rewards *)
    list_need_compute_rewards = list_between_fun_uint32 list_between_fun reward_cycle_list;

    (* direct deposit *)
    directDepositForDelegator_m <- directDepositForDelegator[delegator][ssn_operator];
    direct_deposits_for_delegator = deposit_value_or_empty directDepositForDelegator_m;

    (* buffered deposit *)
    bufferedDepositForDelegator_m <- bufferedDepositForDelegator[delegator][ssn_operator];
    buffered_deposits_for_delegator = deposit_value_or_empty bufferedDepositForDelegator_m;

    (* combine two deposit list *)
    init_map = Emp Uint32 Uint128;
    foldl = @list_foldl Uint32 Map Uint32 Uint128;
    staking_init_map = Emp Uint32 Uint128;
    iter = combine_buffered_and_direct direct_deposits_for_delegator buffered_deposits_for_delegator;
    combined_direct_and_buffered_map = foldl iter init_map list_need_compute_rewards;


    (* to calculate final staking per cycle for delegators *)
    iter = caculate_all_stake_per_cycle combined_direct_and_buffered_map;
    stake_delegator_per_cycle = foldl iter staking_init_map list_need_compute_rewards;

    stake_ssn_per_cycle_m <- stakeSSNPerCyle[ssn_operator];
    match stake_ssn_per_cycle_m with 
    | Some stake_ssn_per_cycle =>
     (* to calculate staking rewards per cycle for delegator *)
     reward_per_cycle_for_delegator_init = Emp Uint32 DelegatorAndRewards;
     foldl_a = @list_foldl Uint32 Map Uint32 DelegatorAndRewards;
     calculate_rewards_per_cycly_for_delegator_iter = calculate_rewards_per_cycly_for_delegator delegator stake_delegator_per_cycle stake_ssn_per_cycle;
     rewards_delegator_per_cycle = foldl_a calculate_rewards_per_cycly_for_delegator_iter reward_per_cycle_for_delegator_init list_need_compute_rewards;

     (* to send those rewards and update last withdraw cycle of delegator *)
     rewards_delegator_per_cycle_list = builtin to_list rewards_delegator_per_cycle;
     forall rewards_delegator_per_cycle_list send_delegator_rewards;
     lastWithdrawCycleForDelegator[delegator] := last_reward_blocknum;
     e = mk_update_delegate_cycle_event ssn_operator delegator;
     event e
    | None => (* ssn has no rewards *)
    end  
    (* todo it has no withdraw record, we set it to 0 than copy and paster *)
    (* or we should set the first value for them *)
  | None => 
    e = mk_update_delegate_cycle_event ssn_operator delegator;
    event e
  end
  
end

(* @dev: Move token amount from contract account to initiator. Use by delegator only. *)
(* @param initiator: The original caller who called the proxy *)
(* withdraw all delegate amount all at once *)
transition withdraw_delegate_amount (ssn: ByStr20, initator: ByStr20)
  is_paused;
  validate_proxy;
  if_delegator_exist ssn initator;
  has_rewards_tobe_withdraw initator;
  (* todo *)
  e = mk_delegator_withdraw_amount_event ssn initator;
  event e

end

(* @dev: Move token amount from initiator to recipient i.e. contract address. *)
(* @param initiator: The original caller who called the proxy *)
transition deposit_funds (initiator : ByStr20)
  is_paused;
  validate_proxy;
  accept;
  e = mk_deposit_funds_event initiator;
  event e
end
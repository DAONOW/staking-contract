scilla_version 0
import IntUtils ListUtils
library GZIL
let one_msg =
fun (msg: Message) =>
let nil_msg = Nil {Message} in
Cons {Message} msg nil_msg
let two_msgs =
fun (msg1: Message) =>
fun (msg2: Message) =>
let msgs_tmp = one_msg msg2 in
Cons {Message} msg1 msgs_tmp
type Error =
| CodeIsSender
| CodeInsufficientFunds
| CodeInsufficientAllowance
| CodeNotOwner
| CodeNotMinter
| CodeNotProxy
let make_error =
fun (result: Error) =>
let result_code =
match result with
| CodeIsSender              => Int32 -1
| CodeInsufficientFunds     => Int32 -2
| CodeInsufficientAllowance => Int32 -3
| CodeNotOwner              => Int32 -4
| CodeNotMinter             => Int32 -5
| CodeNotProxy              => Int32 -6
end
in
{ _exception: "Error"; code: result_code }
let zero = Uint128 0
type Unit =
| Unit
let get_val =
fun (some_val: Option Uint128) =>
match some_val with
| Some val => val
| None => zero
end
contract GZIL
(
contract_owner: ByStr20,
proxy_address: ByStr20,
init_minter: ByStr20,
name: String,
symbol: String,
decimals: Uint32,
init_supply: Uint128
)
field total_supply: Uint128 = init_supply
field balances: Map ByStr20 Uint128 = Emp ByStr20 Uint128
field allowances: Map ByStr20 (Map ByStr20 Uint128)
= Emp ByStr20 (Map ByStr20 Uint128)
field minter: ByStr20 = init_minter
procedure ThrowError(err: Error)
e = make_error err;
throw e
end
procedure IsOwner(address: ByStr20)
is_owner = builtin eq contract_owner address;
match is_owner with
| True =>
| False =>
err = CodeNotOwner;
ThrowError err
end
end
procedure AuthorizedBurnIfSufficientBalance(from: ByStr20, amount: Uint128)
get_bal <- balances[from];
match get_bal with
| Some bal =>
can_burn = uint128_le amount bal;
match can_burn with
| True =>
new_balance = builtin sub bal amount;
balances[from] := new_balance;
current_total_supply <- total_supply;
new_total_supply = builtin sub current_total_supply amount;
total_supply := new_total_supply;
e = {_eventname: "Burnt"; burner: _sender; burn_account: from; amount: amount};
event e
| False =>
err = CodeInsufficientFunds;
ThrowError err
end
| None =>
err = CodeInsufficientFunds;
ThrowError err
end
end
procedure IsProxy()
is_proxy = builtin eq _sender proxy_address;
match is_proxy with
| True  =>
| False =>
e = CodeNotProxy;
ThrowError e
end
end
procedure IsMinter(address: ByStr20)
current_minter <- minter;
is_minter = builtin eq current_minter address;
match is_minter with
| True =>
| False =>
err = CodeNotMinter;
ThrowError err
end
end
procedure IsNotSender(address: ByStr20)
is_sender = builtin eq _sender address;
match is_sender with
| True =>
err = CodeIsSender;
ThrowError err
| False =>
end
end
procedure AuthorizedMint(recipient: ByStr20, amount: Uint128)
some_bal <- balances[recipient];
bal = get_val some_bal;
new_balance = builtin add amount bal;
balances[recipient] := new_balance;
current_total_supply <- total_supply;
new_total_supply = builtin add current_total_supply amount;
total_supply := new_total_supply;
e = {_eventname: "Minted"; minter: _sender; recipient: recipient; amount: amount};
event e
end
procedure AuthorizedMoveIfSufficientBalance(from: ByStr20, to: ByStr20, amount: Uint128)
get_from_bal <- balances[from];
match get_from_bal with
| Some bal =>
can_do = uint128_le amount bal;
match can_do with
| True =>
new_from_bal = builtin sub bal amount;
balances[from] := new_from_bal;
get_to_bal <- balances[to];
new_to_bal = match get_to_bal with
| Some bal => builtin add bal amount
| None => amount
end;
balances[to] := new_to_bal
| False =>
err = CodeInsufficientFunds;
ThrowError err
end
| None =>
err = CodeInsufficientFunds;
ThrowError err
end
end
transition ChangeMinter(new_minter: ByStr20, initiator: ByStr20)
IsProxy;
IsOwner initiator;
minter := new_minter;
e = {_eventname: "ChangedMinter"; new_minter: new_minter};
event e
end
transition Mint(recipient: ByStr20, amount: Uint128)
IsMinter _sender;
AuthorizedMint recipient amount;
msg_to_recipient = {_tag: "RecipientAcceptMint"; _recipient: recipient; _amount: zero;
minter: _sender; recipient: recipient; amount: amount};
msgs = one_msg msg_to_recipient;
send msgs
end
transition Burn(burn_account: ByStr20, amount: Uint128)
IsMinter _sender;
AuthorizedBurnIfSufficientBalance burn_account amount;
msg_to_sender = {_tag: "BurnSuccessCallBack"; _recipient: _sender; _amount: zero;
burner: _sender; burn_account: burn_account; amount: amount};
msgs = one_msg msg_to_sender;
send msgs
end
transition IncreaseAllowance(spender: ByStr20, amount: Uint128)
IsNotSender spender;
some_current_allowance <- allowances[_sender][spender];
current_allowance = get_val some_current_allowance;
new_allowance = builtin add current_allowance amount;
allowances[_sender][spender] := new_allowance;
e = {_eventname: "IncreasedAllowance"; token_owner: _sender; spender: spender; new_allowance: new_allowance};
event e
end
transition DecreaseAllowance(spender: ByStr20, amount: Uint128)
IsNotSender spender;
some_current_allowance <- allowances[_sender][spender];
current_allowance = get_val some_current_allowance;
new_allowance =
let amount_le_allowance = uint128_le amount current_allowance in
match amount_le_allowance with
| True => builtin sub current_allowance amount
| False => zero
end;
allowances[_sender][spender] := new_allowance;
e = {_eventname: "DecreasedAllowance"; token_owner: _sender; spender: spender; new_allowance: new_allowance};
event e
end
transition Transfer(to: ByStr20, amount: Uint128)
AuthorizedMoveIfSufficientBalance _sender to amount;
e = {_eventname : "TransferSuccess"; sender : _sender; recipient : to; amount : amount};
event e;
msg_to_recipient = {_tag: "RecipientAcceptTransfer"; _recipient: to; _amount: zero;
sender: _sender; recipient: to; amount: amount};
msg_to_sender = {_tag: "TransferSuccessCallBack"; _recipient: _sender; _amount: zero;
sender: _sender; recipient: to; amount: amount};
msgs = two_msgs msg_to_recipient msg_to_sender;
send msgs
end
transition TransferFrom(from: ByStr20, to: ByStr20, amount: Uint128)
get_spender_allowed <- allowances[from][_sender];
match get_spender_allowed with
| Some allowed =>
can_do = uint128_le amount allowed;
match can_do with
| True =>
AuthorizedMoveIfSufficientBalance from to amount;
e = {_eventname : "TransferFromSuccess"; initiator : _sender; sender : from; recipient : to; amount : amount};
event e;
new_allowed = builtin sub allowed amount;
allowances[from][_sender] := new_allowed;
msg_to_recipient = {_tag: "RecipientAcceptTransferFrom"; _recipient : to; _amount: zero;
initiator: _sender; sender : from; recipient: to; amount: amount};
msg_to_sender = {_tag: "TransferFromSuccessCallBack"; _recipient: _sender; _amount: zero;
initiator: _sender; sender: from; recipient: to; amount: amount};
msgs = two_msgs msg_to_recipient msg_to_sender;
send msgs
| False =>
err = CodeInsufficientAllowance;
ThrowError err
end
| None =>
err = CodeInsufficientAllowance;
ThrowError err
end
end
